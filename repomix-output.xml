This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: tst/, tsconfig.tsbuildinfo, bun.locl, .yaml, .json, src/scripts/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
convex/
  _generated/
    api.d.ts
    api.js
    dataModel.d.ts
    server.d.ts
    server.js
  emails/
    RelocationReport.tsx
  mutate/
    city.ts
    date.ts
    flight.ts
    rental.ts
  query/
    city.ts
  schemas/
    city.ts
    conversation.ts
    date.ts
    document.ts
    flight.ts
    message.ts
    rental.ts
    subscription.ts
    user.ts
    visa.ts
    zod_schemas.ts
  tools/
    citySearch.ts
    conversationTracker.ts
    costEstimation.ts
    documentDetails.ts
    emailCapture.ts
    pdfSender.ts
    updateUserReport.ts
    visaRequirements.ts
  city.ts
  conversations.ts
  http.ts
  mcp.ts
  README.md
  schema.ts
  simulations.ts
  storage.ts
  subscriptions.ts
  tsconfig.json
public/
  file.svg
  globe.svg
  next.svg
  pdf-worker.js
  SYSTEM.md
  vercel.svg
  window.svg
scripts/
  manage-vapi-tools.ts
  register-vapi-tools.ts
  updateVapiAssistant.ts
simulations/
  backend/
    app/
      __init__.py
      main.py
      prompts.py
    Dockerfile
    requirements.txt
  frontend/
    static/
      index.html
    Dockerfile
    nginx.conf
  docker-compose.dev.yml
  docker-compose.yml
  README.md
src/
  app/
    account/
      page.tsx
    api/
      create-checkout/
        route.ts
      email/
        route.ts
      polar/
        checkout/
          route.ts
        webhook/
          route.ts
    billing/
      page.tsx
    callback/
      route.ts
    checkout/
      page.tsx
    success/
      page.tsx
    actions.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    DecryptedText.tsx
    DecryptedTextDemo.tsx
    EmailCaptureModal.tsx
    LandingHero.tsx
    Navigation.tsx
    ResultCard.tsx
    SimulationModal.tsx
    StreamingResults.tsx
    TextVelocity.tsx
    VapiButton.tsx
    VapiConversationIndicator.tsx
    VapiExample.tsx
  hooks/
    usePDFUpload.ts
    useStreamingSearch.ts
    useVapi.tsx
    useVapiCall.ts
  lib/
    mcp/
      exa-tools.ts
    pdf/
      generatePDF.ts
  providers/
    ConvexClientProvider.tsx
    VapiProvider.tsx
  types/
    html2pdf.d.ts
  middleware.ts
.gitignore
CLAUDE.md
eslint.config.mjs
IMPLE_BAK.md
IMPLEMENTATION_PLAN.md
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(pnpm add:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="convex/simulations.ts">
import { v } from "convex/values";
import { action } from "./_generated/server";
import { OpenAI } from "openai";

const SCENARIO_LABELS = {
  cheapest: "The Frugal Mover",
  balanced: "The Balanced Mover",
  fastest: "The Fast-Track Mover",
  luxury: "The Premier Mover",
} as const;

type ScenarioType = keyof typeof SCENARIO_LABELS;

function buildMessages(
  payload: {
    start_city?: string;
    destination_city?: string;
    budget_range?: string;
    move_month?: string;
    context?: string;
  },
  scenario: ScenarioType
) {
  const start = payload.start_city?.trim() || "";
  const dest = payload.destination_city?.trim() || "";
  const budget = payload.budget_range?.trim() || "";
  const month = payload.move_month?.trim() || "";
  const context = payload.context?.trim() || "";

  const scenarioLabel = SCENARIO_LABELS[scenario];

  const scenarioBias = {
    cheapest:
      "Prioritize minimizing cost. Prefer DIY options, budget flights, shared or modest housing, and longer timelines if it saves money.",
    balanced:
      "Balance cost, time, and convenience. Choose realistic, middle-of-the-road options likely for most movers.",
    fastest:
      "Prioritize speed. Use approaches that reduce waiting time even at higher cost; consider premium processing, temporary housing to accelerate arrival, etc.",
    luxury:
      "Prioritize convenience and service quality. Assume use of relocation agents, premium services, and higher budgets to reduce stress and delays.",
  }[scenario];

  const system = `
ROLE AND GOAL
You are an expert relocation logistics simulator. Your goal is to generate one distinct, realistic simulation for the mover based on the provided inputs and the specified scenario style.

CORE VARIABLES (INPUTS)
- Profile: Not provided explicitly; infer a reasonable baseline family profile unless context specifies otherwise.
- Origin: ${start}
- Destination: ${dest}
- Budget Range: ${budget}
- Ideal Move Month: ${month}
- Additional Context: ${context}

SIMULATION LOGIC (PROCESS)
For the destination, simulate the full relocation process and estimate both cost and time for:
1) Visa & Immigration (path, docs, processing times, fees)
2) Pet Relocation (requirements, costs, timeline) if relevant
3) Housing (rental process, average rent, deposits, agent fees)
4) Cost of Living Adjustment (salary vs. taxes and expenses)
5) Setup Costs (shipping, flights, temporary housing)
6) Timeline Estimation (Gantt-style phases with dependencies)

SCENARIO STYLE
Scenario: ${scenarioLabel}
Guidance: ${scenarioBias}

OUTPUT FORMAT
Return a concise Markdown block containing:
- A short headline for the scenario
- Bullet summaries for each factor with concrete estimates
- Total Estimated Cost (USD) and Estimated Timeline (months)
- One major pro and one major con
- A feasibility score (1-10)
`.trim();

  const user = "Using the inputs above, produce the simulation. Be concrete and avoid filler.";

  return [
    { role: "system" as const, content: system },
    { role: "user" as const, content: user },
  ];
}

export const streamSimulation = action({
  args: {
    start_city: v.optional(v.string()),
    destination_city: v.optional(v.string()),
    budget_range: v.optional(v.string()),
    move_month: v.optional(v.string()),
    context: v.optional(v.string()),
    scenario: v.union(
      v.literal("cheapest"),
      v.literal("fastest"),
      v.literal("balanced"),
      v.literal("luxury")
    ),
  },
  handler: async (ctx, args) => {
    const openai = new OpenAI({
      apiKey: process.env.OPEN_AI_API,
    });

    const messages = buildMessages(
      {
        start_city: args.start_city,
        destination_city: args.destination_city,
        budget_range: args.budget_range,
        move_month: args.move_month,
        context: args.context,
      },
      args.scenario
    );

    const stream = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages,
      stream: true,
    });

    const chunks: string[] = [];
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || "";
      if (content) {
        chunks.push(content);
      }
    }

    return chunks.join("");
  },
});

export const generateTimeline = action({
  args: {
    scenario_key: v.optional(v.string()),
    scenario_title: v.optional(v.string()),
    raw_text: v.string(),
    preferences: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const openai = new OpenAI({
      apiKey: process.env.OPEN_AI_API,
    });

    let rawText = args.raw_text.trim();
    if (rawText.length > 12000) {
      rawText = rawText.substring(0, 12000);
    }

    const schemaDesc = {
      headline: "string",
      budget_total_usd: "number",
      timeframe_months: "integer",
      phases: [
        {
          name: "string",
          start_month: "integer",
          end_month: "integer",
          summary: "string",
          tasks: [
            {
              title: "string",
              desc: "string",
              cost_usd: "number",
              duration_weeks: "number",
              milestone: "boolean",
            },
          ],
        },
      ],
      milestones: [{ title: "string", month: "number", note: "string" }],
      notes: "string",
      confidence: "number between 0 and 1",
    };

    const system =
      "You are a relocation timeline extractor. Read the scenario text and produce a concise, normalized timeline JSON matching the provided schema. Use reasonable defaults when needed. Return strictly valid JSON with no prose.";

    const user = {
      scenario_key: args.scenario_key,
      scenario_title: args.scenario_title,
      preferences: args.preferences || {},
      schema: schemaDesc,
      scenario_text: rawText,
      rules: [
        "Infer total budget (USD) and timeframe (months) if implied",
        "Limit tasks per phase to at most 6 concise items",
        "Mark key steps as milestone: true",
        "Clamp negative numbers to zero and omit impossible fields",
        "Omit null fields where not applicable",
      ],
    };

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: system + " Strictly output JSON only." },
        { role: "user", content: JSON.stringify(user) },
      ],
      response_format: { type: "json_object" },
    });

    const content = response.choices[0]?.message?.content || "{}";
    const data = JSON.parse(content);

    // Coerce numbers to proper types
    if (typeof data.timeframe_months === "number") {
      data.timeframe_months = Math.max(0, Math.round(data.timeframe_months));
    }

    if (Array.isArray(data.phases)) {
      for (const phase of data.phases) {
        if (typeof phase.start_month === "number") {
          phase.start_month = Math.max(0, Math.round(phase.start_month));
        }
        if (typeof phase.end_month === "number") {
          phase.end_month = Math.max(0, Math.round(phase.end_month));
        }
        if (
          phase.start_month !== undefined &&
          phase.end_month !== undefined &&
          phase.end_month < phase.start_month
        ) {
          phase.end_month = phase.start_month;
        }
      }
    }

    return data;
  },
});
</file>

<file path="src/components/SimulationModal.tsx">
"use client";

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "motion/react";
import { useAction } from "convex/react";
import { api } from "../../convex/_generated/api";
import DecryptedText from "./DecryptedText";

interface SimulationModalProps {
  isOpen: boolean;
  onClose: () => void;
  startCity?: string;
  destinationCity?: string;
}

const scenarios = [
  { key: "cheapest" as const, label: "Cheapest Options" },
  { key: "fastest" as const, label: "Fastest Options" },
  { key: "balanced" as const, label: "Balanced Options" },
  { key: "luxury" as const, label: "Luxury Options" },
];

const loadingPhrases = [
  "Analyzing the unique cultural fabric and social atmosphere of each district",
  "Aggregating and cross-referencing thousands of current rental market listings",
  "Simulating daily commute routes via public transit, driving, and cycling options",
  "Evaluating curriculum standards and admission availability at international schools",
  "Calculating a detailed, personalized cost of living index against your income",
  "Investigating and outlining the most viable long-term visa and residency pathways",
  "Scoring local coworking spaces based on amenities, community reviews, and pricing",
  "Correlating official crime statistics with hyperlocal resident safety sentiment data",
  "Pinpointing public parks, nature reserves, and recreational green spaces nearby",
  "Identifying popular and hidden-gem destinations for enriching weekend excursions",
];

export function SimulationModal({
  isOpen,
  onClose,
  startCity = "",
  destinationCity = "",
}: SimulationModalProps) {
  const [formData, setFormData] = useState({
    start_city: startCity,
    destination_city: destinationCity,
    budget_min: "",
    budget_max: "",
    move_month: "",
    context: "",
  });

  const [isRunning, setIsRunning] = useState(false);
  const [results, setResults] = useState<Record<string, string>>({});
  const [timelines, setTimelines] = useState<Record<string, TimelineData>>({});
  const [expandedScenario, setExpandedScenario] = useState<string | null>(null);
  const [loadingStates, setLoadingStates] = useState<Record<string, boolean>>(
    {}
  );
  const [currentPhrases, setCurrentPhrases] = useState<Record<string, string>>(
    {}
  );
  const [isFormCollapsed, setIsFormCollapsed] = useState(false);

  const streamSimulation = useAction(api.simulations.streamSimulation);
  const generateTimeline = useAction(api.simulations.generateTimeline);

  useEffect(() => {
    setFormData((prev) => ({
      ...prev,
      start_city: startCity,
      destination_city: destinationCity,
    }));
  }, [startCity, destinationCity]);

  useEffect(() => {
    if (!isRunning) return;

    const interval = setInterval(() => {
      setCurrentPhrases((prev) => {
        const newPhrases = { ...prev };
        scenarios.forEach((scenario) => {
          if (loadingStates[scenario.key]) {
            newPhrases[scenario.key] =
              loadingPhrases[Math.floor(Math.random() * loadingPhrases.length)];
          }
        });
        return newPhrases;
      });
    }, 500);

    return () => clearInterval(interval);
  }, [isRunning, loadingStates]);

  const formatBudgetRange = () => {
    const min = formData.budget_min ? Number(formData.budget_min) : null;
    const max = formData.budget_max ? Number(formData.budget_max) : null;

    if (min && max && max >= min) {
      return `$${min.toLocaleString()} - $${max.toLocaleString()}`;
    } else if (min) {
      return `Over $${min.toLocaleString()}`;
    } else if (max) {
      return `Under $${max.toLocaleString()}`;
    }
    return "";
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsRunning(true);
    setIsFormCollapsed(true);
    setResults({});
    setTimelines({});
    setExpandedScenario(null);

    const budgetRange = formatBudgetRange();

    // Initialize loading states
    const initialLoadingStates: Record<string, boolean> = {};
    scenarios.forEach((s) => {
      initialLoadingStates[s.key] = true;
    });
    setLoadingStates(initialLoadingStates);

    // Run all scenarios in parallel
    const promises = scenarios.map(async (scenario) => {
      try {
        const result = await streamSimulation({
          start_city: formData.start_city,
          destination_city: formData.destination_city,
          budget_range: budgetRange,
          move_month: formData.move_month,
          context: formData.context,
          scenario: scenario.key,
        });

        setResults((prev) => ({ ...prev, [scenario.key]: result }));
        setLoadingStates((prev) => ({ ...prev, [scenario.key]: false }));

        // Generate timeline
        const timeline = await generateTimeline({
          scenario_key: scenario.key,
          scenario_title: scenario.label,
          raw_text: result.slice(0, 15000),
        });

        setTimelines((prev) => ({ ...prev, [scenario.key]: timeline }));
      } catch (error) {
        console.error(`Error in ${scenario.key}:`, error);
        setResults((prev) => ({
          ...prev,
          [scenario.key]: `Error: ${error}`,
        }));
        setLoadingStates((prev) => ({ ...prev, [scenario.key]: false }));
      }
    });

    await Promise.all(promises);
    setIsRunning(false);
  };

  const handleClear = () => {
    setFormData({
      start_city: startCity,
      destination_city: destinationCity,
      budget_min: "",
      budget_max: "",
      move_month: "",
      context: "",
    });
    setResults({});
    setTimelines({});
    setExpandedScenario(null);
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 bg-black/80 backdrop-blur-sm z-40 flex items-center justify-center p-4"
          onClick={onClose}
        >
          <motion.div
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
            className="bg-black border border-green-500/30 w-full max-w-6xl max-h-[90vh] overflow-y-auto relative"
            onClick={(e) => e.stopPropagation()}
            style={{
              boxShadow: "0 0 40px rgba(0, 255, 0, 0.1)",
            }}
          >
            <div className="sticky top-0 bg-black border-b border-green-500/30 p-6 z-10">
              <div className="flex items-center justify-between">
                <h2 className="text-2xl font-bold text-green-500 tracking-wider">
                  RELOCATION SIMULATIONS
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 hover:text-green-500 transition-colors transform hover:scale-110"
                >
                  <svg
                    className="w-6 h-6"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M6 18L18 6M6 6l12 12"
                    />
                  </svg>
                </button>
              </div>
            </div>

            <div className="p-6">
              <form onSubmit={handleSubmit} className="mb-8">
                {/* Form header with collapse toggle */}
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-sm text-gray-500 uppercase tracking-wider">
                    Simulation Parameters
                  </h3>
                  {(isRunning || Object.keys(results).length > 0) && (
                    <button
                      type="button"
                      onClick={() => setIsFormCollapsed(!isFormCollapsed)}
                      className="text-gray-500 hover:text-green-500 transition-colors"
                    >
                      <svg
                        className={`w-5 h-5 transition-transform ${
                          isFormCollapsed ? "" : "rotate-180"
                        }`}
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M5 15l7-7 7 7"
                        />
                      </svg>
                    </button>
                  )}
                </div>
                
                <AnimatePresence>
                  {!isFormCollapsed && (
                    <motion.div
                      initial={{ height: "auto", opacity: 1 }}
                      animate={{ height: "auto", opacity: 1 }}
                      exit={{ height: 0, opacity: 0 }}
                      transition={{ duration: 0.3 }}
                      className="overflow-hidden"
                    >
                      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                  <div className="space-y-2">
                    <label className="text-xs text-gray-500 uppercase tracking-wider">
                      Start City
                    </label>
                    <input
                      type="text"
                      value={formData.start_city}
                      onChange={(e) =>
                        setFormData({ ...formData, start_city: e.target.value })
                      }
                      placeholder="San Francisco, CA, USA"
                      className="w-full bg-black border border-green-500/30 px-3 py-2 text-green-500 placeholder-gray-600 focus:border-green-500 focus:outline-none transition-all transform hover:scale-x-[1.02]"
                    />
                  </div>

                  <div className="space-y-2">
                    <label className="text-xs text-gray-500 uppercase tracking-wider">
                      Destination City
                    </label>
                    <input
                      type="text"
                      value={formData.destination_city}
                      onChange={(e) =>
                        setFormData({
                          ...formData,
                          destination_city: e.target.value,
                        })
                      }
                      placeholder="Lisbon, Portugal"
                      className="w-full bg-black border border-green-500/30 px-3 py-2 text-green-500 placeholder-gray-600 focus:border-green-500 focus:outline-none transition-all transform hover:scale-x-[1.02]"
                    />
                  </div>

                  <div className="space-y-2">
                    <label className="text-xs text-gray-500 uppercase tracking-wider">
                      Min Budget (USD)
                    </label>
                    <input
                      type="number"
                      value={formData.budget_min}
                      onChange={(e) =>
                        setFormData({ ...formData, budget_min: e.target.value })
                      }
                      placeholder="25000"
                      className="w-full bg-black border border-green-500/30 px-3 py-2 text-green-500 placeholder-gray-600 focus:border-green-500 focus:outline-none transition-all transform hover:scale-x-[1.02]"
                    />
                  </div>

                  <div className="space-y-2">
                    <label className="text-xs text-gray-500 uppercase tracking-wider">
                      Max Budget (USD)
                    </label>
                    <input
                      type="number"
                      value={formData.budget_max}
                      onChange={(e) =>
                        setFormData({ ...formData, budget_max: e.target.value })
                      }
                      placeholder="50000"
                      className="w-full bg-black border border-green-500/30 px-3 py-2 text-green-500 placeholder-gray-600 focus:border-green-500 focus:outline-none transition-all transform hover:scale-x-[1.02]"
                    />
                  </div>

                  <div className="space-y-2 lg:col-span-2">
                    <label className="text-xs text-gray-500 uppercase tracking-wider">
                      Ideal Move Month
                    </label>
                    <input
                      type="month"
                      value={formData.move_month}
                      onChange={(e) =>
                        setFormData({ ...formData, move_month: e.target.value })
                      }
                      className="w-full bg-black border border-green-500/30 px-3 py-2 text-green-500 placeholder-gray-600 focus:border-green-500 focus:outline-none transition-all transform hover:scale-x-[1.02]"
                    />
                  </div>

                  <div className="space-y-2 lg:col-span-2">
                    <label className="text-xs text-gray-500 uppercase tracking-wider">
                      Additional Context
                    </label>
                    <textarea
                      value={formData.context}
                      onChange={(e) =>
                        setFormData({ ...formData, context: e.target.value })
                      }
                      placeholder="e.g., family with dog, school priority, job details, constraints"
                      rows={3}
                      className="w-full bg-black border border-green-500/30 px-3 py-2 text-green-500 placeholder-gray-600 focus:border-green-500 focus:outline-none transition-all transform hover:scale-x-[1.02] resize-none"
                    />
                  </div>
                </div>
                    </motion.div>
                  )}
                </AnimatePresence>

                <div className="flex justify-end gap-4">
                  <button
                    type="button"
                    onClick={handleClear}
                    className="px-6 py-2 border border-green-500/30 text-gray-500 hover:text-green-500 hover:border-green-500 transition-all transform hover:scale-x-105 hover:scale-y-105 active:bg-green-500 active:text-black"
                  >
                    Clear
                  </button>
                  <button
                    type="submit"
                    disabled={isRunning}
                    className="px-6 py-2 bg-green-500/10 border border-green-500 text-green-500 hover:bg-green-500/20 transition-all transform hover:scale-x-105 hover:scale-y-105 active:bg-green-500 active:text-black disabled:opacity-50 disabled:cursor-not-allowed relative"
                  >
                    {isRunning ? (
                      <span className="flex items-center gap-2">
                        <span className="inline-block w-4 h-4 border-2 border-green-500 border-t-transparent animate-spin"></span>
                        Streaming...
                      </span>
                    ) : (
                      "Run 4 Scenarios"
                    )}
                  </button>
                </div>
              </form>

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {scenarios.map((scenario) => (
                  <ScenarioCard
                    key={scenario.key}
                    scenario={scenario}
                    result={results[scenario.key]}
                    timeline={timelines[scenario.key]}
                    isLoading={loadingStates[scenario.key]}
                    loadingPhrase={currentPhrases[scenario.key]}
                    isExpanded={expandedScenario === scenario.key}
                    onToggleExpand={() =>
                      setExpandedScenario(
                        expandedScenario === scenario.key ? null : scenario.key
                      )
                    }
                  />
                ))}
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

interface TimelineTask {
  title: string;
  desc?: string;
  cost_usd?: number;
  duration_weeks?: number;
  milestone?: boolean;
}

interface TimelinePhase {
  name: string;
  start_month?: number;
  end_month?: number;
  summary?: string;
  tasks?: TimelineTask[];
}

interface TimelineData {
  headline?: string;
  budget_total_usd?: number;
  timeframe_months?: number;
  phases?: TimelinePhase[];
  milestones?: Array<{ title: string; month: number; note: string }>;
  notes?: string;
  confidence?: number;
}

interface ScenarioCardProps {
  scenario: { key: string; label: string };
  result?: string;
  timeline?: TimelineData;
  isLoading?: boolean;
  loadingPhrase?: string;
  isExpanded?: boolean;
  onToggleExpand?: () => void;
}

function ScenarioCard({
  scenario,
  result,
  timeline,
  isLoading,
  loadingPhrase,
  isExpanded,
  onToggleExpand,
}: ScenarioCardProps) {
  return (
    <motion.div
      className="bg-black border border-green-500/30 p-4 relative overflow-hidden"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <div className="absolute inset-0 bg-gradient-to-br from-green-500/5 to-transparent pointer-events-none" />

      <div className="relative z-10">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-sm font-bold text-green-500 uppercase tracking-wider">
            {scenario.label}
          </h3>
          {timeline && (
            <button
              onClick={onToggleExpand}
              className="text-gray-500 hover:text-green-500 transition-colors transform hover:scale-110"
            >
              <svg
                className={`w-5 h-5 transition-transform ${isExpanded ? "rotate-180" : ""}`}
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M19 9l-7 7-7-7"
                />
              </svg>
            </button>
          )}
        </div>

        <div className="min-h-[200px] max-h-[400px] overflow-y-auto">
          {isLoading ? (
            <div className="text-gray-500 animate-pulse">
              <div className="flex items-center gap-2 mb-2">
                <span className="inline-flex gap-1">
                  {[...Array(3)].map((_, i) => (
                    <span
                      key={i}
                      className="w-1 h-3 bg-green-500/50 animate-bounce"
                      style={{ animationDelay: `${i * 0.1}s` }}
                    />
                  ))}
                </span>
                <span className="text-xs">{loadingPhrase}</span>
              </div>
            </div>
          ) : result ? (
            <div className="space-y-4">
              {timeline && (
                <div className="flex flex-wrap gap-2 mb-4">
                  {timeline.budget_total_usd && (
                    <span className="inline-flex items-center gap-1 px-3 py-1 bg-green-500 text-black text-xs font-bold">
                      <span>Budget</span>
                      <span>${timeline.budget_total_usd.toLocaleString()}</span>
                    </span>
                  )}
                  {timeline.timeframe_months && (
                    <span className="inline-flex items-center gap-1 px-3 py-1 bg-green-500 text-black text-xs font-bold">
                      <span>Timeframe</span>
                      <span>{timeline.timeframe_months} mo</span>
                    </span>
                  )}
                </div>
              )}

              <div className="text-sm text-gray-300 whitespace-pre-wrap font-mono">
                {result.length > 500 ? (
                  <>
                    <DecryptedText
                      text={result.slice(0, 500)}
                      speed={10}
                      maxIterations={5}
                      sequential={true}
                      animateOn="view"
                      className="text-green-500"
                      encryptedClassName="text-gray-600"
                    />
                    <span className="text-green-500">{result.slice(500)}</span>
                  </>
                ) : (
                  <DecryptedText
                    text={result}
                    speed={10}
                    maxIterations={5}
                    sequential={true}
                    animateOn="view"
                    className="text-green-500"
                    encryptedClassName="text-gray-600"
                  />
                )}
              </div>

              <AnimatePresence>
                {isExpanded && timeline?.phases && (
                  <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: "auto", opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    className="border-t border-green-500/20 pt-4 mt-4"
                  >
                    <h4 className="text-xs text-gray-500 uppercase tracking-wider mb-3">
                      Timeline Breakdown
                    </h4>
                    <div className="space-y-3">
                      {timeline.phases.map((phase, i) => (
                        <div
                          key={i}
                          className="bg-white/5 border border-green-500/20 p-3"
                        >
                          <div className="flex justify-between items-center mb-2">
                            <span className="text-sm font-bold text-green-500">
                              {phase.name}
                            </span>
                            {(phase.start_month !== undefined ||
                              phase.end_month !== undefined) && (
                              <span className="text-xs text-gray-500">
                                {phase.start_month ?? 0}–{phase.end_month ?? ""}{" "}
                                mo
                              </span>
                            )}
                          </div>
                          {phase.summary && (
                            <p className="text-xs text-gray-400 mb-2">
                              {phase.summary}
                            </p>
                          )}
                          {phase.tasks && phase.tasks.length > 0 && (
                            <div className="space-y-2">
                              {phase.tasks.map((task, j) => (
                                <div key={j} className="flex items-start gap-2">
                                  <div
                                    className={`w-2 h-2 mt-1 ${
                                      task.milestone
                                        ? "bg-green-500"
                                        : "bg-gray-600"
                                    }`}
                                  />
                                  <div className="flex-1">
                                    <div className="text-xs text-gray-300">
                                      {task.title}
                                    </div>
                                    {task.desc && (
                                      <div className="text-xs text-gray-500">
                                        {task.desc}
                                      </div>
                                    )}
                                    <div className="flex gap-2 mt-1">
                                      {task.cost_usd && (
                                        <span className="text-xs text-gray-600 border border-gray-700 px-1">
                                          ${task.cost_usd.toLocaleString()}
                                        </span>
                                      )}
                                      {task.duration_weeks && (
                                        <span className="text-xs text-gray-600 border border-gray-700 px-1">
                                          {task.duration_weeks} wk
                                        </span>
                                      )}
                                    </div>
                                  </div>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          ) : (
            <div className="text-gray-600 text-sm">Ready to simulate...</div>
          )}
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="src/components/TextVelocity.tsx">
import { useRef, useLayoutEffect, useState } from "react";
import {
  motion,
  useScroll,
  useSpring,
  useTransform,
  useMotionValue,
  useVelocity,
  useAnimationFrame,
} from "motion/react";

function useElementWidth(ref: React.RefObject<HTMLElement | null>) {
  const [width, setWidth] = useState(0);

  useLayoutEffect(() => {
    function updateWidth() {
      if (ref.current) {
        setWidth(ref.current.offsetWidth);
      }
    }
    updateWidth();
    window.addEventListener("resize", updateWidth);
    return () => window.removeEventListener("resize", updateWidth);
  }, [ref]);

  return width;
}

interface ScrollVelocityProps {
  scrollContainerRef?: React.RefObject<HTMLElement>;
  texts?: string[];
  velocity?: number;
  className?: string;
  damping?: number;
  stiffness?: number;
  numCopies?: number;
  velocityMapping?: { input: number[]; output: number[] };
  parallaxClassName?: string;
  scrollerClassName?: string;
  parallaxStyle?: React.CSSProperties;
  scrollerStyle?: React.CSSProperties;
}

export const ScrollVelocity = ({
  scrollContainerRef,
  texts = [],
  velocity = 100,
  className = "",
  damping = 50,
  stiffness = 400,
  numCopies = 6,
  velocityMapping = { input: [0, 1000], output: [0, 5] },
  parallaxClassName,
  scrollerClassName,
  parallaxStyle,
  scrollerStyle,
}: ScrollVelocityProps) => {
  interface VelocityTextProps {
    children: React.ReactNode;
    baseVelocity?: number;
    scrollContainerRef?: React.RefObject<HTMLElement>;
    className?: string;
    damping?: number;
    stiffness?: number;
    numCopies?: number;
    velocityMapping?: { input: number[]; output: number[] };
    parallaxClassName?: string;
    scrollerClassName?: string;
    parallaxStyle?: React.CSSProperties;
    scrollerStyle?: React.CSSProperties;
  }

  function VelocityText({
    children,
    baseVelocity = velocity,
    scrollContainerRef,
    className = "",
    damping,
    stiffness,
    numCopies,
    velocityMapping,
    parallaxClassName,
    scrollerClassName,
    parallaxStyle,
    scrollerStyle,
  }: VelocityTextProps) {
    const baseX = useMotionValue(0);
    const scrollOptions = scrollContainerRef
      ? { container: scrollContainerRef }
      : {};
    const { scrollY } = useScroll(scrollOptions);
    const scrollVelocity = useVelocity(scrollY);
    const smoothVelocity = useSpring(scrollVelocity, {
      damping: damping ?? 50,
      stiffness: stiffness ?? 400,
    });
    const velocityFactor = useTransform(
      smoothVelocity,
      velocityMapping?.input || [0, 1000],
      velocityMapping?.output || [0, 5],
      { clamp: false }
    );

    const copyRef = useRef<HTMLElement | null>(null);
    const copyWidth = useElementWidth(copyRef);

    function wrap(min: number, max: number, v: number) {
      const range = max - min;
      const mod = (((v - min) % range) + range) % range;
      return mod + min;
    }

    const x = useTransform(baseX, (v) => {
      if (copyWidth === 0) return "0px";
      return `${wrap(-copyWidth, 0, v)}px`;
    });

    const directionFactor = useRef(1);
    useAnimationFrame((_t, delta) => {
      let moveBy = directionFactor.current * baseVelocity * (delta / 1000);

      if (velocityFactor.get() < 0) {
        directionFactor.current = -1;
      } else if (velocityFactor.get() > 0) {
        directionFactor.current = 1;
      }

      moveBy += directionFactor.current * moveBy * velocityFactor.get();
      baseX.set(baseX.get() + moveBy);
    });

    const spans = [];
    for (let i = 0; i < (numCopies ?? 1); i++) {
      spans.push(
        <span
          className={`flex-shrink-0 ${className}`}
          key={i}
          ref={i === 0 ? copyRef : null}
        >
          {children}
        </span>
      );
    }

    return (
      <div
        className={`${parallaxClassName} relative overflow-hidden`}
        style={parallaxStyle}
      >
        <motion.div
          className={`${scrollerClassName} flex whitespace-nowrap text-center font-sans text-4xl font-bold tracking-[-0.02em] drop-shadow md:text-[5rem] md:leading-[5rem]`}
          style={{ x, ...scrollerStyle }}
        >
          {spans}
        </motion.div>
      </div>
    );
  }

  return (
    <section>
      {texts.map((text, index) => (
        <VelocityText
          key={index}
          className={className}
          baseVelocity={index % 2 !== 0 ? -velocity : velocity}
          scrollContainerRef={scrollContainerRef}
          damping={damping}
          stiffness={stiffness}
          numCopies={numCopies}
          velocityMapping={velocityMapping}
          parallaxClassName={parallaxClassName}
          scrollerClassName={scrollerClassName}
          parallaxStyle={parallaxStyle}
          scrollerStyle={scrollerStyle}
        >
          {text}&nbsp;
        </VelocityText>
      ))}
    </section>
  );
};

export default ScrollVelocity;
</file>

<file path="convex/_generated/api.js">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
</file>

<file path="convex/_generated/dataModel.d.ts">
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
</file>

<file path="convex/_generated/server.d.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;
</file>

<file path="convex/_generated/server.js">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/emails/RelocationReport.tsx">
import * as React from 'react';
import {
  Html,
  Head,
  Body,
  Container,
  Preview,
  Section,
  Heading,
  Text,
  Button,
  Hr,
  Link,
} from '@react-email/components';

interface RelocationReportProps {
  name: string;
  email: string;
  originCity: string;
  originCountry: string;
  destinationCity: string;
  destinationCountry: string;
  visaOptions: string;
}

export function RelocationReport({
  name = 'Valued Client',
  email,
  originCity,
  originCountry,
  destinationCity,
  destinationCountry,
  visaOptions = '',
}: RelocationReportProps) {
  const previewText = `Your relocation report from ${originCity} to ${destinationCity}`;

  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Body style={main}>
        <Container style={container}>
          {/* Header Section */}
          <Section style={header}>
            <Heading as="h1" style={headerTitle}>
              Your Relocation Report
            </Heading>
            <Text style={headerSubtitle}>
              From {originCity}, {originCountry} to {destinationCity}, {destinationCountry}
            </Text>
          </Section>

          {/* Greeting */}
          <Section style={content}>
            <Text style={greeting}>Dear {name},</Text>
            <Text style={paragraph}>
              Thank you for using Gullie for your relocation planning. Based on our analysis, 
              here's your comprehensive relocation report.
            </Text>
          </Section>

          {/* Visa Options */}
          <Section style={sectionContainer}>
            <Heading as="h2" style={sectionTitle}>
              📋 Visa Options Summary
            </Heading>
            <div style={sectionContent}>
              {formatVisaOptions(visaOptions)}
            </div>
          </Section>

          {/* Timeline */}
          <Section style={sectionContainer}>
            <Heading as="h2" style={sectionTitle}>
              📅 Recommended Timeline
            </Heading>
            <div style={sectionContent}>
              <Text style={listItem}><strong>Month 1:</strong> Research and document gathering</Text>
              <Text style={listItem}><strong>Month 2:</strong> Visa application submission</Text>
              <Text style={listItem}><strong>Month 3:</strong> Housing arrangements and travel booking</Text>
              <Text style={listItem}><strong>Month 4:</strong> Final preparations and relocation</Text>
            </div>
          </Section>

          {/* Document Checklist */}
          <Section style={sectionContainer}>
            <Heading as="h2" style={sectionTitle}>
              📄 Document Checklist
            </Heading>
            <div style={sectionContent}>
              <Text style={listItem}>• Valid passport (6+ months validity)</Text>
              <Text style={listItem}>• Visa application forms</Text>
              <Text style={listItem}>• Proof of funds/bank statements</Text>
              <Text style={listItem}>• Employment letter/contract</Text>
              <Text style={listItem}>• Housing proof/rental agreement</Text>
              <Text style={listItem}>• Health insurance documentation</Text>
              <Text style={listItem}>• Educational certificates (if applicable)</Text>
              <Text style={listItem}>• Criminal background check</Text>
            </div>
          </Section>

          {/* Next Steps */}
          <Section style={sectionContainer}>
            <Heading as="h2" style={sectionTitle}>
              💡 Next Steps
            </Heading>
            <div style={sectionContent}>
              <Text style={listItem}>1. <strong>Choose your visa type</strong> based on your circumstances and timeline</Text>
              <Text style={listItem}>2. <strong>Gather all required documents</strong> from the checklist above</Text>
              <Text style={listItem}>3. <strong>Book visa appointment</strong> at the nearest consulate/embassy</Text>
              <Text style={listItem}>4. <strong>Arrange housing</strong> in {destinationCity}</Text>
              <Text style={listItem}>5. <strong>Book flights</strong> once visa is approved</Text>
            </div>
          </Section>

          {/* Resources */}
          <Section style={sectionContainer}>
            <Heading as="h2" style={sectionTitle}>
              🔗 Helpful Resources
            </Heading>
            <div style={sectionContent}>
              <Text style={listItem}>• Official Immigration Website for {destinationCountry}</Text>
              <Text style={listItem}>• Embassy/Consulate contact information</Text>
              <Text style={listItem}>• Local expat communities and forums</Text>
              <Text style={listItem}>• Housing platforms for {destinationCity}</Text>
            </div>
          </Section>

          <Hr style={divider} />

          {/* CTA Section */}
          <Section style={ctaSection}>
            <Text style={ctaText}>
              <strong>Need more help?</strong> Reply to this email or call us directly through our AI assistant for personalized guidance.
            </Text>
            <Button
              href="https://gullie.ai"
              style={button}
            >
              Contact Our AI Assistant
            </Button>
          </Section>

          {/* Footer */}
          <Section style={footer}>
            <Text style={footerText}>
              Best regards,<br />
              The Gullie Team
            </Text>
            <Hr style={footerDivider} />
            <Text style={footerCopyright}>
              © 2024 Gullie Travel Planner. All rights reserved.
            </Text>
            <Text style={footerCopyright}>
              This report was generated on {new Date().toLocaleDateString()}
            </Text>
          </Section>
        </Container>
      </Body>
    </Html>
  );
}

function formatVisaOptions(visaOptions: string): React.ReactNode {
  if (!visaOptions) {
    return <Text style={paragraph}>Detailed visa information will be provided based on your specific situation.</Text>;
  }

  // Convert markdown-style formatting to React elements
  const lines = visaOptions.split('\n');
  return lines.map((line, index) => {
    // Handle bold text
    const formattedLine = line.replace(/\*\*(.*?)\*\*/g, (_, text) => text);
    
    if (line.startsWith('• ') || line.startsWith('- ')) {
      return <Text key={index} style={listItem}>• {formattedLine.substring(2)}</Text>;
    }
    
    if (/^\d+\. /.test(line)) {
      return <Text key={index} style={listItem}>{formattedLine}</Text>;
    }
    
    return <Text key={index} style={paragraph}>{formattedLine}</Text>;
  });
}

// Styles
const main = {
  backgroundColor: '#f6f9fc',
  fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Ubuntu, sans-serif',
};

const container = {
  backgroundColor: '#ffffff',
  margin: '0 auto',
  padding: '20px 0 48px',
  marginBottom: '64px',
};

const header = {
  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
  padding: '40px 32px',
  textAlign: 'center' as const,
};

const headerTitle = {
  color: '#ffffff',
  fontSize: '32px',
  fontWeight: '700',
  margin: '0 0 16px',
};

const headerSubtitle = {
  color: '#ffffff',
  fontSize: '18px',
  margin: '0',
  opacity: '0.9',
};

const content = {
  padding: '32px',
};

const greeting = {
  fontSize: '18px',
  fontWeight: '600',
  marginBottom: '8px',
};

const paragraph = {
  fontSize: '16px',
  lineHeight: '26px',
  color: '#404040',
  marginBottom: '16px',
};

const sectionContainer = {
  padding: '0 32px 32px',
};

const sectionTitle = {
  color: '#667eea',
  fontSize: '22px',
  fontWeight: '600',
  borderLeft: '4px solid #667eea',
  paddingLeft: '16px',
  marginBottom: '16px',
};

const sectionContent = {
  paddingLeft: '20px',
};

const listItem = {
  fontSize: '15px',
  lineHeight: '24px',
  color: '#404040',
  marginBottom: '8px',
};

const divider = {
  borderColor: '#e6ebf1',
  margin: '32px 0',
};

const ctaSection = {
  padding: '32px',
  textAlign: 'center' as const,
};

const ctaText = {
  fontSize: '16px',
  lineHeight: '26px',
  color: '#404040',
  marginBottom: '24px',
};

const button = {
  backgroundColor: '#667eea',
  borderRadius: '8px',
  color: '#fff',
  fontSize: '16px',
  fontWeight: '600',
  textDecoration: 'none',
  textAlign: 'center' as const,
  padding: '12px 24px',
  display: 'inline-block',
};

const footer = {
  padding: '32px',
  textAlign: 'center' as const,
};

const footerText = {
  fontSize: '16px',
  lineHeight: '24px',
  color: '#404040',
  marginBottom: '16px',
};

const footerDivider = {
  borderColor: '#e6ebf1',
  margin: '24px 0',
};

const footerCopyright = {
  fontSize: '12px',
  lineHeight: '16px',
  color: '#8898aa',
  margin: '4px 0',
};

export default RelocationReport;
</file>

<file path="convex/mutate/city.ts">
import { v } from "convex/values";
import { mutation } from "../_generated/server";

export const _createCity = mutation({
  args: {
    departure_city: v.string(),
    departure_country: v.optional(v.string()),
    arrival_city: v.string(),
    arrival_country: v.optional(v.string()),
    user: v.id("users"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("cities", {
      user: args.user,
      departure_city: args.departure_city,
      departure_country: args.departure_country,
      arrival_city: args.arrival_city,
      arrival_country: args.arrival_country,
    });
  },
});
</file>

<file path="convex/mutate/date.ts">
import { v } from "convex/values";
import { mutation } from "../_generated/server";

export const _createDate = mutation({
  args: {
    user: v.id("users"),
    city: v.id("cities"),
    departure_date: v.string(),
    arrival_date: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("dates", {
      user: args.user,
      city: args.city,
      departure_date: args.departure_date,
      arrival_date: args.arrival_date,
    });
  },
});
</file>

<file path="convex/mutate/flight.ts">
import { v } from "convex/values";
import { mutation } from "../_generated/server";

export const _createFlight = mutation({
  args: {
    flight_cost: v.number(),
    currency: v.string(),
    user: v.id("users"),
    date: v.id("dates"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("flights", {
      flight_cost: args.flight_cost,
      currency: args.currency,
      user: args.user,
      date: args.date,
    });
  },
});
</file>

<file path="convex/mutate/rental.ts">
import { v } from "convex/values";
import { mutation } from "../_generated/server";

export const _createRental = mutation({
  args: {
    rental_cost: v.string(),
    user: v.id("users"),
    city: v.id("cities"),
    area: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("rentals", {
      rental_cost: args.rental_cost,
      user: args.user,
      city: args.city,
      area: args.area,
    });
  },
});
</file>

<file path="convex/query/city.ts">
import { query } from "../_generated/server";
import { internal } from "../_generated/api";
import { v } from "convex/values";

export const get = query({
  args: {
    user: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("name"), args.user))
      .first();

    if (!user) {
      return "We can't find your name, can you tell me your name again?";
    }
    return await ctx.db
      .query("cities")
      .filter((q) => q.eq(q.field("user"), user._id))
      .collect();
  },
});
</file>

<file path="convex/schemas/conversation.ts">
import { v } from "convex/values";

export const conversation = {
  // Vapi call ID
  callId: v.string(),
  
  // Session ID for grouping related conversations
  sessionId: v.optional(v.string()),
  
  // User information
  userId: v.optional(v.id("users")),
  userEmail: v.optional(v.string()),
  phoneNumber: v.optional(v.string()),
  
  // Conversation transcript
  transcript: v.array(v.object({
    role: v.union(v.literal("assistant"), v.literal("user"), v.literal("system"), v.literal("tool")),
    content: v.string(),
    timestamp: v.number(),
    toolCall: v.optional(v.object({
      name: v.string(),
      arguments: v.any(),
      result: v.optional(v.any()),
    })),
  })),
  
  // Vector embeddings for semantic search
  embedding: v.optional(v.array(v.float64())),
  
  // Conversation metadata
  startedAt: v.number(),
  endedAt: v.optional(v.number()),
  duration: v.optional(v.number()),
  
  // Extracted context
  extractedData: v.optional(v.object({
    originCity: v.optional(v.string()),
    originCountry: v.optional(v.string()),
    destinationCity: v.optional(v.string()),
    destinationCountry: v.optional(v.string()),
    name: v.optional(v.string()),
    email: v.optional(v.string()),
    visaOptions: v.optional(v.string()),
    budget: v.optional(v.string()),
    travelDates: v.optional(v.string()),
  })),
  
  // Tool calls summary
  toolCalls: v.array(v.object({
    name: v.string(),
    timestamp: v.number(),
    success: v.boolean(),
  })),
  
  // Status
  status: v.union(
    v.literal("in_progress"),
    v.literal("completed"),
    v.literal("failed"),
    v.literal("abandoned")
  ),
};
</file>

<file path="convex/schemas/date.ts">
import { v } from "convex/values";

export const date = {
  user: v.id("users"),
  city: v.id("cities"),
  departure_date: v.string(),
  arrival_date: v.string(),
};
</file>

<file path="convex/schemas/document.ts">
import { v } from "convex/values";

export const document = {
  userId: v.optional(v.id("users")),
  userName: v.optional(v.string()),
  email: v.string(),
  phone: v.optional(v.string()),
  fromCity: v.optional(v.string()),
  toCity: v.optional(v.string()),
  selectedOption: v.optional(v.string()),
  pdfUrl: v.optional(v.string()),
  pdfStorageId: v.optional(v.id("_storage")),
  fileName: v.optional(v.string()),
  type: v.optional(v.string()),
  uploadedAt: v.optional(v.number()),
  searchResults: v.optional(v.object({
    cheapest: v.optional(v.any()),
    fastest: v.optional(v.any()),
    convenient: v.optional(v.any()),
    premium: v.optional(v.any()),
  })),
  metadata: v.optional(v.object({
    generatedAt: v.number(),
    sentAt: v.optional(v.number()),
    polarCustomerId: v.optional(v.string()),
    subscriptionStatus: v.optional(v.string()),
  })),
};
</file>

<file path="convex/schemas/flight.ts">
import { v } from "convex/values";

export const flight = {
  flight_cost: v.number(),
  currency: v.string(),
  user: v.id("users"),
  date: v.id("dates"),
};
</file>

<file path="convex/schemas/message.ts">
import { v } from "convex/values";

export const message = {
  body: v.string(),
  embedding: v.optional(v.array(v.float64())),
  user: v.id("users"),
};
</file>

<file path="convex/schemas/rental.ts">
import { v } from "convex/values";

export const rental = {
  area: v.optional(v.string()), // area will be coming from the destination city
  rental_cost: v.optional(v.string()),
  user: v.id("users"),
  city: v.id("cities"),
};
</file>

<file path="convex/schemas/subscription.ts">
import { v } from "convex/values";

export const subscriptionSchema = {
  polarId: v.string(),
  userId: v.string(),
  productId: v.string(),
  status: v.string(), // active, canceled, past_due, etc.
  currentPeriodStart: v.optional(v.string()),
  currentPeriodEnd: v.optional(v.string()),
  cancelAtPeriodEnd: v.boolean(),
  metadata: v.any(),
  createdAt: v.number(),
  updatedAt: v.number(),
};

export const checkoutSchema = {
  checkoutId: v.string(),
  customerId: v.string(),
  productId: v.string(),
  amount: v.number(),
  currency: v.string(),
  status: v.string(),
  metadata: v.any(),
  createdAt: v.number(),
};
</file>

<file path="convex/schemas/visa.ts">
import { v } from "convex/values";

export const visa = {
  visa_type: v.string(),
  visa_cost: v.optional(v.string()),
  user: v.id("users"),
  date: v.id("dates"),
};
</file>

<file path="convex/tools/conversationTracker.ts">
import { v } from "convex/values";
import { internalAction } from "../_generated/server";
import { internal } from "../_generated/api";

// Track conversation updates from Vapi
export const trackConversation = internalAction({
  args: {
    callId: v.string(),
    sessionId: v.optional(v.string()),
    message: v.object({
      type: v.string(),
      role: v.optional(v.union(v.literal("assistant"), v.literal("user"), v.literal("system"), v.literal("tool"))),
      content: v.optional(v.string()),
      transcript: v.optional(v.string()),
      timestamp: v.optional(v.number()),
      toolCall: v.optional(v.object({
        name: v.string(),
        arguments: v.any(),
        result: v.optional(v.any()),
      })),
    }),
    call: v.optional(v.object({
      id: v.string(),
      phoneNumber: v.optional(v.string()),
      customer: v.optional(v.object({
        email: v.optional(v.string()),
        name: v.optional(v.string()),
        phoneNumber: v.optional(v.string()),
      })),
    })),
  },
  handler: async (ctx, args) => {
    const { callId, sessionId, message, call } = args;
    
    // Create or update conversation
    await ctx.runMutation(internal.conversations.upsertConversation, {
      callId,
      sessionId,
      userEmail: call?.customer?.email,
      phoneNumber: call?.customer?.phoneNumber || call?.phoneNumber,
    });

    // Add message to transcript if it's a conversation message
    if (message.type === "transcript" || message.type === "conversation-update") {
      const role = message.role || (message.transcript?.startsWith("User:") ? "user" : "assistant");
      const content = message.content || message.transcript || "";
      
      if (content) {
        await ctx.runMutation(internal.conversations.addTranscriptMessage, {
          callId,
          message: {
            role: role as "assistant" | "user" | "system" | "tool",
            content,
            timestamp: message.timestamp || Date.now(),
            toolCall: message.toolCall,
          },
        });
      }
    }

    // Track tool calls
    if (message.type === "tool-calls" && message.toolCall) {
      await ctx.runMutation(internal.conversations.recordToolCall, {
        callId,
        toolCall: {
          name: message.toolCall.name,
          timestamp: Date.now(),
          success: true,
        },
      });
    }

    // Mark conversation as completed
    if (message.type === "end-of-call-report" || message.type === "hang") {
      await ctx.runMutation(internal.conversations.completeConversation, {
        callId,
      });
    }
  },
});

// Extract and persist data from conversations
export const extractConversationData = internalAction({
  args: {
    callId: v.string(),
    extractedData: v.object({
      originCity: v.optional(v.string()),
      originCountry: v.optional(v.string()),
      destinationCity: v.optional(v.string()),
      destinationCountry: v.optional(v.string()),
      name: v.optional(v.string()),
      email: v.optional(v.string()),
      visaOptions: v.optional(v.string()),
      budget: v.optional(v.string()),
      travelDates: v.optional(v.string()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.runMutation(internal.conversations.updateExtractedData, {
      callId: args.callId,
      extractedData: args.extractedData,
    });
  },
});

// Get conversation context for Vapi to use
export const getConversationContext = internalAction({
  args: {
    sessionId: v.optional(v.string()),
    callId: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args): Promise<{
    transcript: any[];
    extractedData: any;
    conversationCount: number;
  }> => {
    if (args.sessionId) {
      // Get context from session
      const context = await ctx.runQuery(internal.conversations.getSessionContext, {
        sessionId: args.sessionId,
        limit: args.limit,
      });
      return context;
    } else if (args.callId) {
      // Get specific conversation
      const conversation = await ctx.runQuery(internal.conversations.getConversationByCallId, {
        callId: args.callId,
      });
      if (conversation) {
        return {
          transcript: conversation.transcript,
          extractedData: conversation.extractedData,
          conversationCount: 1,
        };
      }
    }
    
    return {
      transcript: [],
      extractedData: {},
      conversationCount: 0,
    };
  },
});
</file>

<file path="convex/conversations.ts">
import { v } from "convex/values";
import { mutation, query, internalMutation, internalQuery } from "./_generated/server";
import { internal } from "./_generated/api";

// Create or update a conversation
export const upsertConversation = internalMutation({
  args: {
    callId: v.string(),
    sessionId: v.optional(v.string()),
    userId: v.optional(v.id("users")),
    userEmail: v.optional(v.string()),
    phoneNumber: v.optional(v.string()),
    transcript: v.optional(v.array(v.object({
      role: v.union(v.literal("assistant"), v.literal("user"), v.literal("system"), v.literal("tool")),
      content: v.string(),
      timestamp: v.number(),
      toolCall: v.optional(v.object({
        name: v.string(),
        arguments: v.any(),
        result: v.optional(v.any()),
      })),
    }))),
    status: v.optional(v.union(
      v.literal("in_progress"),
      v.literal("completed"),
      v.literal("failed"),
      v.literal("abandoned")
    )),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();

    if (existing) {
      // Update existing conversation
      await ctx.db.patch(existing._id, {
        ...(args.sessionId !== undefined && { sessionId: args.sessionId }),
        ...(args.userId !== undefined && { userId: args.userId }),
        ...(args.userEmail !== undefined && { userEmail: args.userEmail }),
        ...(args.phoneNumber !== undefined && { phoneNumber: args.phoneNumber }),
        ...(args.transcript !== undefined && { transcript: args.transcript }),
        ...(args.status !== undefined && { status: args.status }),
      });
      return existing._id;
    } else {
      // Create new conversation
      const conversationId = await ctx.db.insert("conversations", {
        callId: args.callId,
        sessionId: args.sessionId,
        userId: args.userId,
        userEmail: args.userEmail,
        phoneNumber: args.phoneNumber,
        transcript: args.transcript || [],
        startedAt: Date.now(),
        status: args.status || "in_progress",
        toolCalls: [],
        extractedData: {},
      });
      return conversationId;
    }
  },
});

// Add a message to the conversation transcript
export const addTranscriptMessage = internalMutation({
  args: {
    callId: v.string(),
    message: v.object({
      role: v.union(v.literal("assistant"), v.literal("user"), v.literal("system"), v.literal("tool")),
      content: v.string(),
      timestamp: v.number(),
      toolCall: v.optional(v.object({
        name: v.string(),
        arguments: v.any(),
        result: v.optional(v.any()),
      })),
    }),
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();

    if (!conversation) {
      // Create new conversation if it doesn't exist
      await ctx.db.insert("conversations", {
        callId: args.callId,
        transcript: [args.message],
        startedAt: Date.now(),
        status: "in_progress",
        toolCalls: [],
      });
    } else {
      // Append message to existing transcript
      const updatedTranscript = [...conversation.transcript, args.message];
      await ctx.db.patch(conversation._id, {
        transcript: updatedTranscript,
      });
    }
  },
});

// Update extracted data from conversation
export const updateExtractedData = internalMutation({
  args: {
    callId: v.string(),
    extractedData: v.object({
      originCity: v.optional(v.string()),
      originCountry: v.optional(v.string()),
      destinationCity: v.optional(v.string()),
      destinationCountry: v.optional(v.string()),
      name: v.optional(v.string()),
      email: v.optional(v.string()),
      visaOptions: v.optional(v.string()),
      budget: v.optional(v.string()),
      travelDates: v.optional(v.string()),
    }),
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();

    if (conversation) {
      const mergedData = {
        ...conversation.extractedData,
        ...args.extractedData,
      };
      await ctx.db.patch(conversation._id, {
        extractedData: mergedData,
      });
    }
  },
});

// Record a tool call
export const recordToolCall = internalMutation({
  args: {
    callId: v.string(),
    toolCall: v.object({
      name: v.string(),
      timestamp: v.number(),
      success: v.boolean(),
    }),
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();

    if (conversation) {
      const updatedToolCalls = [...conversation.toolCalls, args.toolCall];
      await ctx.db.patch(conversation._id, {
        toolCalls: updatedToolCalls,
      });
    }
  },
});

// Get conversation by call ID
export const getConversationByCallId = internalQuery({
  args: { callId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();
  },
});

// Get recent conversations by session ID
export const getRecentConversationsBySession = query({
  args: { 
    sessionId: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit || 10;
    return await ctx.db
      .query("conversations")
      .withIndex("by_session_id", (q) => q.eq("sessionId", args.sessionId))
      .order("desc")
      .take(limit);
  },
});

// Get conversation context for a session
export const getSessionContext = internalQuery({
  args: { 
    sessionId: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit || 5;
    const conversations = await ctx.db
      .query("conversations")
      .withIndex("by_session_id", (q) => q.eq("sessionId", args.sessionId))
      .order("desc")
      .take(limit);

    // Combine transcripts and extracted data
    const combinedTranscript = conversations.flatMap(c => c.transcript);
    const extractedData = conversations.reduce((acc, c) => ({
      ...acc,
      ...c.extractedData,
    }), {});

    return {
      transcript: combinedTranscript,
      extractedData,
      conversationCount: conversations.length,
    };
  },
});

// Search conversations by content
export const searchConversations = query({
  args: {
    query: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const limit = args.limit || 10;
    
    // This is a simple text search. For better results, you could:
    // 1. Use vector embeddings for semantic search
    // 2. Implement full-text search
    const allConversations = await ctx.db
      .query("conversations")
      .order("desc")
      .take(100);

    const filtered = allConversations.filter(conv => {
      const transcriptText = conv.transcript
        .map(msg => msg.content)
        .join(" ")
        .toLowerCase();
      return transcriptText.includes(args.query.toLowerCase());
    });

    return filtered.slice(0, limit);
  },
});

// Mark conversation as completed
export const completeConversation = internalMutation({
  args: {
    callId: v.string(),
    duration: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();

    if (conversation) {
      await ctx.db.patch(conversation._id, {
        status: "completed",
        endedAt: Date.now(),
        ...(args.duration !== undefined && { duration: args.duration }),
      });
    }
  },
});
</file>

<file path="convex/mcp.ts">
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

// Exa MCP Server Configuration
const EXA_SERVER_URL = "https://server.smithery.ai/exa/mcp";
const EXA_API_KEY = process.env.EXA_API_KEY as string;
const EXA_PROFILE = process.env.EXA_PROFILE as string;

// Construct server URL with authentication
const url = new URL(EXA_SERVER_URL);
url.searchParams.set("api_key", EXA_API_KEY);
url.searchParams.set("profile", EXA_PROFILE);
const serverUrl = url.toString();

// Create MCP transport and client
const transport = new StreamableHTTPClientTransport(new URL(serverUrl));
const client = new Client({
  name: "exa-search-smithery-mcp",
  version: "1.0.0",
});

// Travel search preferences
export type TravelPreference =
  | "cheapest"
  | "luxury"
  | "fastest"
  | "cost-effective";

export interface ExaSearchResult {
  title: string;
  url: string;
  text: string;
  published: string;
  author?: string;
  score: number;
}

export interface TravelSearchQuery {
  departure_city: string;
  arrival_city: string;
  preference: TravelPreference;
  dates?: {
    departure: string;
    return?: string;
  };
  budget?: number;
  currency?: string;
}

// Initialize MCP client connection
export async function initializeExaClient() {
  try {
    await client.connect(transport);
    console.log("✅ Exa MCP client connected successfully");

    // List available tools
    const tools = await client.listTools();
    console.log(
      `🔧 Available Exa tools: ${(tools as unknown as any[])
        .map((t: any) => t.name)
        .join(", ")}`
    );

    return client;
  } catch (error) {
    console.error("❌ Failed to connect to Exa MCP server:", error);
    throw error;
  }
}

// Search for travel information using Exa
export async function searchTravelInfo(
  query: TravelSearchQuery
): Promise<ExaSearchResult[]> {
  try {
    const client = await initializeExaClient();

    // Create search query based on preference
    const searchQuery = createSearchQuery(query);

    // Use Exa's search capabilities
    const searchResult = await client.callTool({
      name: "search",
      arguments: {
        query: searchQuery,
        num_results: 10,
        include_domains: [
          "skyscanner.com",
          "kayak.com",
          "booking.com",
          "airbnb.com",
          "expedia.com",
          "hotels.com",
          "tripadvisor.com",
          "lonelyplanet.com",
          "nomadlist.com",
        ],
        exclude_domains: [],
        use_autoprompt: true,
        type: "keyword",
      },
    });

    return processSearchResults(searchResult);
  } catch (error) {
    console.error("❌ Exa search failed:", error);
    return [];
  }
}

// Create optimized search query based on travel preference
function createSearchQuery(query: TravelSearchQuery): string {
  const { departure_city, arrival_city, preference, dates, budget } = query;

  let searchQuery = `travel from ${departure_city} to ${arrival_city}`;

  switch (preference) {
    case "cheapest":
      searchQuery += " cheapest flights budget travel low cost accommodation";
      break;
    case "luxury":
      searchQuery +=
        " luxury travel premium flights 5 star hotels exclusive experiences";
      break;
    case "fastest":
      searchQuery += " fastest flights direct routes quickest travel time";
      break;
    case "cost-effective":
      searchQuery +=
        " best value flights mid-range hotels optimal price quality ratio";
      break;
  }

  if (dates?.departure) {
    searchQuery += ` ${dates.departure}`;
  }

  if (budget) {
    searchQuery += ` under ${budget} ${query.currency || "USD"}`;
  }

  return searchQuery;
}

// Process and filter search results
function processSearchResults(searchResult: any): ExaSearchResult[] {
  try {
    if (!searchResult || !searchResult.results) {
      return [];
    }

    return searchResult.results.map((result: any) => ({
      title: result.title || "No title",
      url: result.url || "",
      text: result.text || result.snippet || "",
      published: result.published || "",
      author: result.author,
      score: result.score || 0,
    }));
  } catch (error) {
    console.error("❌ Failed to process search results:", error);
    return [];
  }
}

// Get specific travel information based on preference
export async function getTravelRecommendations(query: TravelSearchQuery) {
  const searchResults = await searchTravelInfo(query);

  // Categorize results by type
  const categorizedResults = {
    flights: searchResults.filter(
      (r) =>
        r.text.toLowerCase().includes("flight") ||
        r.url.includes("skyscanner") ||
        r.url.includes("kayak")
    ),
    accommodation: searchResults.filter(
      (r) =>
        r.text.toLowerCase().includes("hotel") ||
        r.text.toLowerCase().includes("accommodation") ||
        r.url.includes("airbnb") ||
        r.url.includes("booking")
    ),
    general: searchResults.filter(
      (r) =>
        !r.text.toLowerCase().includes("flight") &&
        !r.text.toLowerCase().includes("hotel") &&
        !r.text.toLowerCase().includes("accommodation")
    ),
  };

  return {
    preference: query.preference,
    total_results: searchResults.length,
    categorized_results: categorizedResults,
    top_recommendations: searchResults.slice(0, 5),
    search_query: createSearchQuery(query),
  };
}

// Get all four preference types for comparison
export async function getAllTravelPreferences(
  query: Omit<TravelSearchQuery, "preference">
) {
  const preferences: TravelPreference[] = [
    "cheapest",
    "luxury",
    "fastest",
    "cost-effective",
  ];

  const results = await Promise.all(
    preferences.map(async (preference) => {
      const searchQuery: TravelSearchQuery = { ...query, preference };
      const recommendations = await getTravelRecommendations(searchQuery);
      return recommendations;
    })
  );

  return {
    departure_city: query.departure_city,
    arrival_city: query.arrival_city,
    search_date: new Date().toISOString(),
    preferences: results,
  };
}

// Close MCP client connection
export async function closeExaClient() {
  try {
    await client.close();
    console.log("✅ Exa MCP client closed successfully");
  } catch (error) {
    console.error("❌ Failed to close Exa MCP client:", error);
  }
}

// Export client for use in other modules
export { client as exaClient };
</file>

<file path="convex/storage.ts">
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    return await ctx.storage.generateUploadUrl();
  },
});

export const savePDFReference = mutation({
  args: {
    storageId: v.id("_storage"),
    email: v.string(),
    fileName: v.string(),
  },
  handler: async (ctx, args) => {
    const { storageId, email, fileName } = args;
    
    await ctx.db.insert("documents", {
      pdfStorageId: storageId,
      email,
      fileName,
      uploadedAt: Date.now(),
      type: "relocation-report",
    });
    
    return storageId;
  },
});

export const getPDFUrl = query({
  args: {
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.storageId);
  },
});
</file>

<file path="convex/subscriptions.ts">
import { v } from "convex/values";
import { internalMutation, query } from "./_generated/server";

export const upsertSubscription = internalMutation({
  args: {
    polarId: v.string(),
    userId: v.string(),
    productId: v.string(),
    status: v.string(),
    currentPeriodStart: v.optional(v.string()),
    currentPeriodEnd: v.optional(v.string()),
    cancelAtPeriodEnd: v.boolean(),
    metadata: v.any(),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("subscriptions")
      .withIndex("by_polar_id", (q) => q.eq("polarId", args.polarId))
      .first();
      
    if (existing) {
      await ctx.db.patch(existing._id, {
        ...args,
        updatedAt: Date.now(),
      });
    } else {
      await ctx.db.insert("subscriptions", {
        ...args,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    }
  },
});

export const cancelSubscription = internalMutation({
  args: {
    polarId: v.string(),
  },
  handler: async (ctx, args) => {
    const subscription = await ctx.db
      .query("subscriptions")
      .withIndex("by_polar_id", (q) => q.eq("polarId", args.polarId))
      .first();
      
    if (subscription) {
      await ctx.db.patch(subscription._id, {
        status: "canceled",
        updatedAt: Date.now(),
      });
    }
  },
});

export const recordCheckout = internalMutation({
  args: {
    checkoutId: v.string(),
    customerId: v.string(),
    productId: v.string(),
    amount: v.number(),
    currency: v.string(),
    metadata: v.any(),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("checkouts", {
      ...args,
      status: "succeeded",
      createdAt: Date.now(),
    });
  },
});

export const getUserSubscription = query({
  args: {
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("subscriptions")
      .withIndex("by_user_id", (q) => q.eq("userId", args.userId))
      .filter((q) => q.eq(q.field("status"), "active"))
      .first();
  },
});

export const getUserCheckouts = query({
  args: {
    customerId: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("checkouts")
      .withIndex("by_customer_id", (q) => q.eq("customerId", args.customerId))
      .order("desc")
      .collect();
  },
});
</file>

<file path="convex/tsconfig.json">
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings are required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/pdf-worker.js">
// PDF Generation Web Worker
importScripts('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');

self.addEventListener('message', async (event) => {
  const { type, data } = event.data;
  
  if (type === 'GENERATE_PDF') {
    try {
      const pdf = await generatePDF(data);
      self.postMessage({
        type: 'PDF_COMPLETE',
        data: pdf
      });
    } catch (error) {
      self.postMessage({
        type: 'PDF_ERROR',
        error: error.message
      });
    }
  }
});

async function generatePDF(data) {
  const { jsPDF } = self.jspdf;
  const doc = new jsPDF();
  
  const {
    userName,
    email,
    phone,
    fromCity,
    toCity,
    selectedOption,
    searchResults,
    generatedAt
  } = data;
  
  // Header
  doc.setFontSize(24);
  doc.setTextColor(0, 255, 136);
  doc.text('GULLIE', 20, 30);
  
  doc.setFontSize(12);
  doc.setTextColor(100);
  doc.text('Global Mobility Expert Report', 20, 40);
  
  // User Information
  doc.setFontSize(14);
  doc.setTextColor(0);
  doc.text('Relocation Plan', 20, 60);
  
  doc.setFontSize(10);
  doc.text(`Name: ${userName}`, 20, 70);
  doc.text(`Email: ${email}`, 20, 77);
  doc.text(`Phone: ${phone}`, 20, 84);
  doc.text(`Route: ${fromCity} → ${toCity}`, 20, 91);
  doc.text(`Generated: ${new Date(generatedAt).toLocaleDateString()}`, 20, 98);
  
  // Selected Option Details
  doc.setFontSize(14);
  doc.text(`Selected: ${selectedOption.title}`, 20, 115);
  
  doc.setFontSize(10);
  let yPos = 125;
  
  // Visa Information
  doc.setFontSize(12);
  doc.text('Visa Requirements', 20, yPos);
  yPos += 10;
  
  doc.setFontSize(10);
  doc.text(`Type: ${selectedOption.visaType}`, 25, yPos);
  yPos += 7;
  doc.text(`Timeline: ${selectedOption.timeline}`, 25, yPos);
  yPos += 7;
  doc.text(`Cost: ${selectedOption.totalCost}`, 25, yPos);
  yPos += 15;
  
  // Key Highlights
  doc.setFontSize(12);
  doc.text('Key Features', 20, yPos);
  yPos += 10;
  
  doc.setFontSize(10);
  if (selectedOption.highlights) {
    selectedOption.highlights.forEach((highlight) => {
      doc.text(`• ${highlight}`, 25, yPos);
      yPos += 7;
    });
  }
  
  // All Options Summary
  yPos += 10;
  doc.setFontSize(12);
  doc.text('All Options Comparison', 20, yPos);
  yPos += 10;
  
  const options = ['cheapest', 'fastest', 'convenient', 'premium'];
  options.forEach((optionType) => {
    const option = searchResults[optionType];
    if (option) {
      doc.setFontSize(10);
      doc.setFont(undefined, 'bold');
      doc.text(`${option.title}:`, 25, yPos);
      doc.setFont(undefined, 'normal');
      yPos += 7;
      doc.text(`${option.visaType} - ${option.timeline} - ${option.totalCost}`, 30, yPos);
      yPos += 10;
    }
  });
  
  // Footer
  doc.setFontSize(8);
  doc.setTextColor(150);
  doc.text('This report is confidential and for personal use only.', 20, 270);
  doc.text('Gullie Global Mobility Expert - £1000/month after free trial', 20, 275);
  doc.text('Support available 24/7 via phone and web', 20, 280);
  
  // Convert to blob
  const pdfBlob = doc.output('blob');
  
  // Convert blob to base64 for transfer
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      resolve({
        base64: reader.result,
        blob: pdfBlob
      });
    };
    reader.readAsDataURL(pdfBlob);
  });
}
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="scripts/manage-vapi-tools.ts">
#!/usr/bin/env bun

const VAPI_API_KEY = process.env.VAPI_API_KEY;

interface VapiTool {
  id: string;
  type: "function";
  function: {
    name: string;
    description: string;
    parameters: any;
  };
  server?: {
    url: string;
  };
  createdAt: string;
  updatedAt: string;
  orgId: string;
}

async function listTools(): Promise<VapiTool[]> {
  try {
    const response = await fetch('https://api.vapi.ai/tool?limit=1000', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`
      }
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('Failed to list tools:', error);
      return [];
    }

    const tools = await response.json();
    return tools;
  } catch (error) {
    console.error('Error listing tools:', error);
    return [];
  }
}

async function deleteTool(toolId: string): Promise<boolean> {
  try {
    const response = await fetch(`https://api.vapi.ai/tool/${toolId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`
      }
    });

    if (!response.ok) {
      const error = await response.text();
      console.error(`Failed to delete tool ${toolId}:`, error);
      return false;
    }

    return true;
  } catch (error) {
    console.error(`Error deleting tool ${toolId}:`, error);
    return false;
  }
}

async function findDuplicateTools(tools: VapiTool[]): Map<string, VapiTool[]> {
  const toolsByName = new Map<string, VapiTool[]>();
  
  for (const tool of tools) {
    if (tool.type === 'function' && tool.function?.name) {
      const name = tool.function.name;
      if (!toolsByName.has(name)) {
        toolsByName.set(name, []);
      }
      toolsByName.get(name)!.push(tool);
    }
  }
  
  // Filter to only show duplicates
  const duplicates = new Map<string, VapiTool[]>();
  for (const [name, toolList] of toolsByName) {
    if (toolList.length > 1) {
      duplicates.set(name, toolList);
    }
  }
  
  return duplicates;
}

async function cleanupDuplicates(keepLatest: boolean = true) {
  console.log('🔍 Fetching all tools...');
  const tools = await listTools();
  console.log(`📊 Found ${tools.length} total tools\n`);

  const duplicates = await findDuplicateTools(tools);
  
  if (duplicates.size === 0) {
    console.log('✅ No duplicate tools found!');
    return;
  }

  console.log(`⚠️  Found ${duplicates.size} tools with duplicates:\n`);
  
  for (const [name, toolList] of duplicates) {
    console.log(`\n📦 ${name}: ${toolList.length} instances`);
    
    // Sort by creation date
    toolList.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    
    for (let i = 0; i < toolList.length; i++) {
      const tool = toolList[i];
      const createdDate = new Date(tool.createdAt).toLocaleString();
      const isLatest = i === 0;
      
      console.log(`   ${isLatest ? '🟢' : '🔴'} ID: ${tool.id}`);
      console.log(`      Created: ${createdDate}`);
      console.log(`      URL: ${tool.server?.url || 'N/A'}`);
      
      if (!keepLatest || !isLatest) {
        if (process.argv.includes('--dry-run')) {
          console.log(`      [DRY RUN] Would delete this tool`);
        } else if (process.argv.includes('--confirm')) {
          const success = await deleteTool(tool.id);
          if (success) {
            console.log(`      ✅ Deleted`);
          } else {
            console.log(`      ❌ Failed to delete`);
          }
        }
      }
    }
  }

  if (!process.argv.includes('--confirm') && !process.argv.includes('--dry-run')) {
    console.log('\n⚠️  To actually delete duplicates, run with --confirm flag');
    console.log('   Or use --dry-run to see what would be deleted');
  }
}

async function listAllTools() {
  console.log('🔍 Fetching all tools...');
  const tools = await listTools();
  
  if (tools.length === 0) {
    console.log('No tools found');
    return;
  }
  
  console.log(`\n📊 Found ${tools.length} tools:\n`);
  
  // Group by function name
  const toolsByName = new Map<string, VapiTool[]>();
  const otherTools: VapiTool[] = [];
  
  for (const tool of tools) {
    if (tool.type === 'function' && tool.function?.name) {
      const name = tool.function.name;
      if (!toolsByName.has(name)) {
        toolsByName.set(name, []);
      }
      toolsByName.get(name)!.push(tool);
    } else {
      otherTools.push(tool);
    }
  }
  
  // Display function tools
  for (const [name, toolList] of toolsByName) {
    console.log(`📦 ${name}:`);
    for (const tool of toolList) {
      const createdDate = new Date(tool.createdAt).toLocaleString();
      console.log(`   - ID: ${tool.id}`);
      console.log(`     Created: ${createdDate}`);
      console.log(`     URL: ${tool.server?.url || 'N/A'}`);
      if (toolList.length > 1) {
        console.log(`     ⚠️  DUPLICATE (${toolList.length} instances)`);
      }
    }
    console.log();
  }
  
  // Display other tools
  if (otherTools.length > 0) {
    console.log('📦 Other tools:');
    for (const tool of otherTools) {
      console.log(`   - ID: ${tool.id}`);
      console.log(`     Type: ${tool.type}`);
      console.log(`     Created: ${new Date(tool.createdAt).toLocaleString()}`);
    }
  }
}

async function deleteAllTools() {
  if (!process.argv.includes('--confirm')) {
    console.log('⚠️  This will delete ALL tools!');
    console.log('   Run with --confirm to proceed');
    return;
  }

  console.log('🔍 Fetching all tools...');
  const tools = await listTools();
  
  if (tools.length === 0) {
    console.log('No tools to delete');
    return;
  }
  
  console.log(`⚠️  Deleting ${tools.length} tools...`);
  
  let deleted = 0;
  let failed = 0;
  
  for (const tool of tools) {
    const success = await deleteTool(tool.id);
    if (success) {
      deleted++;
      console.log(`✅ Deleted: ${tool.function?.name || tool.id}`);
    } else {
      failed++;
      console.log(`❌ Failed: ${tool.function?.name || tool.id}`);
    }
  }
  
  console.log(`\n📊 Results: ${deleted} deleted, ${failed} failed`);
}

async function main() {
  const command = process.argv[2];
  
  console.log('🚀 Vapi Tool Manager\n');
  
  switch (command) {
    case 'list':
      await listAllTools();
      break;
    case 'cleanup':
      await cleanupDuplicates();
      break;
    case 'delete-all':
      await deleteAllTools();
      break;
    default:
      console.log('Usage: bun run scripts/manage-vapi-tools.ts <command> [options]');
      console.log('\nCommands:');
      console.log('  list                  - List all tools');
      console.log('  cleanup [--confirm]   - Remove duplicate tools (keeps latest)');
      console.log('  delete-all [--confirm] - Delete ALL tools');
      console.log('\nOptions:');
      console.log('  --confirm  - Actually perform deletions');
      console.log('  --dry-run  - Show what would be deleted without doing it');
  }
}

main().catch(console.error);
</file>

<file path="simulations/backend/app/__init__.py">

</file>

<file path="simulations/backend/app/main.py">
import os
import json
import math
from typing import Optional, List

import psycopg2
from fastapi import FastAPI, Request
import logging
from fastapi.responses import PlainTextResponse, JSONResponse, StreamingResponse
from pydantic import BaseModel, Field, conint, confloat, ValidationError
from openai import OpenAI, BadRequestError
from .prompts import build_messages


app = FastAPI(title="HTMX + FastAPI Boilerplate")


@app.get("/health")
def health() -> dict:
    return {"status": "ok"}


@app.get("/api/hello", response_class=PlainTextResponse)
def hello() -> str:
    return "Hello from FastAPI 👋"


@app.get("/api/db-ping")
def db_ping():
    dsn: Optional[str] = os.getenv("DATABASE_URL")
    if not dsn:
        return JSONResponse(status_code=500, content={"ok": False, "error": "DATABASE_URL not set"})

    try:
        with psycopg2.connect(dsn) as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
                one = cur.fetchone()[0]
        return {"ok": True, "result": int(one)}
    except Exception as exc:
        return JSONResponse(status_code=500, content={"ok": False, "error": str(exc)})


@app.post("/api/stream")
async def stream_response(request: Request):
    data = await request.json()
    # Structured fields (preferred)
    start_city = data.get("start_city")
    destination_city = data.get("destination_city")
    budget_range = data.get("budget_range")
    move_month = data.get("move_month")
    context = data.get("context")

    # Fallback freeform prompt support
    prompt: str = data.get("prompt")

    # Scenario may be a label (cheapest, fastest, balanced, luxury) or index
    scenario = data.get("scenario")

    def streamer():
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            yield b"[server] Missing OPENAI_API_KEY.\n"
            return

        client = OpenAI(api_key=api_key)

        try:
            # Stream using the Responses API
            # Build messages: structured or fallback
            if start_city or destination_city or budget_range or move_month or context:
                messages = build_messages(
                    {
                        "start_city": start_city,
                        "destination_city": destination_city,
                        "budget_range": budget_range,
                        "move_month": move_month,
                        "context": context,
                    },
                    str(scenario or "balanced").lower(),
                )
            else:
                # freeform prompt as user content
                messages = [{"role": "user", "content": prompt or "Provide a short sample."}]

            with client.responses.stream(
                model=os.getenv("OPENAI_MODEL", "gpt-5-nano-2025-08-07"),
                input=messages,
            ) as stream:
                # Removed scenario header so client loaders are not interrupted
                for event in stream:
                    if event.type == "response.output_text.delta":
                        chunk = getattr(event, "delta", "") or ""
                        yield chunk.encode("utf-8")
                    elif event.type == "response.error":
                        err = getattr(event, "error", None)
                        if err:
                            yield f"\n[error] {err}\n".encode("utf-8")

                # Access the final response if needed
                # final = stream.get_final_response()
                yield b"\n"
        except Exception as exc:
            yield f"[server] {exc}\n".encode("utf-8")

    return StreamingResponse(streamer(), media_type="text/plain; charset=utf-8")


# =========================
# Timeline generation API
# =========================

class TimelineTask(BaseModel):
    title: str
    desc: Optional[str] = None
    cost_usd: Optional[confloat(ge=0)] = None
    duration_weeks: Optional[confloat(ge=0)] = None
    milestone: Optional[bool] = False


class TimelinePhase(BaseModel):
    name: str
    start_month: Optional[conint(ge=0)] = None
    end_month: Optional[conint(ge=0)] = None
    summary: Optional[str] = None
    tasks: List[TimelineTask] = Field(default_factory=list)


class TimelineResponse(BaseModel):
    headline: Optional[str] = None
    budget_total_usd: Optional[confloat(ge=0)] = None
    timeframe_months: Optional[conint(ge=0)] = None
    phases: List[TimelinePhase] = Field(default_factory=list)
    milestones: Optional[List[dict]] = None
    notes: Optional[str] = None
    confidence: Optional[confloat(ge=0, le=1)] = 0.7


class TimelineRequest(BaseModel):
    scenario_key: Optional[str] = None  # cheapest|balanced|fastest|luxury
    scenario_title: Optional[str] = None
    raw_text: str = Field(..., min_length=1)
    preferences: Optional[dict] = None


def _extract_json_obj(resp):
    """Extract a JSON object (dict) from OpenAI Responses API output.

    Supports both output_text (JSON string) and output_json (native dict) parts.
    """
    # 1) Direct text aggregate
    text = getattr(resp, "output_text", None)
    if isinstance(text, str) and text.strip():
        try:
            return json.loads(text)
        except Exception:
            pass

    # 2) Structured parts
    output = getattr(resp, "output", None)
    try:
        if output and len(output) > 0:
            first = output[0]
            content = getattr(first, "content", None)
            if content and len(content) > 0:
                part = content[0]
                ptype = getattr(part, "type", None)
                if ptype == "output_json":
                    pobj = getattr(part, "json", None)
                    if isinstance(pobj, dict):
                        return pobj
                    # Sometimes it can be a string
                    if isinstance(pobj, str):
                        try:
                            return json.loads(pobj)
                        except Exception:
                            pass
                # Fallback to text field
                ptext = getattr(part, "text", None)
                if isinstance(ptext, str) and ptext.strip():
                    try:
                        return json.loads(ptext)
                    except Exception:
                        pass
    except Exception:
        pass

    # 3) Last resort: find JSON substring in any string form
    blob = str(getattr(resp, "output_text", "") or resp)
    start = blob.find("{")
    end = blob.rfind("}")
    if start != -1 and end != -1 and end > start:
        try:
            return json.loads(blob[start : end + 1])
        except Exception:
            pass
    return {}


@app.post("/api/timeline")
def build_timeline(req: TimelineRequest):
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        return JSONResponse(status_code=500, content={"ok": False, "error": "Missing OPENAI_API_KEY"})

    client = OpenAI(api_key=api_key)

    # Clip raw text to avoid over-long prompts
    raw_text = req.raw_text.strip()
    if len(raw_text) > 12000:
        raw_text = raw_text[:12000]

    schema_desc = {
        "headline": "string",
        "budget_total_usd": "number",
        "timeframe_months": "integer",
        "phases": [
            {
                "name": "string",
                "start_month": "integer",
                "end_month": "integer",
                "summary": "string",
                "tasks": [
                    {
                        "title": "string",
                        "desc": "string",
                        "cost_usd": "number",
                        "duration_weeks": "number",
                        "milestone": "boolean",
                    }
                ],
            }
        ],
        "milestones": [
            {"title": "string", "month": "number", "note": "string"}
        ],
        "notes": "string",
        "confidence": "number between 0 and 1",
    }

    system = (
        "You are a relocation timeline extractor. Read the scenario text and produce a concise,"
        " normalized timeline JSON matching the provided schema. Use reasonable defaults when needed."
        " Return strictly valid JSON with no prose."
    )
    user = {
        "scenario_key": req.scenario_key,
        "scenario_title": req.scenario_title,
        "preferences": req.preferences or {},
        "schema": schema_desc,
        "scenario_text": raw_text,
        "rules": [
            "Infer total budget (USD) and timeframe (months) if implied",
            "Limit tasks per phase to at most 6 concise items",
            "Mark key steps as milestone: true",
            "Clamp negative numbers to zero and omit impossible fields",
            "Omit null fields where not applicable",
        ],
    }

    def _round_nonneg_int(x: Optional[float]) -> Optional[int]:
        if x is None:
            return None
        try:
            # Round halves up (0.5 -> 1) and clamp negative to 0
            val = int(math.floor(float(x) + 0.5))
            return max(0, val)
        except Exception:
            return None

    def _coerce_timeline_numbers(obj: dict) -> dict:
        # Coerce timeframe_months
        if isinstance(obj.get("timeframe_months"), (int, float)):
            obj["timeframe_months"] = _round_nonneg_int(obj.get("timeframe_months"))

        # Coerce phases' start/end month to ints
        phases = obj.get("phases")
        if isinstance(phases, list):
            for ph in phases:
                if not isinstance(ph, dict):
                    continue
                sm = _round_nonneg_int(ph.get("start_month")) if ph.get("start_month") is not None else None
                em = _round_nonneg_int(ph.get("end_month")) if ph.get("end_month") is not None else None
                if sm is not None:
                    ph["start_month"] = sm
                if em is not None:
                    ph["end_month"] = em
                # If both exist and end < start, align end to start
                if sm is not None and em is not None and em < sm:
                    ph["end_month"] = sm
        return obj

    try:
        resp = client.responses.create(
            model=os.getenv("OPENAI_MODEL", "gpt-5-nano-2025-08-07"),
            input=[
                {"role": "system", "content": system + " Strictly output JSON only."},
                {"role": "user", "content": json.dumps(user)},
            ],
        )
        data = _extract_json_obj(resp)
        data = _coerce_timeline_numbers(data or {})
        timeline = TimelineResponse(**data)
        return timeline.model_dump()
    except BadRequestError as bre:
        # Fallback to chat.completions for older models/configs
        try:
            chat = client.chat.completions.create(
                model=os.getenv("OPENAI_MODEL", "gpt-5-nano-2025-08-07"),
                messages=[
                    {"role": "system", "content": system + " Strictly output JSON only."},
                    {"role": "user", "content": json.dumps(user)},
                ],
            )
            content = chat.choices[0].message.content if chat.choices else "{}"
            data = json.loads(content or "{}")
            data = _coerce_timeline_numbers(data or {})
            timeline = TimelineResponse(**data)
            return timeline.model_dump()
        except Exception:
            logging.exception("/api/timeline chat fallback failed")
            return JSONResponse(status_code=400, content={"ok": False, "error": str(bre)})
    except ValidationError as ve:
        logging.exception("/api/timeline validation error")
        return JSONResponse(status_code=422, content={"ok": False, "error": "ValidationError", "detail": json.loads(ve.json())})
    except Exception as exc:
        logging.exception("/api/timeline failed")
        return JSONResponse(status_code=500, content={"ok": False, "error": str(exc)})
</file>

<file path="simulations/backend/app/prompts.py">
from typing import Dict, List


SCENARIO_LABELS = {
    "cheapest": "The Frugal Mover",
    "balanced": "The Balanced Mover",
    "fastest": "The Fast-Track Mover",
    "luxury": "The Premier Mover",
}


def build_messages(payload: Dict, scenario: str) -> List[Dict]:
    """Build OpenAI Responses API messages from structured inputs and scenario.

    Returns a list of dicts with role/content, suitable for the `input` parameter.
    """
    start = (payload.get("start_city") or "").strip()
    dest = (payload.get("destination_city") or "").strip()
    budget = (payload.get("budget_range") or "").strip()
    month = (payload.get("move_month") or "").strip()
    context = (payload.get("context") or "").strip()

    scenario_label = SCENARIO_LABELS.get(scenario, scenario.title())

    scenario_bias = {
        "cheapest": (
            "Prioritize minimizing cost. Prefer DIY options, budget flights,"
            " shared or modest housing, and longer timelines if it saves money."
        ),
        "balanced": (
            "Balance cost, time, and convenience. Choose realistic, middle-of-the-road"
            " options likely for most movers."
        ),
        "fastest": (
            "Prioritize speed. Use approaches that reduce waiting time even at higher cost;"
            " consider premium processing, temporary housing to accelerate arrival, etc."
        ),
        "luxury": (
            "Prioritize convenience and service quality. Assume use of relocation agents,"
            " premium services, and higher budgets to reduce stress and delays."
        ),
    }.get(scenario, "Balance cost, time, and convenience.")

    system = f"""
ROLE AND GOAL
You are an expert relocation logistics simulator. Your goal is to generate one distinct, realistic simulation for the mover based on the provided inputs and the specified scenario style.

CORE VARIABLES (INPUTS)
- Profile: Not provided explicitly; infer a reasonable baseline family profile unless context specifies otherwise.
- Origin: {start}
- Destination: {dest}
- Budget Range: {budget}
- Ideal Move Month: {month}
- Additional Context: {context}

SIMULATION LOGIC (PROCESS)
For the destination, simulate the full relocation process and estimate both cost and time for:
1) Visa & Immigration (path, docs, processing times, fees)
2) Pet Relocation (requirements, costs, timeline) if relevant
3) Housing (rental process, average rent, deposits, agent fees)
4) Cost of Living Adjustment (salary vs. taxes and expenses)
5) Setup Costs (shipping, flights, temporary housing)
6) Timeline Estimation (Gantt-style phases with dependencies)

SCENARIO STYLE
Scenario: {scenario_label}
Guidance: {scenario_bias}

OUTPUT FORMAT
Return a concise Markdown block containing:
- A short headline for the scenario
- Bullet summaries for each factor with concrete estimates
- Total Estimated Cost (USD) and Estimated Timeline (months)
- One major pro and one major con
- A feasibility score (1-10)
""".strip()

    user = (
        "Using the inputs above, produce the simulation. Be concrete and avoid filler."
    )

    return [
        {"role": "system", "content": system},
        {"role": "user", "content": user},
    ]
</file>

<file path="simulations/backend/Dockerfile">
FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1

WORKDIR /app

# Paths are relative to the build context (./backend)
COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt

COPY app /app/app

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="simulations/backend/requirements.txt">
fastapi==0.112.0
uvicorn[standard]==0.30.3
psycopg2-binary==2.9.9
openai>=1.30.0,<2
</file>

<file path="simulations/frontend/static/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Streaming Demo</title>
    <style>
      :root {
        /* Refined monochrome dark palette (not pure black/white) */
        --bg: #0a0b0d;         /* page background (charcoal) */
        --panel: #111316;      /* raised surfaces */
        --border: #1d2129;     /* subtle borders */
        --text: #e8e9ec;       /* primary text (off-white) */
        --muted: #9ea3ab;      /* secondary text (cool gray) */
        --code: #0d0f12;       /* tiles / code-like blocks */
        /* Accents kept neutral for elegant B/W feel */
        --accent: #1f232a;     /* interactive bg (deep slate) */
        --accent-2: #2a2f38;   /* interactive border */
        --focus: #dfe2e6;      /* light gray focus border */
        --focusRing: rgba(223,226,230,.12); /* soft halo */
      }
      * { box-sizing: border-box; }
      body {
        margin: 0; padding: 0; background: var(--bg); color: var(--text);
        font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
        color-scheme: dark;
      }
      /* Make the main wrapper full-width with safe gutters */
      .wrap { max-width: none; margin: 0 auto; padding: 32px 16px; }
      @media (min-width: 1024px) { .wrap { padding: 32px 24px; } }
      .title { margin: 0 0 16px; font-weight: 650; letter-spacing: .2px; }
      .muted { color: var(--muted); margin: 0 0 20px; }

      /* Keep the form panel at a readable width */
      .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 16px; max-width: 860px; margin: 0 auto; box-shadow: 0 0 0 1px rgba(255,255,255,.02) inset; }
      .row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; align-items: end; }
      @media (max-width: 900px) { .row { grid-template-columns: repeat(2, 1fr); } }
      @media (max-width: 520px) { .row { grid-template-columns: 1fr; } }
      .field { display:flex; flex-direction:column; gap:6px; }
      .field label { font-size: 12px; color: var(--muted); }
      input[type="text"], input[type="month"], select, textarea {
        width: 100%; border-radius: 10px; padding: 10px 12px; border: 1px solid var(--border);
        background: #0d0f12; color: var(--text); outline: none; transition: border-color .15s ease, box-shadow .15s ease, background .15s ease;
      }
      textarea { min-height: 44px; resize: vertical; }
      input:focus, select:focus, textarea:focus { border-color: var(--focus); box-shadow: 0 0 0 3px var(--focusRing); }
      button {
        appearance: none; border: 1px solid var(--accent-2);
        background: linear-gradient(180deg, #1a1d22, #15181d);
        color: var(--text); border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer;
        transition: transform .04s ease, filter .15s ease, background .15s ease, border-color .15s ease;
      }
      button:hover { filter: brightness(1.05); }
      button:active { transform: translateY(1px); }
      button[disabled] { opacity: .7; cursor: not-allowed; }
      .btn-ghost { background: transparent; border-color: var(--border); color: var(--muted); }
      .btn-ghost:hover { border-color: #343a44; color: var(--text); filter: none; }

      .output { margin-top: 16px; background: var(--code); border: 1px solid var(--border);
        border-radius: 10px; padding: 12px; max-height: 60vh; overflow: auto; box-shadow: 0 0 0 1px rgba(255,255,255,.02) inset; }
      .label { font-size: 13px; color: var(--muted); margin-bottom: 8px; }
      pre { margin: 0; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
      /* Full-width scenarios grid (with gutters), responsive */
      .scenarios { margin-top: 16px; }
      .grid { display: grid; gap: 14px; grid-template-columns: repeat(4, 1fr); }
      @media (max-width: 1400px) { .grid { grid-template-columns: repeat(3, 1fr); } }
      @media (max-width: 1000px) { .grid { grid-template-columns: repeat(2, 1fr); } }
      @media (max-width: 640px) { .grid { grid-template-columns: 1fr; } }
      .tile { background: var(--code); border: 1px solid var(--border); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; min-height: 180px; box-shadow: 0 0 0 1px rgba(255,255,255,.02) inset; }
      .tile-header { font-size: 12px; color: var(--muted); margin-bottom: 8px; font-weight: 600; letter-spacing: .2px; }
      .tile-output { margin: 0; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 13px; line-height: 1.4; max-height: 35vh; overflow: auto; }
      .timeline-area { margin-top: 10px; border-top: 1px dashed var(--border); padding-top: 10px; }
      /* Timeline UI */
      .timeline { display: grid; gap: 12px; }
      .timeline-header { display:flex; align-items:center; justify-content:space-between; gap: 8px; }
      .tl-title { font-weight: 700; letter-spacing: .2px; color: var(--text); font-size: 15px; }
      .chips { display:flex; flex-wrap: wrap; gap: 6px; }
      /* Flip Budget/Timeframe chips to elegant white for contrast */
      .chip { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #e3e6ea; border-radius: 999px; color: #16181c; background: #ffffff; font-size: 13px; }
      .chip .val { font-weight: 700; font-size: 14px; color: #0b0d10; }
      .phases { display:grid; gap:10px; }
      /* Flip the phase card to white with dark text; keep inner task cards dark for contrast */
      .phase { border:1px solid #e3e6ea; border-radius: 10px; padding:10px; background: #ffffff; color: #16181c; }
      .phase-head { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; }
      .phase-name { font-weight: 600; color: #0f1216; }
      .phase-span { color: #3a4048; font-size: 12px; }
      .phase-summary { color: #2b3138; font-size: 13px; margin-bottom:6px; }
      .tasks { display:grid; grid-template-columns: 1fr; gap:8px; }
      .task { display:flex; align-items:flex-start; gap:8px; padding:8px; border:1px solid var(--border); border-radius:8px; background:#0f1216; }
      .dot { width:8px; height:8px; border-radius:50%; background:#cfd3d8; margin-top:6px; }
      .task-body { display:flex; flex-direction:column; gap:4px; }
      .task-title { font-weight:600; font-size:13px; color: var(--text); }
      .task-desc { font-size:12px; color: var(--muted); }
      .task-meta { display:flex; gap:6px; flex-wrap:wrap; }
      .meta { font-size:11px; color: var(--muted); border:1px solid var(--border); padding:2px 6px; border-radius:999px; }
      /* Timeline loader */
      .tl-loading { display:flex; align-items:center; gap:8px; color: var(--muted); font-size: 13px; }
      .tl-loading .bars i { height: 10px; }

      /* Loading animation for tiles */
      .tile.loading .tile-output { color: var(--muted); }
      .placeholder { display: inline-flex; align-items: center; gap: 8px; }
      .bars { display: inline-flex; gap: 3px; }
      .bars i { width: 3px; height: 12px; background: #2e333c; border-radius: 2px; animation: bounce 1s ease-in-out infinite; }
      .bars i:nth-child(2) { animation-delay: .1s; }
      .bars i:nth-child(3) { animation-delay: .2s; }
      .placeholder .msg { opacity: .9; }
      @keyframes bounce { 0%, 100% { transform: translateY(0); opacity: .6; } 50% { transform: translateY(-4px); opacity: 1; } }

      /* Global status badge */
      .status-badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; color: var(--muted); background: rgba(255,255,255,.02); font-size: 13px; }
      .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #7b828e; }
      .status-badge.streaming .status-dot { background: #d0d4d9; animation: pulse 1s ease-in-out infinite; }
      .status-badge.done .status-dot { background: #67e06b; box-shadow: 0 0 0 2px rgba(103,224,107,.15); }
      @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    </style>
  </head>
  <body>
    <main class="wrap">
      <h1 class="title">Simulations</h1>
      <p class="muted">Scenario simulations for best planning and budgeting.</p>

      <section class="panel">
        <form id="chat-form">
          <div class="row" style="margin-bottom:12px;">
            <div class="field">
              <label for="start_city">Start City</label>
              <input id="start_city" name="start_city" type="text" placeholder="San Francisco, CA, USA" />
            </div>
            <div class="field">
              <label for="destination_city">Destination City</label>
              <input id="destination_city" name="destination_city" type="text" placeholder="Lisbon, Portugal" />
            </div>
            <div class="field">
              <label for="budget_min">Min Budget (USD)</label>
              <input id="budget_min" name="budget_min" type="number" inputmode="numeric" min="0" step="100" placeholder="e.g., 25000" />
            </div>
            <div class="field">
              <label for="budget_max">Max Budget (USD)</label>
              <input id="budget_max" name="budget_max" type="number" inputmode="numeric" min="0" step="100" placeholder="e.g., 50000" />
            </div>
            <div class="field">
              <label for="move_month">Ideal Move Month</label>
              <input id="move_month" name="move_month" type="month" />
            </div>
            <div class="field" style="grid-column: 1 / -1;">
              <label for="context">Additional Context</label>
              <textarea id="context" name="context" rows="3" placeholder="e.g., family with dog, school priority, job details, constraints"></textarea>
            </div>
          </div>
          <div style="display:flex; gap:10px; justify-content:flex-end;">
            <button type="button" id="clear-btn" class="btn-ghost">Clear</button>
            <button id="send-btn" type="submit">Run 4 Scenarios</button>
          </div>
        </form>
      </section>
      <!-- Scenarios grid spans the page width (with gutters) and isn't confined to the form width -->
      <section class="scenarios">
        <div id="status" class="status-badge" aria-live="polite"><span class="status-dot"></span><span class="status-text">Ready</span></div>
        <div id="grid" class="grid"></div>
      </section>
    </main>

    <script>
      const form = document.getElementById('chat-form');
      const btn = document.getElementById('send-btn');
      const clearBtn = document.getElementById('clear-btn');
      const startEl = document.getElementById('start_city');
      const destEl = document.getElementById('destination_city');
      const budgetMinEl = document.getElementById('budget_min');
      const budgetMaxEl = document.getElementById('budget_max');
      const monthEl = document.getElementById('move_month');
      const contextEl = document.getElementById('context');
      const grid = document.getElementById('grid');

      let controllers = [];

      // Loading phrases for pre-stream animation
      const loadingPhrases = [
  'Analyzing the unique cultural fabric and social atmosphere of each district',
  'Aggregating and cross-referencing thousands of current rental market listings',
  'Simulating daily commute routes via public transit, driving, and cycling options',
  'Evaluating curriculum standards and admission availability at international schools',
  'Calculating a detailed, personalized cost of living index against your income',
  'Investigating and outlining the most viable long-term visa and residency pathways',
  'Scoring local coworking spaces based on amenities, community reviews, and pricing',
  'Correlating official crime statistics with hyperlocal resident safety sentiment data',
  'Pinpointing public parks, nature reserves, and recreational green spaces nearby',
  'Identifying popular and hidden-gem destinations for enriching weekend excursions',
  'Modeling the potential tax liabilities and fiscal implications of your relocation',
  'Assessing the quality, cost, and accessibility of local healthcare providers',
  'Projecting annual weather patterns, from seasonal averages to climate trends',
  'Mapping the entire culinary landscape, from street food stalls to fine dining',
  'Prioritizing and verifying the local availability of your essential lifestyle amenities',
  'Optimizing relocation scenarios to perfectly balance your timeline against your budget',
  'Compiling pet import regulations and identifying pet-friendly housing and areas',
  'Quantifying the distinct advantages and potential disadvantages between top neighborhoods',
  'Cataloging entertainment venues, cultural institutions, and local nightlife hotspots',
  'Forecasting the one-time overhead for utilities, security deposits, and initial setup',
  'Comparing local internet service providers based on speed, reliability, and real-world cost',
  'Uncovering often-overlooked administrative fees and potential hidden living expenses',
  'Generating a dynamic and comprehensive pre-move logistics and documentation checklist',
  'Forecasting your complete recurring monthly expenditures with high-fidelity projections',
  'Structuring a strategic, step-by-step itinerary for your first seven days post-arrival',
  'Deconstructing local banking requirements and international money transfer options',
  'Gauging the precise walkability and bikeability scores for shortlisted residential zones',
  'Parsing complex residency permit requirements and typical government processing timelines',
  'Identifying top-rated fitness centers, specialized gyms, and community sports clubs',
  'Assembling a comprehensive guide to navigating local public transportation networks',
  'Calibrating timezone differences and their practical impact on your work and social schedule',
  'Factoring in proximity and travel time to major airports and international hubs',
  'Synthesizing long-term data on air quality indexes and other environmental factors',
  'Researching important local customs, crucial social etiquette, and cultural nuances',
  'Benchmarking childcare facilities and early childhood education programs for quality',
  'Mapping the density of grocery stores, farmers markets, and specialty food shops',
  'Simulating the logistical challenges of shipping personal belongings and furniture',
  'Reviewing municipal services, including waste management and city recycling programs',
  'Analyzing the local job market for potential spousal or partner employment opportunities',
  'Collating information on language schools and effective immersion programs for learners',
  'Determining drivers license conversion processes and necessary vehicle import laws',
  'Evaluating the political stability and the long-term economic outlook of the region',
  'Pinpointing community centers and social groups that closely align with your hobbies',
  'Cross-validating cellular network coverage and comparing mobile data plan affordability',
  'Integrating critical consulate and embassy contact information for your nationality',
  'Projecting the financial impact of currency exchange rate fluctuations on your savings',
  'Assessing the availability and average cost of comprehensive renters insurance policies',
  'Sequencing the essential administrative tasks for a seamless and organized first month',
  'Investigating the local startup scene and key professional networking opportunities',
  'Building a final, hyper-personalized relocation feasibility and strategic action report'
];

      function attachAutoScroll(tile) {
        const out = tile.querySelector('.tile-output');
        tile._autoscroll = true; // follow output by default
        out.addEventListener('scroll', () => {
          const distanceFromBottom = out.scrollHeight - out.scrollTop - out.clientHeight;
          tile._autoscroll = distanceFromBottom < 8; // re-enable when user returns to bottom
        });
      }

      function randomPhrase() {
        return loadingPhrases[Math.floor(Math.random() * loadingPhrases.length)];
      }

      function setTileLoading(tile, on) {
        const out = tile.querySelector('.tile-output');
        if (on) {
          tile.classList.add('loading');
          out.innerHTML = '<div class="placeholder"><span class="bars"><i></i><i></i><i></i></span><span class="msg"></span></div>';
          const msgEl = out.querySelector('.msg');
          msgEl.textContent = randomPhrase();
          // Rotate phrases with a randomized cadence per tile (< 1s)
          const schedule = () => {
            const delay = 350 + Math.random() * 400; // 350–750ms
            tile._loadingTimer = setTimeout(() => {
              msgEl.textContent = randomPhrase();
              schedule();
            }, delay);
          };
          // Clear any previous timers just in case
          if (tile._loadingTimer) { clearTimeout(tile._loadingTimer); }
          if (tile._loadingInterval) { clearInterval(tile._loadingInterval); tile._loadingInterval = null; }
          schedule();
        } else {
          tile.classList.remove('loading');
          if (tile._loadingTimer) { clearTimeout(tile._loadingTimer); tile._loadingTimer = null; }
          if (tile._loadingInterval) { clearInterval(tile._loadingInterval); tile._loadingInterval = null; }
          // Clear placeholder but keep existing text if any
          if (out.querySelector('.placeholder')) { out.textContent = out.textContent; }
        }
      }

      function setStatus(state, text) {
        const el = document.getElementById('status');
        const txt = el.querySelector('.status-text');
        el.classList.remove('streaming','done');
        if (state) el.classList.add(state);
        if (typeof text === 'string') txt.textContent = text;
      }

      function createTile(label) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.innerHTML = `
          <div class="tile-header">${label}</div>
          <pre class="tile-output"></pre>
          <div class="timeline-area"></div>
        `;
        return tile;
      }

      async function streamToTile(scenario, payload, tile, controller) {
        const out = tile.querySelector('.tile-output');
        out.textContent = '';
        setTileLoading(tile, true);
        try {
          const resp = await fetch('/api/stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ...payload, scenario }),
            signal: controller.signal,
          });
          if (!resp.ok || !resp.body) {
            setTileLoading(tile, false);
            out.textContent = `Error: ${resp.status} ${resp.statusText}`;
            return;
          }
          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let received = false;
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (!received) {
              received = true;
              // Swap out placeholder for real content
              setTileLoading(tile, false);
              out.textContent = '';
            }
            out.textContent += decoder.decode(value, { stream: true });
            // Auto-follow output as it streams
            if (tile._autoscroll) {
              out.scrollTop = out.scrollHeight;
            }
          }
        } catch (err) {
          if (controller.signal.aborted) {
            out.textContent += '\n[aborted]';
          } else {
            out.textContent = `[fetch error] ${err}`;
          }
        }
        finally {
          setTileLoading(tile, false);
        }
      }

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        // Abort any in-flight streams
        controllers.forEach(c => c.abort());
        controllers = [];
        // Stop any active loading animations from prior tiles
        document.querySelectorAll('.tile').forEach(t => {
          if (t._loadingTimer) { clearTimeout(t._loadingTimer); t._loadingTimer = null; }
          if (t._loadingInterval) { clearInterval(t._loadingInterval); t._loadingInterval = null; }
        });
        grid.innerHTML = '';

        // Build a flexible budget range string
        const minVal = budgetMinEl.value ? Number(budgetMinEl.value) : null;
        const maxVal = budgetMaxEl.value ? Number(budgetMaxEl.value) : null;
        let budgetRange = '';
        if (minVal != null && maxVal != null && isFinite(minVal) && isFinite(maxVal) && maxVal >= minVal) {
          budgetRange = `${formatUSD(minVal)} - ${formatUSD(maxVal)}`;
        } else if (minVal != null && isFinite(minVal)) {
          budgetRange = `Over ${formatUSD(minVal)}`;
        } else if (maxVal != null && isFinite(maxVal)) {
          budgetRange = `Under ${formatUSD(maxVal)}`;
        }

        const payload = {
          start_city: startEl.value.trim(),
          destination_city: destEl.value.trim(),
          budget_range: budgetRange,
          move_month: monthEl.value,
          context: contextEl.value.trim(),
        };
        btn.disabled = true; btn.textContent = 'Streaming…';
        setStatus('streaming', 'Streaming 4 scenarios…');
        let done = 0;

        const scenarios = [
          { key: 'cheapest', label: 'Cheapest Options' },
          { key: 'fastest', label: 'Fastest Options' },
          { key: 'balanced', label: 'Balanced Options' },
          { key: 'luxury', label: 'Luxury Options' },
        ];

        for (const s of scenarios) {
          const tile = createTile(s.label);
          tile.dataset.key = s.key;
          tile.dataset.label = s.label;
          grid.appendChild(tile);
          attachAutoScroll(tile);
          const controller = new AbortController();
          controllers.push(controller);
          // Fire and forget; no await here to keep them parallel
          streamToTile(s.key, payload, tile, controller).finally(() => {
            done += 1;
            if (done === scenarios.length) {
              btn.disabled = false; btn.textContent = 'Run 4 Scenarios';
              setStatus('done', 'All scenarios complete');
              // Kick off timeline generation for each tile
              Array.from(grid.children).forEach(t => buildTimelineForTile(t));
            }
          });
        }
      });
      function formatUSD(n) {
        const num = Number(n);
        if (!isFinite(num)) return '';
        return num.toLocaleString(undefined, { maximumFractionDigits: 0 });
      }


      clearBtn.addEventListener('click', () => {
          startEl.value = '';
          destEl.value = '';
          budgetMinEl.value = '';
          budgetMaxEl.value = '';
          monthEl.value = '';
          contextEl.value = '';
        grid.innerHTML = '';
        setStatus('', 'Ready');
      });

      async function buildTimelineForTile(tile) {
        const area = tile.querySelector('.timeline-area');
        area.innerHTML = `<div class="tl-loading"><span class="bars"><i></i><i></i><i></i></span> Building timeline…</div>`;
        const out = tile.querySelector('.tile-output');
        const raw = out.textContent || '';
        const payload = {
          scenario_key: tile.dataset.key,
          scenario_title: tile.dataset.label,
          raw_text: raw.slice(0, 15000),
        };
        try {
          const resp = await fetch('/api/timeline', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!resp.ok) {
            let detail = '';
            try { detail = await resp.text(); } catch {}
            throw new Error(`${resp.status} ${resp.statusText}${detail ? ' — ' + detail : ''}`);
          }
          const data = await resp.json();
          renderTimeline(area, data);
        } catch (err) {
          area.innerHTML = `<div class="tl-loading">\n            <span style="color:#d66;">Failed to build timeline:</span> ${err}.\n            <button class="btn-ghost" style="margin-left:8px;" onclick="(async()=>{ const t=this.closest('.tile'); if(t) { await window.__retryTimeline(t); } })()">Retry</button>\n          </div>`;
        }
      }

      window.__retryTimeline = async (tile) => { await buildTimelineForTile(tile); };

      function renderTimeline(container, tl) {
        const fmtMoney = (n) => (typeof n === 'number' && isFinite(n)) ? `$${n.toLocaleString()}` : null;
        const fmtMonths = (n) => (typeof n === 'number' && isFinite(n)) ? `${n} mo` : null;

        const chips = [];
        const money = fmtMoney(tl.budget_total_usd);
        if (money) chips.push(`<span class="chip"><span>Budget</span><span class="val">${money}</span></span>`);
        const months = fmtMonths(tl.timeframe_months);
        if (months) chips.push(`<span class="chip"><span>Timeframe</span><span class="val">${months}</span></span>`);

        const header = `
          <div class="timeline-header">
            <div class="tl-title">${tl.headline ? escapeHtml(tl.headline) : 'Timeline'}</div>
            <div class="chips">${chips.join('')}</div>
          </div>
        `;

        const phases = Array.isArray(tl.phases) ? tl.phases : [];
        const phasesHtml = phases.map(ph => {
          const span = (ph.start_month != null || ph.end_month != null)
            ? `<span class="phase-span">${ph.start_month ?? 0}–${ph.end_month ?? ''} mo</span>`
            : '';
          const summary = ph.summary ? `<div class="phase-summary">${escapeHtml(ph.summary)}</div>` : '';
          const tasks = Array.isArray(ph.tasks) ? ph.tasks : [];
          const tasksHtml = tasks.map(t => {
            const metas = [];
            if (typeof t.cost_usd === 'number') metas.push(`<span class="meta">${fmtMoney(t.cost_usd)}</span>`);
            if (typeof t.duration_weeks === 'number') metas.push(`<span class="meta">${t.duration_weeks} wk</span>`);
            return `
              <div class="task">
                <div class="dot" style="background:${t.milestone ? '#67e06b' : '#cfd3d8'}"></div>
                <div class="task-body">
                  <div class="task-title">${escapeHtml(t.title || '')}</div>
                  ${t.desc ? `<div class="task-desc">${escapeHtml(t.desc)}</div>` : ''}
                  ${metas.length ? `<div class="task-meta">${metas.join('')}</div>` : ''}
                </div>
              </div>`;
          }).join('');
          return `
            <div class="phase">
              <div class="phase-head"><div class="phase-name">${escapeHtml(ph.name || '')}</div>${span}</div>
              ${summary}
              <div class="tasks">${tasksHtml}</div>
            </div>`;
        }).join('');

        container.innerHTML = `<div class="timeline">${header}<div class="phases">${phasesHtml}</div></div>`;
      }

      function escapeHtml(str) {
        return String(str).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
      }
    </script>
  </body>
  </html>
</file>

<file path="simulations/frontend/Dockerfile">
FROM nginx:1.27-alpine

# Paths are relative to the build context (./frontend)
COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY static /usr/share/nginx/html

EXPOSE 80
</file>

<file path="simulations/frontend/nginx.conf">
server {
    listen 80;
    server_name _;

    # Serve static files
    location / {
        root /usr/share/nginx/html;
        try_files $uri /index.html;
    }

    # Proxy API requests to FastAPI service
    location /api/ {
        proxy_pass http://api:8000;
        proxy_http_version 1.1;
        proxy_buffering off; # allow streaming responses
        proxy_cache off;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Health endpoint for container check
    location = /nginx-health {
        return 200 'ok';
        add_header Content-Type text/plain;
    }
}
</file>

<file path="simulations/docker-compose.dev.yml">
version: "3.9"

services:
  api:
    command: ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
    volumes:
      - ./backend/app:/app/app

  frontend:
    volumes:
      - ./frontend/static:/usr/share/nginx/html:ro
      - ./frontend/nginx.conf:/etc/nginx/conf.d/default.conf:ro
</file>

<file path="simulations/docker-compose.yml">
version: "3.9"

services:
  db:
    image: postgres:16-alpine
    container_name: htmx_db
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-app}
      POSTGRES_USER: ${POSTGRES_USER:-app}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password}
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10

  api:
    build: ./backend
    container_name: htmx_api
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USER:-app}:${POSTGRES_PASSWORD:-password}@db:5432/${POSTGRES_DB:-app}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
    depends_on:
      db:
        condition: service_healthy
    expose:
      - "8000"

  frontend:
    build: ./frontend
    container_name: htmx_frontend
    depends_on:
      - api
    ports:
      - "8080:80"

volumes:
  db_data:
</file>

<file path="simulations/README.md">
HTMX + FastAPI + Postgres (Docker Compose)

Minimal boilerplate: Nginx serves a static HTMX frontend, which proxies `/api/*` to a FastAPI backend. The backend connects to a Postgres database. All services run via Docker Compose.

Services
- frontend: Nginx serving static files with proxy to `api`
- api: FastAPI app on Uvicorn
- db: Postgres 16

Quick start
1) Ensure Docker is running.
2) Optionally edit `.env` for database credentials.
3) Build and start containers:
   docker compose up --build
4) Open the app:
   http://localhost:8080

Development (live reload)
- Use the dev override to mount source and enable Uvicorn reload:
  docker compose -f docker-compose.yml -f docker-compose.dev.yml up --build
- Changes in `frontend/static/` are served immediately by Nginx (no rebuild).
- Backend auto-reloads on changes in `backend/app/`.

Project layout
- docker-compose.yml
- .env
- backend/
  - Dockerfile
  - requirements.txt
  - app/main.py
- frontend/
  - Dockerfile
  - nginx.conf
  - static/index.html

API endpoints
- GET /health → simple health check
- GET /api/hello → returns greeting (text)
- GET /api/db-ping → connects to Postgres and returns `{"ok": true, "result": 1}` on success
- POST /api/stream → streams text from OpenAI (chunked plain text)

Notes
- Frontend proxies `/api/*` to `api:8000` inside the compose network, avoiding CORS issues.
- Postgres data persists in the `db_data` volume.
 - For production-style images, run without the dev override.
 - For streaming, set `OPENAI_API_KEY` in `.env`. You may also set `OPENAI_MODEL` (default `gpt-4o-mini`). Nginx proxy buffering is disabled for `/api/*` to enable live streaming.

Streaming example (Python)
```python
from openai import OpenAI
client = OpenAI()

with client.responses.stream(
    model="gpt-4o-mini",
    input=[{"role": "user", "content": "Say 'double bubble bath' ten times fast."}],
) as stream:
    for event in stream:
        if event.type == "response.output_text.delta":
            print(event.delta, end="")
    # Optionally access final response
    final = stream.get_final_response()
```
</file>

<file path="src/app/api/create-checkout/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { withAuth } from "@workos-inc/authkit-nextjs";

export async function POST(request: NextRequest) {
  try {
    // Verify user is authenticated
    const { user } = await withAuth();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { productId, customerEmail, customerName } = body;

    // Create checkout session with Polar API
    const polarResponse = await fetch("https://api.polar.sh/v1/checkouts/", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.POLAR_ACCESS_TOKEN}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        product_id: productId || process.env.POLAR_PRODUCT_ID,
        success_url: `${process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"}/success?session_id={CHECKOUT_SESSION_ID}`,
        customer_email: customerEmail || user.email,
        customer_name: customerName || user.firstName || user.email,
        metadata: {
          userId: user.id,
          workosUserId: user.id,
        },
      }),
    });

    if (!polarResponse.ok) {
      const error = await polarResponse.text();
      console.error("Polar API error:", error);
      return NextResponse.json(
        { error: "Failed to create checkout session" },
        { status: 500 }
      );
    }

    const checkoutData = await polarResponse.json();
    
    return NextResponse.json({
      checkoutUrl: checkoutData.url,
      checkoutId: checkoutData.id,
    });
  } catch (error) {
    console.error("Create checkout error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/email/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { Resend } from "resend";

//TODO: Add RESEND_API_KEY to .env.local
// Get from: https://resend.com/api-keys
const resend = new Resend(process.env.RESEND_API_KEY);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, userName, pdfBase64, fromCity, toCity, selectedOption } = body;

    if (!email || !pdfBase64) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Convert base64 to buffer for attachment
    const pdfBuffer = Buffer.from(
      pdfBase64.replace(/^data:application\/pdf;base64,/, ""),
      "base64"
    );

    //TODO: Configure your domain in Resend dashboard
    // Replace 'noreply@yourdomain.com' with your verified domain
    const { data, error } = await resend.emails.send({
      from: "Gullie <noreply@yourdomain.com>",
      to: [email],
      subject: `Your Relocation Plan: ${fromCity} to ${toCity}`,
      html: `
        <!DOCTYPE html>
        <html>
          <head>
            <style>
              body { font-family: monospace; background: #000; color: #fff; padding: 20px; }
              .container { max-width: 600px; margin: 0 auto; }
              .header { color: #00ff88; font-size: 24px; margin-bottom: 20px; }
              .content { background: #1a1a1a; padding: 20px; border: 1px solid #333; }
              .highlight { color: #00ffff; }
              .footer { margin-top: 20px; font-size: 12px; color: #666; }
              .button { 
                display: inline-block; 
                padding: 12px 24px; 
                background: #00ff88; 
                color: #000; 
                text-decoration: none; 
                font-weight: bold;
                margin-top: 20px;
              }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">GULLIE</div>
              <div class="content">
                <h2>Hi ${userName},</h2>
                <p>Your personalized relocation plan from <span class="highlight">${fromCity}</span> to <span class="highlight">${toCity}</span> is ready!</p>
                
                <h3>Selected Option: ${selectedOption.title}</h3>
                <ul>
                  <li>Visa Type: ${selectedOption.visaType}</li>
                  <li>Timeline: ${selectedOption.timeline}</li>
                  <li>Total Cost: ${selectedOption.totalCost}</li>
                </ul>
                
                <p>Please find your comprehensive PDF report attached to this email.</p>
                
                <h3>Next Steps:</h3>
                <ol>
                  <li>Review the attached PDF for detailed information</li>
                  <li>Call us anytime for personalized support</li>
                  <li>Your first month is FREE - no charges until visa secured</li>
                </ol>
                
                <a href="https://yourdomain.com/subscribe" class="button">
                  Start Your Journey
                </a>
                
                <p style="margin-top: 30px;">
                  Our AI agents are available 24/7 to assist you with every step of your relocation.
                </p>
              </div>
              <div class="footer">
                <p>Gullie Global Mobility Expert</p>
                <p>£1000/month after free trial • Cancel anytime</p>
                <p>This email contains confidential information</p>
              </div>
            </div>
          </body>
        </html>
      `,
      attachments: [
        {
          filename: `relocation-plan-${fromCity}-to-${toCity}.pdf`,
          content: pdfBuffer,
        },
      ],
    });

    if (error) {
      console.error("Resend error:", error);
      return NextResponse.json(
        { error: "Failed to send email" },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true, emailId: data?.id });
  } catch (error) {
    console.error("Email route error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/polar/checkout/route.ts">
import { NextRequest, NextResponse } from "next/server";

//TODO: Add POLAR_ACCESS_TOKEN to .env.local
// Get from: https://dashboard.polar.sh
// Create a product with £1000/month pricing

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, userName, metadata } = body;

    const polarAccessToken = process.env.POLAR_ACCESS_TOKEN;
    const polarProductId = process.env.POLAR_PRODUCT_ID;
    
    if (!polarAccessToken || !polarProductId) {
      console.error("Polar configuration missing");
      return NextResponse.json(
        { error: "Payment system not configured" },
        { status: 500 }
      );
    }

    // Create checkout session with Polar
    const response = await fetch("https://api.polar.sh/v1/checkouts", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${polarAccessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        product_id: polarProductId,
        customer_email: email,
        customer_name: userName,
        success_url: `${process.env.NEXT_PUBLIC_BASE_URL}/success`,
        metadata: {
          ...metadata,
          service: "gullie-relocation",
        },
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error("Polar API error:", error);
      return NextResponse.json(
        { error: "Failed to create checkout session" },
        { status: 500 }
      );
    }

    const data = await response.json();
    
    return NextResponse.json({
      checkoutUrl: data.url,
      checkoutId: data.id,
    });
  } catch (error) {
    console.error("Checkout route error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/polar/webhook/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { validateEvent } from "@polar-sh/sdk/webhooks";

//TODO: Add POLAR_WEBHOOK_SECRET to .env.local
// Get from: https://dashboard.polar.sh/webhooks

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    const signature = request.headers.get("webhook-signature");
    const webhookId = request.headers.get("webhook-id");
    const webhookTimestamp = request.headers.get("webhook-timestamp");
    
    if (!signature || !webhookId || !webhookTimestamp) {
      return NextResponse.json(
        { error: "Missing webhook headers" },
        { status: 400 }
      );
    }

    const webhookSecret = process.env.POLAR_WEBHOOK_SECRET;
    
    if (!webhookSecret) {
      console.error("POLAR_WEBHOOK_SECRET not configured");
      return NextResponse.json(
        { error: "Webhook not configured" },
        { status: 500 }
      );
    }

    // Validate webhook signature
    const event = await validateEvent(
      body,
      {
        "webhook-signature": signature,
        "webhook-id": webhookId,
        "webhook-timestamp": webhookTimestamp,
      },
      webhookSecret
    );

    // Handle different event types
    switch (event.type) {
      case "subscription.created":
        console.log("New subscription created:", event.data);
        //TODO: Update user status in Convex
        // Mark user as subscribed
        // Enable full features
        break;
        
      case "subscription.updated":
        console.log("Subscription updated:", event.data);
        //TODO: Update subscription status
        break;
        
      case "subscription.canceled":
        console.log("Subscription canceled:", event.data);
        //TODO: Handle cancellation
        // Send retention email
        // Schedule access removal
        break;
        
      case "order.paid":
        console.log("Payment received:", event.data);
        //TODO: Record payment in database
        break;
        
      case "checkout.created":
        console.log("Checkout started:", event.data);
        //TODO: Track checkout analytics
        break;
        
      default:
        console.log("Unhandled webhook event:", event.type);
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error("Webhook error:", error);
    return NextResponse.json(
      { error: "Webhook processing failed" },
      { status: 400 }
    );
  }
}
</file>

<file path="src/app/callback/route.ts">
import { handleAuth } from "@workos-inc/authkit-nextjs";
import { NextResponse } from "next/server";

export const GET = handleAuth({
  onError: async (error) => {
    console.error("Error authenticating", error);
    
    return NextResponse.json(
      { error: "Authentication failed, reason: " + JSON.stringify(error) },
      { status: 500 }
    );
  },
});
</file>

<file path="src/app/success/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import DecryptedText from "@/components/DecryptedText";

export default function SuccessPage() {
  const router = useRouter();
  const [countdown, setCountdown] = useState(10);

  useEffect(() => {
    const timer = setInterval(() => {
      setCountdown((prev) => {
        if (prev <= 1) {
          clearInterval(timer);
          router.push("/");
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [router]);

  return (
    <main className="min-h-screen bg-black flex items-center justify-center">
      <div className="text-center space-y-8 max-w-2xl px-4">
        <div className="space-y-4">
          <div className="text-6xl">✓</div>
          <h1 className="text-4xl font-bold">
            <DecryptedText
              text="Welcome to Gullie!"
              animateOn="view"
              speed={60}
              sequential={true}
              revealDirection="center"
              className="gradient-text"
              encryptedClassName="text-gray-700"
            />
          </h1>
        </div>

        <div className="space-y-4 text-gray-300">
          <p className="text-xl">
            Your subscription has been activated successfully.
          </p>
          <p>
            You now have full access to our AI-powered relocation services.
          </p>
        </div>

        <div className="card p-8 space-y-4">
          <h2 className="text-2xl font-semibold text-green-400">
            <DecryptedText
              text="What's Next?"
              speed={40}
              maxIterations={10}
              className="text-green-400"
              encryptedClassName="text-green-900"
            />
          </h2>
          <ul className="space-y-3 text-left text-gray-400">
            <li>• Call us anytime for personalized support</li>
            <li>• Access unlimited visa consultations</li>
            <li>• Get real-time updates on your application</li>
            <li>• Receive priority processing on all requests</li>
          </ul>
        </div>

        <div className="space-y-4">
          <p className="text-sm text-gray-500">
            Your first month is FREE. You&apos;ll be charged £1000/month starting next month.
          </p>
          <p className="text-sm text-gray-500">
            Cancel anytime before your visa is secured.
          </p>
        </div>

        <div className="text-gray-600">
          Redirecting to dashboard in {countdown} seconds...
        </div>
      </div>
    </main>
  );
}
</file>

<file path="src/components/DecryptedText.tsx">
"use client";

import { useEffect, useState, useRef } from 'react';
import { motion } from 'motion/react';

interface DecryptedTextProps {
  text: string;
  speed?: number;
  maxIterations?: number;
  sequential?: boolean;
  revealDirection?: 'start' | 'end' | 'center';
  useOriginalCharsOnly?: boolean;
  characters?: string;
  className?: string;
  parentClassName?: string;
  encryptedClassName?: string;
  animateOn?: 'hover' | 'view';
}

export default function DecryptedText({
  text,
  speed = 50,
  maxIterations = 10,
  sequential = false,
  revealDirection = 'start',
  useOriginalCharsOnly = false,
  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',
  className = '',
  parentClassName = '',
  encryptedClassName = '',
  animateOn = 'hover'
}: DecryptedTextProps) {
  const [displayText, setDisplayText] = useState(text);
  const [isHovering, setIsHovering] = useState(false);
  const [isScrambling, setIsScrambling] = useState(false);
  const [revealedIndices, setRevealedIndices] = useState(new Set<number>());
  const [hasAnimated, setHasAnimated] = useState(false);
  const containerRef = useRef<HTMLSpanElement>(null);

  useEffect(() => {
    let interval: NodeJS.Timeout;
    let currentIteration = 0;

    const getNextIndex = (revealedSet: Set<number>) => {
      const textLength = text.length;
      switch (revealDirection) {
        case 'start':
          return revealedSet.size;
        case 'end':
          return textLength - 1 - revealedSet.size;
        case 'center': {
          const middle = Math.floor(textLength / 2);
          const offset = Math.floor(revealedSet.size / 2);
          const nextIndex =
            revealedSet.size % 2 === 0
              ? middle + offset
              : middle - offset - 1;

          if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {
            return nextIndex;
          }
          for (let i = 0; i < textLength; i++) {
            if (!revealedSet.has(i)) return i;
          }
          return 0;
        }
        default:
          return revealedSet.size;
      }
    };

    const availableChars = useOriginalCharsOnly
      ? Array.from(new Set(text.split(''))).filter((char) => char !== ' ')
      : characters.split('');

    const shuffleText = (originalText: string, currentRevealed: Set<number>) => {
      if (useOriginalCharsOnly) {
        const positions = originalText.split('').map((char, i) => ({
          char,
          isSpace: char === ' ',
          index: i,
          isRevealed: currentRevealed.has(i),
        }));

        const nonSpaceChars = positions
          .filter((p) => !p.isSpace && !p.isRevealed)
          .map((p) => p.char);

        for (let i = nonSpaceChars.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];
        }

        let charIndex = 0;
        return positions
          .map((p) => {
            if (p.isSpace) return ' ';
            if (p.isRevealed) return originalText[p.index];
            return nonSpaceChars[charIndex++];
          })
          .join('');
      } else {
        return originalText
          .split('')
          .map((char, i) => {
            if (char === ' ') return ' ';
            if (currentRevealed.has(i)) return originalText[i];
            return availableChars[Math.floor(Math.random() * availableChars.length)];
          })
          .join('');
      }
    };

    if (isHovering) {
      setIsScrambling(true);
      interval = setInterval(() => {
        setRevealedIndices((prevRevealed) => {
          if (sequential) {
            if (prevRevealed.size < text.length) {
              const nextIndex = getNextIndex(prevRevealed);
              const newRevealed = new Set(prevRevealed);
              newRevealed.add(nextIndex);
              setDisplayText(shuffleText(text, newRevealed));
              return newRevealed;
            } else {
              clearInterval(interval);
              setIsScrambling(false);
              return prevRevealed;
            }
          } else {
            setDisplayText(shuffleText(text, prevRevealed));
            currentIteration++;
            if (currentIteration >= maxIterations) {
              clearInterval(interval);
              setIsScrambling(false);
              setDisplayText(text);
            }
            return prevRevealed;
          }
        });
      }, speed);
    } else {
      setDisplayText(text);
      setRevealedIndices(new Set());
      setIsScrambling(false);
    }

    return () => {
      if (interval) clearInterval(interval);
    };
  }, [
    isHovering,
    text,
    speed,
    maxIterations,
    sequential,
    revealDirection,
    characters,
    useOriginalCharsOnly,
  ]);

  useEffect(() => {
    if (animateOn !== 'view') return;

    const observerCallback = (entries: IntersectionObserverEntry[]) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting && !hasAnimated) {
          setIsHovering(true);
          setHasAnimated(true);
        }
      });
    };

    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1,
    };

    const observer = new IntersectionObserver(observerCallback, observerOptions);
    const currentRef = containerRef.current;
    if (currentRef) {
      observer.observe(currentRef);
    }

    return () => {
      if (currentRef) observer.unobserve(currentRef);
    };
  }, [animateOn, hasAnimated]);

  const hoverProps =
    animateOn === 'hover'
      ? {
          onMouseEnter: () => setIsHovering(true),
          onMouseLeave: () => setIsHovering(false),
        }
      : {};

  return (
    <motion.span
      ref={containerRef}
      className={`inline-block whitespace-pre-wrap ${parentClassName}`}
      {...hoverProps}
    >
      <span className="sr-only">{displayText}</span>

      <span aria-hidden="true">
        {displayText.split('').map((char, index) => {
          const isRevealedOrDone =
            revealedIndices.has(index) || !isScrambling || !isHovering;

          return (
            <span
              key={index}
              className={isRevealedOrDone ? className : encryptedClassName}
            >
              {char}
            </span>
          );
        })}
      </span>
    </motion.span>
  );
}
</file>

<file path="src/components/DecryptedTextDemo.tsx">
"use client";

import DecryptedText from './DecryptedText';

export function DecryptedTextDemo() {
  return (
    <div className="space-y-8 p-8 bg-black text-white">
      <h2 className="text-2xl font-bold mb-8">DecryptedText Component Examples</h2>
      
      {/* Example 1: Default hover effect */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 1: Default (hover to decrypt)</p>
        <DecryptedText 
          text="Hover over me to reveal the text!" 
          className="text-green-400 text-xl"
          encryptedClassName="text-gray-600 text-xl"
        />
      </div>

      {/* Example 2: Custom speed and characters */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 2: Custom speed and characters</p>
        <DecryptedText
          text="GULLIE TRAVEL PLANNER"
          speed={100}
          maxIterations={20}
          characters="GULLIE0123456789!@#"
          className="text-purple-400 text-2xl font-bold"
          encryptedClassName="text-purple-900 text-2xl font-bold"
        />
      </div>

      {/* Example 3: Animate on view (center reveal) */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 3: Animate on view (center reveal)</p>
        <DecryptedText
          text="This text animates when scrolled into view"
          animateOn="view"
          revealDirection="center"
          sequential={true}
          speed={40}
          className="text-blue-400 text-lg"
          encryptedClassName="text-blue-900 text-lg"
        />
      </div>

      {/* Example 4: Sequential reveal from end */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 4: Sequential reveal from end</p>
        <DecryptedText
          text="Watch me reveal from the end"
          sequential={true}
          revealDirection="end"
          speed={60}
          className="text-yellow-400 text-lg"
          encryptedClassName="text-yellow-900 text-lg"
        />
      </div>

      {/* Example 5: Using original characters only */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 5: Using original characters only</p>
        <DecryptedText
          text="123-456-7890"
          useOriginalCharsOnly={true}
          speed={80}
          className="text-red-400 text-xl font-mono"
          encryptedClassName="text-red-900 text-xl font-mono"
        />
      </div>

      {/* Example 6: Large heading with gradient */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 6: Large heading with gradient</p>
        <h1>
          <DecryptedText
            text="WELCOME TO GULLIE"
            animateOn="view"
            sequential={true}
            revealDirection="start"
            speed={50}
            className="gradient-text text-6xl font-bold"
            encryptedClassName="text-gray-800 text-6xl font-bold"
          />
        </h1>
      </div>

      {/* Example 7: Fast scramble effect */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 7: Fast scramble effect</p>
        <DecryptedText
          text="⚡ Lightning Fast Migration ⚡"
          speed={20}
          maxIterations={30}
          characters="⚡✨🚀💫⭐🌟"
          className="text-cyan-400 text-2xl"
          encryptedClassName="text-cyan-900 text-2xl"
        />
      </div>

      {/* Example 8: Multi-line text */}
      <div className="space-y-2">
        <p className="text-sm text-gray-500">Example 8: Multi-line text</p>
        <DecryptedText
          text={`Navigate global relocation with confidence.
Get personalized visa guidance.
Comprehensive support for your journey.`}
          animateOn="view"
          sequential={true}
          speed={30}
          className="text-gray-300"
          encryptedClassName="text-gray-700"
          parentClassName="block max-w-md"
        />
      </div>
    </div>
  );
}
</file>

<file path="src/components/EmailCaptureModal.tsx">
"use client";

import { useState } from "react";
import { usePDFUpload } from "@/hooks/usePDFUpload";

interface EmailCaptureModalProps {
  result: {
    type: string;
    visaType: string;
    timeline: string;
    totalCost: string;
    highlights?: string[];
  };
  userName: string;
  onClose: () => void;
}

export function EmailCaptureModal({ result, userName, onClose }: EmailCaptureModalProps) {
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { uploadPDF } = usePDFUpload();

  const handleSubmit = async () => {
    if (!email || !phone) return;
    
    setIsSubmitting(true);
    
    try {
      // Get cities from session storage or use defaults
      const originCity = sessionStorage.getItem("originCity") || "Your City";
      const originCountry = sessionStorage.getItem("originCountry") || "Your Country";
      const destinationCity = sessionStorage.getItem("destinationCity") || "Destination City";
      const destinationCountry = sessionStorage.getItem("destinationCountry") || "Destination Country";

      // Format visa options from result
      const visaOptions = `
        **${result.visaType}**
        Timeline: ${result.timeline}
        Total Cost: ${result.totalCost}
        ${result.highlights ? `\nHighlights:\n${result.highlights.map(h => `• ${h}`).join('\n')}` : ''}
      `;

      // 1. Generate and upload PDF to Convex storage
      const storageId = await uploadPDF({
        name: userName,
        email,
        originCity,
        originCountry,
        destinationCity,
        destinationCountry,
        visaOptions,
      });

      if (storageId) {
        // 2. Send email through API with PDF reference
        await fetch("/api/email", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            email,
            userName,
            storageId,
            fromCity: originCity,
            toCity: destinationCity,
            selectedOption: result
          })
        });

        alert("Report sent to your email!");
        onClose();
      } else {
        // Fallback: Send email without PDF
        await fetch("/api/email", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              email,
              userName,
              fromCity: "Current Location",
              toCity: "Destination",
              selectedOption: result
            })
          });

          // 3. Redirect to checkout
          const checkoutResponse = await fetch("/api/polar/checkout", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              email,
              userName,
              metadata: { selectedOption: result.type }
            })
          });

          const { checkoutUrl } = await checkoutResponse.json();
          
          if (checkoutUrl) {
            window.location.href = checkoutUrl;
          } else {
            alert("Report sent to your email!");
            onClose();
          }
      }
    } catch (error) {
      console.error("Error processing request:", error);
      alert("An error occurred. Please try again.");
      setIsSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black/90 flex items-center justify-center p-6 z-50 backdrop-blur-sm">
      <div className="bg-gray-900 border border-gray-700 p-10 max-w-md w-full space-y-8">
        <div className="space-y-3">
          <h2 className="text-3xl font-bold">Get Your Full Report</h2>
          <p className="text-gray-400">
            We&apos;ll send a comprehensive PDF with all pricing details and next steps.
          </p>
        </div>
        
        <div className="space-y-4">
          <div className="space-y-2">
            <label className="text-sm text-gray-400">Email Address</label>
            <input
              type="email"
              placeholder="john@example.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full px-4 py-3 bg-black border border-gray-700 focus:border-green-500"
              disabled={isSubmitting}
            />
          </div>
          
          <div className="space-y-2">
            <label className="text-sm text-gray-400">Phone Number</label>
            <input
              type="tel"
              placeholder="+44 20 1234 5678"
              value={phone}
              onChange={(e) => setPhone(e.target.value)}
              className="w-full px-4 py-3 bg-black border border-gray-700 focus:border-green-500"
              disabled={isSubmitting}
            />
          </div>
        </div>

        <div className="flex space-x-4">
          <button
            onClick={handleSubmit}
            disabled={isSubmitting || !email || !phone}
            className={`flex-1 px-6 py-3 font-semibold transition-all transform ${
              !isSubmitting && email && phone
                ? "bg-green-500 text-black hover:bg-green-400 hover:scale-105 active:scale-95"
                : "bg-gray-700 text-gray-500 cursor-not-allowed"
            }`}
          >
            {isSubmitting ? (
              <span className="flex items-center justify-center">
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Sending...
              </span>
            ) : (
              "Send Report"
            )}
          </button>
          <button
            onClick={onClose}
            disabled={isSubmitting}
            className="flex-1 px-6 py-3 border border-gray-600 hover:bg-gray-800 transition-colors"
          >
            Cancel
          </button>
        </div>

        <p className="text-xs text-gray-500 text-center">
          By submitting, you agree to our £1000/month service after the first free month.
          Cancel anytime before your visa is secured.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ResultCard.tsx">
"use client";

interface ResultData {
  type: string;
  visaType: string;
  timeline: string;
  totalCost: string;
  highlights?: string[];
}

interface ResultCardProps {
  title: string;
  type: "cheapest" | "fastest" | "convenient" | "premium";
  data: ResultData;
  onSelect: (data: ResultData) => void;
  isLocked: boolean;
}

export function ResultCard({ title, type, data, onSelect, isLocked }: ResultCardProps) {
  const getTypeStyles = () => {
    switch (type) {
      case "cheapest": 
        return {
          color: "text-green-400",
          border: "border-green-400/30",
          hover: "hover:border-green-400/60",
          icon: "💰"
        };
      case "fastest": 
        return {
          color: "text-blue-400",
          border: "border-blue-400/30",
          hover: "hover:border-blue-400/60",
          icon: "⚡"
        };
      case "convenient": 
        return {
          color: "text-purple-400",
          border: "border-purple-400/30",
          hover: "hover:border-purple-400/60",
          icon: "✨"
        };
      case "premium": 
        return {
          color: "text-yellow-400",
          border: "border-yellow-400/30",
          hover: "hover:border-yellow-400/60",
          icon: "👑"
        };
      default: 
        return {
          color: "text-gray-400",
          border: "border-gray-400/30",
          hover: "hover:border-gray-400/60",
          icon: "📋"
        };
    }
  };

  const styles = getTypeStyles();

  if (!data) {
    return (
      <div className={`card p-8 border-2 ${styles.border} opacity-50`}>
        <div className="flex items-start justify-between mb-6">
          <h3 className={`font-bold text-xl ${styles.color}`}>
            {title}
          </h3>
          <span className="text-2xl opacity-50">{styles.icon}</span>
        </div>
        <div className="space-y-3">
          <div className="h-4 bg-gray-800 rounded animate-pulse" />
          <div className="h-4 bg-gray-800 rounded w-3/4 animate-pulse" />
          <div className="h-4 bg-gray-800 rounded w-1/2 animate-pulse" />
        </div>
      </div>
    );
  }

  return (
    <div 
      className={`card p-8 border-2 cursor-pointer transition-all transform ${styles.border} ${styles.hover} ${
        !isLocked ? "hover:scale-105 hover:shadow-2xl" : ""
      }`}
      onClick={() => !isLocked && onSelect(data)}
    >
      <div className="flex items-start justify-between mb-6">
        <h3 className={`font-bold text-xl ${styles.color}`}>
          {title}
        </h3>
        <span className="text-2xl">{styles.icon}</span>
      </div>
      
      <div className="space-y-4">
        <div className="space-y-2">
          <span className="text-xs text-gray-500 uppercase tracking-wider">Visa Type</span>
          <p className="font-semibold text-lg">{data.visaType || "Loading..."}</p>
        </div>
        
        <div className="space-y-2">
          <span className="text-xs text-gray-500 uppercase tracking-wider">Timeline</span>
          <p className="font-semibold">{data.timeline || "Loading..."}</p>
        </div>
        
        <div className="space-y-2">
          <span className="text-xs text-gray-500 uppercase tracking-wider">Total Cost</span>
          <p className="font-bold text-2xl">
            {isLocked ? (
              <span className="blur-sm select-none">£XX,XXX</span>
            ) : (
              data.totalCost || "Calculating..."
            )}
          </p>
        </div>

        {data.highlights && data.highlights.length > 0 && (
          <div className="pt-4 border-t border-gray-800">
            <ul className="space-y-2">
              {data.highlights.slice(0, 3).map((item: string, i: number) => (
                <li key={i} className="flex items-start space-x-2 text-sm text-gray-400">
                  <span className="text-green-500 mt-1">•</span>
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>

      {!isLocked && (
        <button className={`mt-6 w-full py-3 border-2 ${styles.border} ${styles.color} text-sm font-bold uppercase tracking-wider hover:bg-white/5 transition-all`}>
          View Full Details →
        </button>
      )}
    </div>
  );
}
</file>

<file path="src/components/StreamingResults.tsx">
"use client";

import { useEffect, useState } from "react";
import { ResultCard } from "./ResultCard";
import { useStreamingSearch } from "@/hooks/useStreamingSearch";
import { EmailCaptureModal } from "./EmailCaptureModal";
import DecryptedText from "./DecryptedText";

interface StreamingResultsProps {
  userName: string;
  isSearching: boolean;
  isCallActive: boolean;
}

interface ResultData {
  type: string;
  visaType: string;
  timeline: string;
  totalCost: string;
  highlights?: string[];
}

export function StreamingResults({ 
  userName, 
  isCallActive 
}: StreamingResultsProps) {
  const { results, isLoading } = useStreamingSearch();
  const [selectedResult, setSelectedResult] = useState<ResultData | null>(null);

  useEffect(() => {
    if (isCallActive) {
      //TODO: Trigger search when user provides destination
      // This will be triggered by Vapi webhook or real-time events
    }
  }, [isCallActive]);

  return (
    <div className="space-y-12">
      {/* Header Section */}
      <div className="text-center space-y-4">
        <h1 className="text-4xl md:text-5xl font-bold">
          Hi <span className="gradient-text">
            <DecryptedText
              text={userName}
              animateOn="view"
              speed={50}
              maxIterations={10}
              className="gradient-text"
              encryptedClassName="text-gray-600"
            />
          </span>
        </h1>
        <p className="text-xl text-gray-400">
          {isCallActive 
            ? "Speaking with Gullie Agent... Tell us your destination city"
            : "Click 'Start Voice Consultation' to begin your relocation consultation"}
        </p>
        {isCallActive && (
          <div className="flex items-center justify-center space-x-3 mt-4">
            <div className="relative">
              <div className="w-4 h-4 bg-green-500 rounded-full animate-ping absolute"></div>
              <div className="w-4 h-4 bg-green-500 rounded-full"></div>
            </div>
            <span className="text-sm text-green-500 font-medium">Call Active</span>
          </div>
        )}
      </div>

      {/* Loading State */}
      {isLoading && (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="card p-8 space-y-4">
              <div className="h-6 bg-gray-800 rounded w-3/4 animate-pulse" />
              <div className="space-y-2">
                <div className="h-4 bg-gray-800 rounded w-full animate-pulse" />
                <div className="h-4 bg-gray-800 rounded w-5/6 animate-pulse" />
                <div className="h-4 bg-gray-800 rounded w-4/6 animate-pulse" />
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Results Grid */}
      {results.length > 0 && (
        <div className="space-y-8">
          <div className="text-center">
            <h2 className="text-2xl font-semibold text-gray-300">
              Your Personalized Relocation Options
            </h2>
            <p className="text-sm text-gray-500 mt-2">
              Click on any option to get the full detailed report
            </p>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {results.find(r => r.type === "cheapest") && (
              <ResultCard
                title="Cheapest Option"
                type="cheapest"
                data={results.find(r => r.type === "cheapest")!}
                onSelect={setSelectedResult}
                isLocked={!selectedResult}
              />
            )}
            {results.find(r => r.type === "fastest") && (
              <ResultCard
                title="Fastest Option"
                type="fastest"
                data={results.find(r => r.type === "fastest")!}
                onSelect={setSelectedResult}
                isLocked={!selectedResult}
              />
            )}
            {results.find(r => r.type === "convenient") && (
              <ResultCard
                title="Most Convenient"
                type="convenient"
                data={results.find(r => r.type === "convenient")!}
                onSelect={setSelectedResult}
                isLocked={!selectedResult}
              />
            )}
            {results.find(r => r.type === "premium") && (
              <ResultCard
                title="Premium Option"
                type="premium"
                data={results.find(r => r.type === "premium")!}
                onSelect={setSelectedResult}
                isLocked={!selectedResult}
              />
            )}
          </div>
        </div>
      )}

      {/* Email Capture Modal */}
      {selectedResult && (
        <EmailCaptureModal
          result={selectedResult}
          userName={userName}
          onClose={() => setSelectedResult(null)}
        />
      )}

      {/* Footer */}
      <div className="text-center pt-8 border-t border-gray-800">
        <p className="text-xs text-gray-600">
          Real-time analysis powered by AI • Updated as you speak
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/VapiButton.tsx">
import React from 'react';
import { useVapi } from '../hooks/useVapi';

interface VapiButtonProps {
  publicKey?: string;
  assistantId?: string;
  baseUrl?: string;
  className?: string;
  children?: React.ReactNode;
}

export const VapiButton: React.FC<VapiButtonProps> = ({
  publicKey = process.env.REACT_APP_VAPI_PUBLIC_KEY,
  assistantId = process.env.REACT_APP_VAPI_ASSISTANT_ID,
  baseUrl = process.env.REACT_APP_VAPI_BASE_URL,
  className,
  children,
}) => {
  const { startCall, endCall, isSessionActive, isLoading, error } = useVapi({
    publicKey: publicKey || '',
    assistantId: assistantId || '',
    baseUrl,
  });

  const handleClick = () => {
    if (isSessionActive) {
      endCall();
    } else {
      startCall();
    }
  };

  if (!publicKey || !assistantId) {
    return (
      <div className="text-red-500 p-2">
        Missing Vapi configuration. Please set environment variables.
      </div>
    );
  }

  return (
    <>
      <button
        onClick={handleClick}
        disabled={isLoading}
        className={className || "bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50"}
      >
        {children || (isLoading ? 'Connecting...' : isSessionActive ? 'End Call' : 'Start Call')}
      </button>
      {error && (
        <div className="text-red-500 mt-2 text-sm">
          Error: {error}
        </div>
      )}
    </>
  );
};
</file>

<file path="src/components/VapiExample.tsx">
import React from 'react';
import { VapiButton } from './VapiButton';

export const VapiExample: React.FC = () => {
  return (
    <div style={{ padding: '20px' }}>
      <h2>Vapi Voice Assistant Example</h2>
      <p>Click the button below to start a voice conversation:</p>
      
      <VapiButton />
      
      <div style={{ marginTop: '20px' }}>
        <h3>How it works:</h3>
        <ol>
          <li>Make sure you have set up your environment variables</li>
          <li>Click &quot;Start Call&quot; to begin the conversation</li>
          <li>Speak naturally with the assistant</li>
          <li>Click &quot;End Call&quot; when finished</li>
        </ol>
      </div>
    </div>
  );
};
</file>

<file path="src/hooks/usePDFUpload.ts">
"use client";

import { useState } from "react";
import { useMutation } from "convex/react";
import { api } from "../../convex/_generated/api";
import { generatePDFBlob } from "@/lib/pdf/generatePDF";
import { Id } from "../../convex/_generated/dataModel";

interface PDFUploadData {
  name: string;
  email: string;
  originCity: string;
  originCountry: string;
  destinationCity: string;
  destinationCountry: string;
  visaOptions: string;
}

export function usePDFUpload() {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const generateUploadUrl = useMutation(api.storage.generateUploadUrl);
  const savePDFReference = useMutation(api.storage.savePDFReference);

  const uploadPDF = async (data: PDFUploadData): Promise<Id<"_storage"> | null> => {
    setIsUploading(true);
    setError(null);

    try {
      // Generate PDF blob
      const pdfBlob = await generatePDFBlob({
        ...data,
        timestamp: new Date().toISOString(),
      });

      // Get upload URL from Convex
      const uploadUrl = await generateUploadUrl();

      // Upload PDF to Convex storage
      const response = await fetch(uploadUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/pdf",
        },
        body: pdfBlob,
      });

      if (!response.ok) {
        throw new Error("Failed to upload PDF");
      }

      const { storageId } = await response.json();

      // Save reference in database
      await savePDFReference({
        storageId,
        email: data.email,
        fileName: `relocation-report-${data.destinationCity.toLowerCase()}.pdf`,
      });

      setIsUploading(false);
      return storageId;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to upload PDF";
      setError(errorMessage);
      setIsUploading(false);
      console.error("PDF upload error:", err);
      return null;
    }
  };

  return {
    uploadPDF,
    isUploading,
    error,
  };
}
</file>

<file path="src/hooks/useStreamingSearch.ts">
"use client";

import { useState, useCallback } from "react";
import { streamSearchResults } from "@/app/actions";

interface SearchResult {
  type: string;
  visaType: string;
  timeline: string;
  totalCost: string;
  highlights?: string[];
}

export function useStreamingSearch() {
  const [results, setResults] = useState<SearchResult[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const startSearch = useCallback(async (fromCity: string, toCity: string) => {
    setIsLoading(true);
    setResults([]);

    try {
      //TODO: Implement streaming with Vercel AI SDK
      // This will call the server action that uses streamUI
      await streamSearchResults(fromCity, toCity);
      
      // For now, simulate streaming results
      const mockResults = [
        {
          type: "cheapest",
          visaType: "Working Holiday Visa",
          timeline: "3-4 weeks",
          totalCost: "£3,500",
          highlights: ["Budget airlines", "Shared accommodation", "DIY application"]
        },
        {
          type: "fastest",
          visaType: "Priority Skilled Worker",
          timeline: "5-7 days",
          totalCost: "£12,000",
          highlights: ["Express processing", "Premium flights", "Relocation service"]
        },
        {
          type: "convenient",
          visaType: "Standard Skilled Worker",
          timeline: "2-3 weeks",
          totalCost: "£7,500",
          highlights: ["Full service support", "Direct flights", "Temporary housing"]
        },
        {
          type: "premium",
          visaType: "Investor Visa",
          timeline: "1-2 weeks",
          totalCost: "£25,000",
          highlights: ["VIP processing", "Business class", "Luxury accommodation"]
        }
      ];

      // Simulate streaming
      for (const result of mockResults) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        setResults(prev => [...prev, result]);
      }
    } catch (error) {
      console.error("Search failed:", error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  return {
    results,
    isLoading,
    startSearch
  };
}
</file>

<file path="src/hooks/useVapi.tsx">
import { useState, useCallback, useEffect } from 'react';
import Vapi from '@vapi-ai/web';

interface VapiConfig {
  publicKey: string;
  assistantId: string;
  baseUrl?: string;
}

interface VapiState {
  isSessionActive: boolean;
  isLoading: boolean;
  error: string | null;
}

export const useVapi = (config: VapiConfig) => {
  const [vapi, setVapi] = useState<Vapi | null>(null);
  const [state, setState] = useState<VapiState>({
    isSessionActive: false,
    isLoading: false,
    error: null,
  });

  useEffect(() => {
    const vapiInstance = new Vapi(config.publicKey, config.baseUrl);
    setVapi(vapiInstance);

    const handleCallStart = () => {
      setState(prev => ({ ...prev, isSessionActive: true, isLoading: false }));
    };

    const handleCallEnd = () => {
      setState(prev => ({ ...prev, isSessionActive: false, isLoading: false }));
    };

    const handleError = (error: Error) => {
      setState(prev => ({ ...prev, error: error.message, isLoading: false }));
    };

    vapiInstance.on('call-start', handleCallStart);
    vapiInstance.on('call-end', handleCallEnd);
    vapiInstance.on('error', handleError);

    return () => {
      vapiInstance.off('call-start', handleCallStart);
      vapiInstance.off('call-end', handleCallEnd);
      vapiInstance.off('error', handleError);
    };
  }, [config.publicKey, config.baseUrl]);

  const startCall = useCallback(async () => {
    if (!vapi) return;

    setState(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      await vapi.start(config.assistantId);
    } catch (error) {
      setState(prev => ({ ...prev, error: error instanceof Error ? error.message : 'An error occurred', isLoading: false }));
    }
  }, [vapi, config.assistantId]);

  const endCall = useCallback(() => {
    if (!vapi) return;
    vapi.stop();
  }, [vapi]);

  return {
    startCall,
    endCall,
    ...state,
  };
};
</file>

<file path="src/hooks/useVapiCall.ts">
"use client";

import { useState, useEffect } from "react";
import Vapi from "@vapi-ai/web";

interface VapiMessage {
  type: string;
  [key: string]: unknown;
}

export function useVapiCall() {
  const [vapi, setVapi] = useState<Vapi | null>(null);
  const [isCallActive, setIsCallActive] = useState(false);
  const [callData, setCallData] = useState<VapiMessage | null>(null);

  useEffect(() => {
    //TODO: Add VAPI_PUBLIC_KEY to .env.local
    const publicKey = process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY;
    
    if (publicKey) {
      const vapiInstance = new Vapi(publicKey);
      
      vapiInstance.on("call-start", () => {
        setIsCallActive(true);
      });

      vapiInstance.on("call-end", () => {
        setIsCallActive(false);
      });

      vapiInstance.on("message", (message) => {
        console.log("Vapi message:", message);
        setCallData(message);
      });

      setVapi(vapiInstance);
    }
  }, []);

  const startCall = async () => {
    if (!vapi) {
      console.error("Vapi not initialized");
      return;
    }

    try {
      //TODO: Add VAPI_ASSISTANT_ID to .env.local
      // Create assistant at https://dashboard.vapi.ai
      // Configure with greeting: "Hi {{user_name}} this is Gullie Agent, which city are you considering relocation today?"
      const assistantId = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;
      
      if (!assistantId) {
        console.error("VAPI_ASSISTANT_ID not configured");
        return;
      }

      await vapi.start(assistantId);
    } catch (error) {
      console.error("Failed to start Vapi call:", error);
    }
  };

  const endCall = async () => {
    if (vapi && isCallActive) {
      await vapi.stop();
    }
  };

  return {
    startCall,
    endCall,
    isCallActive,
    callData
  };
}
</file>

<file path="src/lib/mcp/exa-tools.ts">
import { z } from "zod";

//TODO: Add EXA_API_KEY to .env.local
// Get from: https://dashboard.exa.ai

const EXA_API_URL = "https://api.exa.ai/search";

export const ExaSearchSchema = z.object({
  query: z.string().describe("Search query for visa and relocation information"),
  fromCountry: z.string().describe("Country of origin"),
  toCountry: z.string().describe("Destination country"),
  searchType: z.enum(["visa", "flight", "housing", "school", "general"]),
});

export type ExaSearchParams = z.infer<typeof ExaSearchSchema>;

export async function searchWithExa(params: ExaSearchParams) {
  const apiKey = process.env.EXA_API_KEY;
  
  if (!apiKey) {
    throw new Error("EXA_API_KEY not configured");
  }

  const searchQuery = buildSearchQuery(params);
  
  try {
    const response = await fetch(EXA_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey,
      },
      body: JSON.stringify({
        query: searchQuery,
        num_results: 10,
        contents: {
          text: true,
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Exa API error: ${response.statusText}`);
    }

    const data = await response.json();
    return processExaResults(data, params.searchType);
  } catch (error) {
    console.error("Exa search failed:", error);
    throw error;
  }
}

function buildSearchQuery(params: ExaSearchParams): string {
  const { query, fromCountry, toCountry, searchType } = params;
  
  switch (searchType) {
    case "visa":
      return `${fromCountry} to ${toCountry} visa requirements application process timeline cost ${query}`;
    case "flight":
      return `flights from ${fromCountry} to ${toCountry} cheapest airlines direct routes ${query}`;
    case "housing":
      return `${toCountry} housing rental apartments accommodation cost areas ${query}`;
    case "school":
      return `${toCountry} schools education international enrollment ${query}`;
    default:
      return `${fromCountry} to ${toCountry} relocation moving ${query}`;
  }
}

interface ExaResult {
  title: string;
  url: string;
  text: string;
  score: number;
}

interface ExaResponse {
  results?: ExaResult[];
}

function processExaResults(data: ExaResponse, searchType: string) {
  const results = data.results || [];
  
  return results.map((result: ExaResult) => ({
    title: result.title,
    url: result.url,
    text: result.text,
    relevanceScore: result.score,
    searchType,
    highlights: extractHighlights(result.text, searchType),
  }));
}

function extractHighlights(text: string, searchType: string): string[] {
  const highlights: string[] = [];
  
  // Extract key information based on search type
  const patterns: Record<string, RegExp[]> = {
    visa: [
      /processing time:?\s*([^.]+)/i,
      /cost:?\s*([^.]+)/i,
      /requirements?:?\s*([^.]+)/i,
    ],
    flight: [
      /price:?\s*([^.]+)/i,
      /duration:?\s*([^.]+)/i,
      /airline:?\s*([^.]+)/i,
    ],
    housing: [
      /rent:?\s*([^.]+)/i,
      /area:?\s*([^.]+)/i,
      /bedroom:?\s*([^.]+)/i,
    ],
    school: [
      /tuition:?\s*([^.]+)/i,
      /enrollment:?\s*([^.]+)/i,
      /curriculum:?\s*([^.]+)/i,
    ],
  };
  
  const relevantPatterns = patterns[searchType] || [];
  
  for (const pattern of relevantPatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      highlights.push(match[1].trim().substring(0, 100));
    }
  }
  
  return highlights.slice(0, 3);
}

const searchVisaParams = z.object({
  fromCountry: z.string(),
  toCountry: z.string(),
  visaType: z.string().optional(),
});

const searchFlightsParams = z.object({
  fromCity: z.string(),
  toCity: z.string(),
  dateRange: z.string().optional(),
});

const searchHousingParams = z.object({
  city: z.string(),
  budget: z.string().optional(),
  type: z.string().optional(),
});

const searchSchoolsParams = z.object({
  city: z.string(),
  level: z.string().optional(),
  international: z.boolean().optional(),
});

export const mcpExaTools = {
  searchVisa: {
    description: "Search for visa requirements and application information",
    parameters: searchVisaParams,
    execute: async (params: z.infer<typeof searchVisaParams>) => {
      return searchWithExa({
        query: params.visaType || "visa requirements",
        fromCountry: params.fromCountry,
        toCountry: params.toCountry,
        searchType: "visa",
      });
    },
  },
  
  searchFlights: {
    description: "Search for flight options and pricing",
    parameters: searchFlightsParams,
    execute: async (params: z.infer<typeof searchFlightsParams>) => {
      return searchWithExa({
        query: params.dateRange || "flight options",
        fromCountry: params.fromCity,
        toCountry: params.toCity,
        searchType: "flight",
      });
    },
  },
  
  searchHousing: {
    description: "Search for housing and accommodation options",
    parameters: searchHousingParams,
    execute: async (params: z.infer<typeof searchHousingParams>) => {
      return searchWithExa({
        query: `${params.budget || ""} ${params.type || "housing"}`,
        fromCountry: "",
        toCountry: params.city,
        searchType: "housing",
      });
    },
  },
  
  searchSchools: {
    description: "Search for schools and education options",
    parameters: searchSchoolsParams,
    execute: async (params: z.infer<typeof searchSchoolsParams>) => {
      return searchWithExa({
        query: `${params.level || ""} ${params.international ? "international" : ""} schools`,
        fromCountry: "",
        toCountry: params.city,
        searchType: "school",
      });
    },
  },
};
</file>

<file path="src/lib/pdf/generatePDF.ts">
import html2pdf from 'html2pdf.js';

interface PDFData {
  name: string;
  email: string;
  originCity: string;
  originCountry: string;
  destinationCity: string;
  destinationCountry: string;
  visaOptions: string;
  timestamp: string;
}

export async function generatePDFBlob(data: PDFData): Promise<Blob> {
  const htmlContent = `
    <div id="pdf-content" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; margin: -40px -40px 30px -40px;">
        <h1 style="margin: 0; font-size: 28px;">Your Relocation Report</h1>
        <p style="margin: 10px 0 0 0; font-size: 16px;">From ${data.originCity}, ${data.originCountry} to ${data.destinationCity}, ${data.destinationCountry}</p>
      </div>
      
      <div style="margin-bottom: 30px;">
        <p style="font-size: 16px; margin-bottom: 10px;">Dear ${data.name},</p>
        <p style="font-size: 14px; line-height: 1.6; color: #666;">Thank you for using Gullie for your relocation planning. Based on our analysis, here's your comprehensive relocation report.</p>
      </div>
      
      <div style="border-left: 4px solid #667eea; padding-left: 20px; margin: 30px 0;">
        <h2 style="color: #667eea; margin-top: 0; font-size: 20px;">📋 Visa Options Summary</h2>
        <div style="font-size: 14px; line-height: 1.8; color: #333;">
          ${formatVisaOptions(data.visaOptions)}
        </div>
      </div>
      
      <div style="border-left: 4px solid #667eea; padding-left: 20px; margin: 30px 0;">
        <h2 style="color: #667eea; margin-top: 0; font-size: 20px;">📅 Recommended Timeline</h2>
        <ul style="font-size: 14px; line-height: 1.8; color: #333;">
          <li><strong>Month 1:</strong> Research and document gathering</li>
          <li><strong>Month 2:</strong> Visa application submission</li>
          <li><strong>Month 3:</strong> Housing arrangements and travel booking</li>
          <li><strong>Month 4:</strong> Final preparations and relocation</li>
        </ul>
      </div>
      
      <div style="border-left: 4px solid #667eea; padding-left: 20px; margin: 30px 0;">
        <h2 style="color: #667eea; margin-top: 0; font-size: 20px;">📄 Document Checklist</h2>
        <ul style="font-size: 14px; line-height: 1.8; color: #333;">
          <li>Valid passport (6+ months validity)</li>
          <li>Visa application forms</li>
          <li>Proof of funds/bank statements</li>
          <li>Employment letter/contract</li>
          <li>Housing proof/rental agreement</li>
          <li>Health insurance documentation</li>
          <li>Educational certificates (if applicable)</li>
          <li>Criminal background check</li>
        </ul>
      </div>
      
      <div style="border-left: 4px solid #667eea; padding-left: 20px; margin: 30px 0;">
        <h2 style="color: #667eea; margin-top: 0; font-size: 20px;">💡 Next Steps</h2>
        <ol style="font-size: 14px; line-height: 1.8; color: #333;">
          <li><strong>Choose your visa type</strong> based on your circumstances and timeline</li>
          <li><strong>Gather all required documents</strong> from the checklist above</li>
          <li><strong>Book visa appointment</strong> at the nearest consulate/embassy</li>
          <li><strong>Arrange housing</strong> in ${data.destinationCity}</li>
          <li><strong>Book flights</strong> once visa is approved</li>
        </ol>
      </div>
      
      <div style="border-left: 4px solid #667eea; padding-left: 20px; margin: 30px 0;">
        <h2 style="color: #667eea; margin-top: 0; font-size: 20px;">🔗 Helpful Resources</h2>
        <ul style="font-size: 14px; line-height: 1.8; color: #333;">
          <li>Official Immigration Website for ${data.destinationCountry}</li>
          <li>Embassy/Consulate contact information</li>
          <li>Local expat communities and forums</li>
          <li>Housing platforms for ${data.destinationCity}</li>
        </ul>
      </div>
      
      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e5e5;">
        <p style="font-size: 14px; color: #666;">
          <strong>Need more help?</strong> Contact us through our AI assistant for personalized guidance.
        </p>
        <p style="font-size: 14px; color: #666;">
          Best regards,<br>
          The Gullie Team
        </p>
      </div>
      
      <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e5e5;">
        <p style="font-size: 12px; color: #999;">© 2024 Gullie Travel Planner. All rights reserved.</p>
        <p style="font-size: 12px; color: #999;">This report was generated on ${new Date(data.timestamp).toLocaleDateString()}</p>
      </div>
    </div>
  `;

  const container = document.createElement('div');
  container.innerHTML = htmlContent;
  document.body.appendChild(container);

  const options = {
    margin: 10,
    filename: `relocation-report-${data.destinationCity.toLowerCase()}.pdf`,
    image: { type: 'jpeg' as const, quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm' as const, format: 'a4' as const, orientation: 'portrait' as const }
  };

  try {
    const element = container.firstElementChild;
    if (!element) {
      throw new Error('No content to generate PDF');
    }
    
    const pdfOutput = await html2pdf()
      .set(options)
      .from(element)
      .outputPdf('blob');
    
    const pdfBlob = pdfOutput as Blob;
    
    document.body.removeChild(container);
    return pdfBlob;
  } catch (error) {
    document.body.removeChild(container);
    throw error;
  }
}

function formatVisaOptions(visaOptions: string): string {
  if (!visaOptions) {
    return "<p>Detailed visa information will be provided based on your specific situation.</p>";
  }
  
  const formatted = visaOptions
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\n/g, '<br>')
    .replace(/• /g, '</li><li>')
    .replace(/(\d+\. )/g, '</li><li>');
  
  return formatted;
}
</file>

<file path="src/providers/ConvexClientProvider.tsx">
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";

//TODO: Add NEXT_PUBLIC_CONVEX_URL to .env.local
// Get from: https://dashboard.convex.dev
const convex = new ConvexReactClient(
  process.env.NEXT_PUBLIC_CONVEX_URL || ""
);

export function ConvexClientProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}
</file>

<file path="src/providers/VapiProvider.tsx">
"use client";

import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";
import Vapi from "@vapi-ai/web";

interface VapiContextType {
  vapi: Vapi | null;
  isCallActive: boolean;
  isInitialized: boolean;
  transcript: Array<{ role: string; text: string }>;
  isSpeaking: boolean;
  startCall: (userName?: string) => Promise<void>;
  endCall: () => Promise<void>;
}

const VapiContext = createContext<VapiContextType | undefined>(undefined);

export function VapiProvider({ children }: { children: ReactNode }) {
  const [vapi, setVapi] = useState<Vapi | null>(null);
  const [isCallActive, setIsCallActive] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const [transcript, setTranscript] = useState<Array<{ role: string; text: string }>>([]);
  const [isSpeaking, setIsSpeaking] = useState(false);

  useEffect(() => {
    const publicKey = process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY;
    
    if (!publicKey) {
      console.error("NEXT_PUBLIC_VAPI_PUBLIC_KEY not configured");
      return;
    }

    const vapiInstance = new Vapi(publicKey);
    
    // Call lifecycle events
    vapiInstance.on("call-start", () => {
      console.log("Vapi call started");
      setIsCallActive(true);
      setTranscript([]);
    });

    vapiInstance.on("call-end", () => {
      console.log("Vapi call ended");
      setIsCallActive(false);
      setIsSpeaking(false);
    });

    // Speech events
    vapiInstance.on("speech-start", () => {
      setIsSpeaking(true);
    });

    vapiInstance.on("speech-end", () => {
      setIsSpeaking(false);
    });

    // Message events
    vapiInstance.on("message", (message) => {
      console.log("Vapi message:", message);
      
      if (message.type === "transcript") {
        setTranscript(prev => [...prev, {
          role: message.role,
          text: message.transcript
        }]);
      }
    });

    // Error handling
    vapiInstance.on("error", (error) => {
      console.error("Vapi error:", error);
    });

    setVapi(vapiInstance);
    setIsInitialized(true);

    return () => {
      if (vapiInstance) {
        vapiInstance.stop();
      }
    };
  }, []);

  const startCall = async () => {
    if (!vapi || !isInitialized) {
      console.error("Vapi not initialized");
      return;
    }

    // Prevent multiple simultaneous call attempts
    if (isCallActive) {
      console.log("Call already active");
      return;
    }

    const assistantId = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;
    
    if (!assistantId) {
      console.error("NEXT_PUBLIC_VAPI_ASSISTANT_ID not configured");
      return;
    }

    try {
      // Add a small delay to ensure audio processors are ready
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Start the call with custom configuration to avoid Krisp issues
      await vapi.start(assistantId);
    } catch (error) {
      console.error("Failed to start Vapi call:", error);
      // Try to recover from the error
      setIsCallActive(false);
      setIsSpeaking(false);
    }
  };

  const endCall = async () => {
    if (vapi && isCallActive) {
      try {
        await vapi.stop();
      } catch (error) {
        console.error("Failed to end Vapi call:", error);
      }
    }
  };

  return (
    <VapiContext.Provider value={{
      vapi,
      isCallActive,
      isInitialized,
      transcript,
      isSpeaking,
      startCall,
      endCall
    }}>
      {children}
    </VapiContext.Provider>
  );
}

export function useVapi() {
  const context = useContext(VapiContext);
  if (context === undefined) {
    throw new Error("useVapi must be used within a VapiProvider");
  }
  return context;
}
</file>

<file path="src/types/html2pdf.d.ts">
declare module 'html2pdf.js' {
  interface Html2PdfOptions {
    margin?: number | number[];
    filename?: string;
    image?: {
      type?: 'jpeg' | 'png' | 'webp';
      quality?: number;
    };
    html2canvas?: {
      scale?: number;
      useCORS?: boolean;
      [key: string]: unknown;
    };
    jsPDF?: {
      unit?: 'pt' | 'mm' | 'cm' | 'in';
      format?: string | number[];
      orientation?: 'portrait' | 'landscape';
      [key: string]: unknown;
    };
    pagebreak?: {
      mode?: string | string[];
      before?: string | string[];
      after?: string | string[];
      avoid?: string | string[];
    };
    enableLinks?: boolean;
  }

  interface Html2PdfWorker {
    from(element: Element | string): Html2PdfWorker;
    set(options: Html2PdfOptions): Html2PdfWorker;
    save(filename?: string): Promise<void>;
    outputPdf(type: 'blob' | 'datauristring' | 'arraybuffer'): Promise<Blob | string | ArrayBuffer>;
    then<T>(onFulfilled: (value: T) => T | PromiseLike<T>): Html2PdfWorker;
  }

  function html2pdf(): Html2PdfWorker;
  function html2pdf(element: Element, options?: Html2PdfOptions): Promise<void>;

  export = html2pdf;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;
</file>

<file path="IMPLE_BAK.md">
# Implementation Plan - Gullie Global Mobility Expert

## Architecture Overview

### Core Components

1. **Frontend (Next.js + Vercel AI SDK)**

   - Single page app with streaming UI
   - Dark theme with Distek Mono font
   - Real-time search results display
   - Card-based results presentation

2. **Backend Services**

   - **Convex**: Database for users, cities, documents, vector embeddings
   - **Vapi**: Voice AI for phone support
   - **Exa API**: Web search for visa/relocation info
   - **MCP (Model Context Protocol)**: Tool orchestration
   - **Resend**: Email delivery
   - **Polar**: Subscription billing

3. **AI Agents**
   - Mobility Expert Agent (main conversational AI)
   - Search Agent (Exa integration)
   - Document Generator Agent (PDF creation)

## Implementation Phases

### Phase 1: Foundation Setup ✅

- [x] Project structure
- [x] Convex schemas for city data
- [ ] Environment variables setup
- [ ] Dark theme configuration

### Phase 2: Frontend Development

- [ ] Landing page with value proposition
- [ ] User name input field
- [ ] Streaming UI for search results
- [ ] Card components for solutions
- [ ] Email/phone capture modal

## Detailed Implementation Plan

This is how we plan to do it in details:

1. When users are moving countries, they need to consider each country's visa options based on where they are coming from, the cost of types of visa, the complexity of preparation and the timeline

2. When user are moving, they also need to consider flight ticket, housing options, moving services (include furniture and moving cost) and school enrollment if they have kids

3. User can ask further on each visa type, given the answer the AI agent will use Exa search to find out what are the requirements for each specific visa type, answer it to user and then it can give estimate on how long it might take for the user to prepare and what type of documents are required.

4. If user ask for a specific documents it will also answer on the detailed requirement on what should be included in that document.

5. Restrict the LLM to only answer questions related to global mobility and relocation, any questions not related to global mobility and relocation will get an answer like "I am sorry I can only answer questions related to global relocation, is there any specific question related to this topic i can help you with?"

6. As soon as user tell us which city, country they are moving to and which city, country they are from, we will run simulation/search query with `https://docs.exa.ai/reference/getting-started`'s endpoint based on four directions: cheapest, fastest, most expensive and most convenient.

7. To improve latency, we won't be telling user all of these information at once, but we will have the searched results in advance, saved on database as vector embedding (convex), and when user asked for a specific question, we first search for database for this answer, and then we fallback to use Exa to search again. And when user asked for specific details, we will be telling them an estimate on the cost based on our saved results.

8. We will only display the solution as cards, cover the pricing on frontend, when user click on it we will prompt them for email and phone numbers, inform them we will send the consulting results as a comprehensive PDF file to their email once they confirm it

9. Create a web worker to generate PDF file for the user, unhide the pricing, save it to convex's document (this schema don't exists yet) and also send this PDF file to user's email using resend.

10. We will use Polar to charge users, the pricing plan is £1000 a month, and we will continue to support users until their visa process is completed. If user land their visa within a month, we don't charge anything because we will only charge at the end of the month (like a month free trial) - but user will always be able to call us any time

11. Please explain the details and value propositions clear on the landing page - but keep the call to action, input field apparent too

## Initial Setup Notes

- Initially, our frontend only take one value, their name and we will start with greeting them with a question.

- The first sentence for the AI agent on this phone call should be "Hi {{user_name}} this is Gullie Agent, which city you are considering relocation today?"

- We will start with frontend implementation first because we will spend more time tweaking backend. We don't need a lot of pages but just one.

- When the results are not coming in yet, please have the streamed search results display on `app/page.tsx`'s frontend just so users don't wait.

- Create different AI agents, tool calls, use model context protocol wherever you see fit, but also let me know the architecture and write the plan as you go so i can watch as we go.

- Feel free to ask me any questions you are unclear about or feel dangerous to implement.

TODO:
🔴 TODO Items for You:

1. Environment Variables - Copy .env.local.example to .env.local and add:


    - Convex deployment URL
    - Vapi keys and assistant ID
    - OpenAI API key
    - Exa API key
    - Resend API key
    - Polar access tokens

2. Font Files - Add Distek Mono font files to /public/fonts/:


    - Disket-Mono-Regular.ttf
    - Disket-Mono-Bold.ttf

3. Vapi Assistant - Configure in dashboard with greeting:
   "Hi {{user_name}} this is Gullie Agent, which city are you considering relocation today?"
4. Polar Product - Create £1000/month subscription plan
5. Resend Domain - Verify your sending domain

📝 Key Features Implemented:

- Streaming search results display while user speaks
- Four pricing tiers: Cheapest, Fastest, Convenient, Premium
- Blurred pricing until email/phone captured
- PDF generation with comprehensive report
- Email delivery with attachment
- Phone support via Vapi
- Dark electric theme with transform animations
</file>

<file path="IMPLEMENTATION_PLAN.md">
# Implementation Plan - Gullie Global Mobility Expert

## Architecture Overview

### Core Components
1. **Frontend (Next.js + Vercel AI SDK)**
   - Single page app with streaming UI
   - Dark theme with Distek Mono font
   - Real-time search results display
   - Card-based results presentation

2. **Backend Services**
   - **Convex**: Database for users, cities, documents, vector embeddings
   - **Vapi**: Voice AI for phone support
   - **Exa API**: Web search for visa/relocation info
   - **MCP (Model Context Protocol)**: Tool orchestration
   - **Resend**: Email delivery
   - **Polar**: Subscription billing

3. **AI Agents**
   - Mobility Expert Agent (main conversational AI)
   - Search Agent (Exa integration)
   - Document Generator Agent (PDF creation)

## Implementation Phases

### Phase 1: Foundation Setup ✅
- [x] Project structure
- [x] Convex schemas for city data
- [ ] Environment variables setup
- [ ] Dark theme configuration

### Phase 2: Frontend Development
- [ ] Landing page with value proposition
- [ ] User name input field
- [ ] Streaming UI for search results
- [ ] Card components for solutions
- [ ] Email/phone capture modal

### Phase 3: Backend Integration
- [ ] Vapi phone call setup
- [ ] Exa search integration
- [ ] Vector embedding storage
- [ ] MCP tool creation

### Phase 4: PDF & Email
- [ ] Web worker for PDF generation
- [ ] Resend email integration
- [ ] Document storage in Convex

### Phase 5: Payment & Polish
- [ ] Polar subscription setup
- [ ] Testing & optimization
- [ ] TypeScript compliance

## Key TODOs for You:

### 🔴 Critical Setup Required:
1. **Environment Variables** - Add to `.env.local`:
   ```
   CONVEX_DEPLOYMENT=✅ (configured)
   VAPI_API_KEY=✅ (configured)
   EXA_API_KEY=✅ (configured)
   RESEND_API_KEY=✅ (configured)
   POLAR_API_KEY=✅ (configured)
   OPEN_AI_API=✅ (configured as OPEN_AI_API)
   ```

2. **Vapi Configuration**:
   - ✅ Vapi account created
   - ✅ Assistant ID configured: 840687a8-bf27-4eee-b392-e8ddde8f2dae
   - 🔄 **IMPORTANT**: Run tool registration script to add tools to assistant:
     ```bash
     bun run scripts/register-vapi-tools.ts
     ```
   - Configure phone number in Vapi dashboard
   - Configure assistant greeting script

3. **Polar Setup**:
   - Create Polar account
   - Configure £1000/month subscription plan
   - Set up webhook endpoints

4. **Font Installation**:
   - Add Distek Mono font files to `/public/fonts/`
   - Or configure Google Fonts if available

### 🟡 Configuration Decisions:
1. Which LLM provider for Vercel AI SDK? (OpenAI/Anthropic/etc)
2. Preferred PDF library? (jsPDF, react-pdf, puppeteer)
3. Vapi assistant configuration details
4. Specific visa types to prioritize

### 🟢 Optional Enhancements:
1. Analytics tracking
2. Error monitoring (Sentry)
3. Rate limiting strategy
4. Caching strategy for Exa results

## Vapi Tools Documentation

### Available Tools for Voice Assistant

All tools are exposed via HTTP endpoints at `https://impartial-ladybug-267.convex.site/tools/`

1. **search_relocation_options** - Main search tool for visa/relocation options
   - Parameters: origin_city, origin_country, destination_city, destination_country
   - Returns: 4 visa options (budget, express, balanced, premium)

2. **get_visa_requirements** - Detailed visa requirements lookup
   - Parameters: origin_country, destination_country, visa_type (tourist/work/student/business)
   - Returns: Specific requirements, documents, processing times

3. **estimate_relocation_costs** - Cost breakdown calculator
   - Parameters: destination_city, include_flight, include_housing, include_moving, family_size
   - Returns: Detailed cost estimates

4. **get_document_details** - Document requirement details
   - Parameters: document_type, country
   - Returns: Specific document requirements and processes

5. **capture_contact_info** - Store user contact for follow-up
   - Parameters: email, phone, name
   - Returns: Confirmation message

6. **send_pdf_report** - Generate and email comprehensive PDF report
   - Parameters: email, consultation_data
   - Returns: Email confirmation

7. **confirm_visa_options** - Handle user choice (email vs discuss)
   - Parameters: user_choice, email, name, search_data, location details
   - Returns: Appropriate response based on choice

### Tool Registration
Run `bun run scripts/register-vapi-tools.ts` to register all tools with Vapi assistant.

### Notes on Implementation
- CORS headers disabled in convex/http.ts as requested
- All tools follow Vapi's expected request/response format
- Tool responses use toolCallId for proper correlation
- Error handling returns friendly messages

## Unused Files (Can be deleted)
- `src/components/VapiExample.tsx` - Demo component not used in production
- `src/components/DecryptedTextDemo.tsx` - Demo component not used in production
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="convex/schemas/city.ts">
import { v } from "convex/values";

export const city = {
  date: v.optional(v.id("dates")),
  user: v.optional(v.id("users")),
  departure_city: v.string(),
  departure_country: v.optional(v.string()),
  arrival_city: v.string(),
  arrival_country: v.optional(v.string()),
  results: v.optional(v.string()),
};
</file>

<file path="convex/schemas/user.ts">
import { v } from "convex/values";

export const user = {
  name: v.string(),
  // when we ask user's name we might not know where they are coming from yet
  nationality: v.optional(v.string()),
  email: v.optional(v.string()),
  phone: v.optional(v.string()),
  lastContactedAt: v.optional(v.number()),
  lastReportSentAt: v.optional(v.number()),
  createdAt: v.optional(v.number()),
};
</file>

<file path="convex/schemas/zod_schemas.ts">
import { z } from "zod";

// Base cost schema
export const CostSchema = z.object({
  amount: z.number().positive("Cost must be a positive number"),
  currency: z.string().min(3, "Currency code must be at least 3 characters"),
  notes: z.string().optional(),
});

// Flight cost schema
export const FlightCostSchema = z.object({
  base_fare: CostSchema,
  taxes: CostSchema.optional(),
  fees: CostSchema.optional(),
  total_cost: CostSchema,
  airline: z.string().optional(),
  class: z.enum(["economy", "premium_economy", "business", "first"]).optional(),
  baggage_included: z.boolean().optional(),
});

// Housing cost schema
export const HousingCostSchema = z.object({
  monthly_rent: CostSchema.optional(),
  security_deposit: CostSchema.optional(),
  utilities: CostSchema.optional(),
  total_monthly_cost: CostSchema,
  property_type: z.enum(["apartment", "house", "condo", "studio"]).optional(),
  bedrooms: z.number().int().min(0).optional(),
  area_sqft: z.number().positive().optional(),
  neighborhood: z.string().optional(),
});

// Furniture moving cost schema
export const MovingCostSchema = z.object({
  packing_materials: CostSchema.optional(),
  moving_company: CostSchema.optional(),
  insurance: CostSchema.optional(),
  storage: CostSchema.optional(),
  total_cost: CostSchema,
  estimated_volume: z.string().optional(), // e.g., "2-bedroom apartment"
  distance_km: z.number().positive().optional(),
  delivery_time: z.number().positive().optional(), // in days
});

// Individual simulation result schema
export const SimulationResultSchema = z.object({
  days: z.number().int().positive(),
  flight_cost: FlightCostSchema,
  housing_cost: HousingCostSchema,
  furniture_moving_cost: MovingCostSchema,
  total_cost: CostSchema,
  season: z.enum(["high", "shoulder", "low"]),
  availability: z.enum(["limited", "moderate", "high"]),
  notes: z.string(),
  risk_factors: z.array(z.string()).optional(),
  recommendations: z.array(z.string()).optional(),
});

// LLM response schema
export const LLMResponseSchema = z.object({
  simulations: z.array(SimulationResultSchema).length(3), // Exactly 3 simulations for 30, 90, 180 days
  general_recommendations: z.array(z.string()).min(3).max(10),
  market_insights: z.object({
    current_trends: z.array(z.string()),
    seasonal_factors: z.array(z.string()),
    currency_considerations: z.array(z.string()),
  }),
  visa_requirements: z
    .object({
      required: z.boolean(),
      processing_time_days: z.number().int().positive().optional(),
      cost: CostSchema.optional(),
      documents_needed: z.array(z.string()).optional(),
    })
    .optional(),
  additional_costs: z
    .object({
      health_insurance: CostSchema.optional(),
      local_transportation: CostSchema.optional(),
      food_and_living: CostSchema.optional(),
      entertainment: CostSchema.optional(),
    })
    .optional(),
});

// Input validation schema
export const TravelInputSchema = z.object({
  departure_city: z
    .string()
    .min(2, "Departure city must be at least 2 characters"),
  departure_country: z
    .string()
    .min(2, "Departure country must be at least 2 characters"),
  arrival_city: z.string().min(2, "Arrival city must be at least 2 characters"),
  arrival_country: z
    .string()
    .min(2, "Arrival country must be at least 2 characters"),
  travel_dates: z
    .object({
      earliest_departure: z.string().datetime().optional(),
      latest_arrival: z.string().datetime().optional(),
      flexible_dates: z.boolean().default(true),
    })
    .optional(),
  budget_constraints: z
    .object({
      max_total_cost: CostSchema.optional(),
      preferred_currency: z.string().min(3).optional(),
      cost_priority: z
        .enum(["lowest", "balanced", "premium"])
        .default("balanced"),
    })
    .optional(),
  special_requirements: z
    .object({
      pets: z.boolean().default(false),
      children: z.boolean().default(false),
      elderly_accessibility: z.boolean().default(false),
      business_travel: z.boolean().default(false),
    })
    .optional(),
});

// Prompt template schema for consistent LLM prompting
export const PromptTemplateSchema = z.object({
  system_role: z.string(),
  user_prompt: z.string(),
  expected_format: z.string(),
  constraints: z.array(z.string()),
  examples: z.array(z.record(z.string(), z.string())).optional(),
});

// Export types
export type Cost = z.infer<typeof CostSchema>;
export type FlightCost = z.infer<typeof FlightCostSchema>;
export type HousingCost = z.infer<typeof HousingCostSchema>;
export type MovingCost = z.infer<typeof MovingCostSchema>;
export type SimulationResult = z.infer<typeof SimulationResultSchema>;
export type LLMResponse = z.infer<typeof LLMResponseSchema>;
export type TravelInput = z.infer<typeof TravelInputSchema>;
export type PromptTemplate = z.infer<typeof PromptTemplateSchema>;

// Predefined prompt templates
export const PROMPT_TEMPLATES = {
  travel_planning: {
    system_role: `You are a global mobility expert specializing in international relocation cost analysis. You have extensive knowledge of:
- Flight pricing and airline industry trends
- Global real estate markets and rental costs
- International moving and logistics
- Visa requirements and immigration processes
- Currency exchange and financial planning
- Cultural and practical relocation considerations

You provide accurate, detailed cost estimates and actionable recommendations based on current market conditions.`,

    user_prompt: `Analyze the relocation costs for moving from {departure_city}, {departure_country} to {arrival_city}, {arrival_country}.

Provide detailed cost simulations for three time periods:
1. 30 days from today (high season, limited availability)
2. 90 days from today (shoulder season, moderate availability)  
3. 180 days from today (low season, high availability)

For each time period, provide:
- Flight costs (base fare, taxes, fees, total)
- Housing costs (rent, deposit, utilities, total monthly)
- Moving costs (packing, moving company, insurance, storage, total)
- Total cost breakdown
- Season classification and availability assessment
- Risk factors and specific recommendations

Also provide:
- General relocation recommendations
- Current market insights and trends
- Seasonal factors affecting costs
- Currency considerations
- Visa requirements if applicable
- Additional living costs (health insurance, transportation, food, entertainment)

Format your response as structured JSON matching the expected schema.`,

    expected_format: `Respond with valid JSON matching this structure:
{
  "simulations": [
    {
      "days": 30,
      "flight_cost": { "base_fare": {...}, "total_cost": {...} },
      "housing_cost": { "monthly_rent": {...}, "total_monthly_cost": {...} },
      "furniture_moving_cost": { "moving_company": {...}, "total_cost": {...} },
      "total_cost": {...},
      "season": "high",
      "availability": "limited",
      "notes": "...",
      "risk_factors": ["..."],
      "recommendations": ["..."]
    }
  ],
  "general_recommendations": ["..."],
  "market_insights": { "current_trends": ["..."], "seasonal_factors": ["..."], "currency_considerations": ["..."] },
  "visa_requirements": {...},
  "additional_costs": {...}
}`,

    constraints: [
      "All monetary values must be positive numbers",
      "Use realistic, market-based cost estimates",
      "Consider seasonal variations and market conditions",
      "Provide specific, actionable recommendations",
      "Include risk factors and mitigation strategies",
      "Consider currency exchange rate fluctuations",
      "Factor in local market conditions and regulations",
    ],
  },
} as const;

// Validation helper functions
export function validateLLMResponse(response: unknown): LLMResponse {
  return LLMResponseSchema.parse(response);
}

export function validateTravelInput(input: unknown): TravelInput {
  return TravelInputSchema.parse(input);
}

export function createStructuredPrompt(input: TravelInput): string {
  const template = PROMPT_TEMPLATES.travel_planning;

  return template.user_prompt
    .replace("{departure_city}", input.departure_city)
    .replace("{departure_country}", input.departure_country)
    .replace("{arrival_city}", input.arrival_city)
    .replace("{arrival_country}", input.arrival_country);
}

export function createSystemPrompt(): string {
  return PROMPT_TEMPLATES.travel_planning.system_role;
}

export function createFormatInstructions(): string {
  const template = PROMPT_TEMPLATES.travel_planning;
  return `Expected Format:\n${
    template.expected_format
  }\n\nConstraints:\n${template.constraints.map((c) => `- ${c}`).join("\n")}`;
}

// Tool-specific schemas for convex/tools/

// City Search Tool Schemas
export const CitySearchInputSchema = z.object({
  originCity: z.string().min(2, "Origin city must be at least 2 characters"),
  originCountry: z
    .string()
    .min(2, "Origin country must be at least 2 characters"),
  destinationCity: z
    .string()
    .min(2, "Destination city must be at least 2 characters"),
  destinationCountry: z
    .string()
    .min(2, "Destination country must be at least 2 characters"),
});

export const VisaOptionSchema = z.object({
  type: z.enum(["cheapest", "fastest", "convenient", "premium"]),
  visa: z.string(),
  cost: z.string(),
  timeline: z.string(),
  description: z.string(),
  details: z.object({
    visa_cost: z.string(),
    flight: z.string(),
    housing: z.string(),
    moving: z.string(),
  }),
});

export const CitySearchOutputSchema = z.object({
  cheapest: VisaOptionSchema,
  fastest: VisaOptionSchema,
  convenient: VisaOptionSchema,
  premium: VisaOptionSchema,
});

export const EmailConfirmationInputSchema = z.object({
  email: z.string().email("Invalid email format"),
  name: z.string().min(1, "Name is required"),
  searchData: z.string(),
  originCity: z.string(),
  originCountry: z.string(),
  destinationCity: z.string(),
  destinationCountry: z.string(),
  storageId: z.optional(z.any()), // Using any for Convex ID compatibility
});

// Cost Estimation Tool Schemas
export const CostEstimationInputSchema = z.object({
  destinationCity: z
    .string()
    .min(2, "Destination city must be at least 2 characters"),
  includeFlight: z.boolean(),
  includeHousing: z.boolean(),
  includeMoving: z.boolean(),
  familySize: z
    .number()
    .int()
    .positive("Family size must be a positive integer"),
});

export const BaseCostsSchema = z.object({
  flight: z.object({
    economy: z.number().positive(),
    premium: z.number().positive(),
    business: z.number().positive(),
  }),
  housing: z.object({
    shared: z.number().positive(),
    one_bed: z.number().positive(),
    two_bed: z.number().positive(),
    family: z.number().positive(),
  }),
  moving: z.object({
    minimal: z.number().positive(),
    standard: z.number().positive(),
    full: z.number().positive(),
    premium: z.number().positive(),
  }),
  setup: z.object({
    utilities: z.number().positive(),
    deposits: z.number().positive(),
    initial_groceries: z.number().positive(),
    transport_setup: z.number().positive(),
    phone_internet: z.number().positive(),
  }),
});

export const CostBreakdownSchema = z.object({
  totalMin: z.number().positive(),
  totalMax: z.number().positive(),
  breakdown: z.array(z.string()),
  contingency: z.number().positive(),
});

// PDF Sender Tool Schemas
export const ConsultationDataSchema = z.object({
  name: z.string(),
  originCity: z.string(),
  originCountry: z.string(),
  destinationCity: z.string(),
  destinationCountry: z.string(),
  visaOptions: z.string(),
  timestamp: z.string().datetime(),
});

export const PDFSenderInputSchema = z.object({
  email: z.string().email("Invalid email format"),
  consultationData: ConsultationDataSchema,
  storageId: z.optional(z.string()),
});

export const PDFSenderOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  emailId: z.string().optional(),
});

// Email Capture Tool Schemas
export const EmailCaptureInputSchema = z.object({
  email: z.string().email("Invalid email format"),
  phone: z.optional(z.string()),
  name: z.string().min(1, "Name is required"),
});

export const EmailCaptureOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
});

// Update User Report Tool Schemas
export const UpdateUserReportInputSchema = z.object({
  email: z.string().email("Invalid email format"),
});

// Document Details Tool Schemas
export const DocumentDetailsInputSchema = z.object({
  documentType: z.string().min(1, "Document type is required"),
  country: z.string().min(2, "Country must be at least 2 characters"),
});

export const DocumentGuideSchema = z.object({
  purpose: z.string(),
  where: z.optional(z.string()),
  process: z.optional(z.array(z.string())),
  requirements: z.optional(z.array(z.string())),
  must_include: z.optional(z.array(z.string())),
  minimum_amounts: z.optional(z.record(z.string(), z.string())),
  validity: z.optional(z.string()),
  cost: z.optional(z.string()),
  tests_included: z.optional(z.array(z.string())),
  additional: z.optional(z.string()),
  authentication: z.optional(z.string()),
  tips: z.string(),
});

// Visa Requirements Tool Schemas
export const VisaRequirementsInputSchema = z.object({
  originCountry: z
    .string()
    .min(2, "Origin country must be at least 2 characters"),
  destinationCountry: z
    .string()
    .min(2, "Destination country must be at least 2 characters"),
  visaType: z.optional(z.string()),
});

export const VisaOptionDetailsSchema = z.object({
  age: z.optional(z.string()),
  duration: z.string(),
  work: z.optional(z.string()),
  cost: z.string(),
  processing: z.string(),
  requirement: z.optional(z.string()),
  path_to_residency: z.optional(z.string()),
  investment: z.optional(z.string()),
});

export const VisaRequirementsSchema = z.object({
  documents: z.array(z.string()),
  process: z.array(z.string()),
  timeline: z.string(),
  costs: z.object({
    application: z.string(),
    health_surcharge: z.string(),
    biometric: z.string(),
    priority_service: z.string(),
  }),
});

// Prompt Structure Schemas for LLM Instructions
export const VisaAnalysisRequirementsSchema = z.object({
  visaTypes: z
    .array(z.string())
    .describe("Different visa types available (tourist, work, student, etc.)"),
  costs: z.array(z.string()).describe("Costs for each visa type"),
  processingTimes: z.array(z.string()).describe("Processing times"),
  keyRequirements: z.array(z.string()).describe("Key requirements"),
});

export const RelocationOptionsStructureSchema = z.object({
  cheapest: z.object({
    label: z.string().describe("Cheapest option (budget-conscious)"),
    description: z.string(),
  }),
  fastest: z.object({
    label: z.string().describe("Fastest option (urgent relocation)"),
    description: z.string(),
  }),
  convenient: z.object({
    label: z.string().describe("Most convenient (balanced approach)"),
    description: z.string(),
  }),
  premium: z.object({
    label: z.string().describe("Premium option (comprehensive service)"),
    description: z.string(),
  }),
});

export const CostAnalysisRequirementsSchema = z.object({
  marketRates: z
    .string()
    .describe("Current market rates for the destination city"),
  familySizeImpact: z.string().describe("Family size impact on costs"),
  seasonalVariations: z.string().describe("Seasonal variations"),
  hiddenCosts: z.string().describe("Hidden costs often overlooked"),
  currencyConversions: z
    .string()
    .describe("Currency conversions if applicable"),
});

export const CostEstimationOutputSchema = z.object({
  totalCostRange: z.string().describe("Total cost range (min-max)"),
  detailedBreakdown: z.string().describe("Detailed breakdown by category"),
  moneySavingTips: z
    .string()
    .describe("Money-saving tips specific to this destination"),
  hiddenCosts: z.string().describe("Hidden costs to watch for"),
  bestTiming: z.string().describe("Best timing for relocation to save money"),
});

export const LLMPromptSchema = z.object({
  systemRole: z.string().describe("System role description for the AI model"),
  userPrompt: z.string().describe("User prompt content"),
  expectedFormat: z.string().describe("Expected response format"),
  constraints: z.array(z.string()).describe("Constraints for the response"),
});

export const CitySearchPromptSchema = z.object({
  systemRole: z.object({
    role: z.string().describe("AI role description"),
    citizenshipCheck: z
      .string()
      .describe("Citizenship verification instruction"),
    analysisInstructions: z
      .string()
      .describe("Instructions for analyzing search results"),
    outputFormat: z.string().describe("Expected output format"),
  }),
  userPrompt: z.object({
    context: z.string().describe("Context about the search results"),
    request: z.string().describe("What the user is requesting"),
    structureInstructions: z.string().describe("How to structure the response"),
    outputRequirements: z.string().describe("What to include in the output"),
  }),
});

// Export tool-specific types
export type CitySearchInput = z.infer<typeof CitySearchInputSchema>;
export type CitySearchOutput = z.infer<typeof CitySearchOutputSchema>;
export type VisaOption = z.infer<typeof VisaOptionSchema>;
export type EmailConfirmationInput = z.infer<
  typeof EmailConfirmationInputSchema
>;
export type CostEstimationInput = z.infer<typeof CostEstimationInputSchema>;
export type BaseCosts = z.infer<typeof BaseCostsSchema>;
export type CostBreakdown = z.infer<typeof CostBreakdownSchema>;
export type ConsultationData = z.infer<typeof ConsultationDataSchema>;
export type PDFSenderInput = z.infer<typeof PDFSenderInputSchema>;
export type PDFSenderOutput = z.infer<typeof PDFSenderOutputSchema>;
export type EmailCaptureInput = z.infer<typeof EmailCaptureInputSchema>;
export type EmailCaptureOutput = z.infer<typeof EmailCaptureOutputSchema>;
export type UpdateUserReportInput = z.infer<typeof UpdateUserReportInputSchema>;
export type DocumentDetailsInput = z.infer<typeof DocumentDetailsInputSchema>;
export type DocumentGuide = z.infer<typeof DocumentGuideSchema>;
export type VisaRequirementsInput = z.infer<typeof VisaRequirementsInputSchema>;
export type VisaOptionDetails = z.infer<typeof VisaOptionDetailsSchema>;
export type VisaRequirements = z.infer<typeof VisaRequirementsSchema>;
export type VisaAnalysisRequirements = z.infer<
  typeof VisaAnalysisRequirementsSchema
>;
export type RelocationOptionsStructure = z.infer<
  typeof RelocationOptionsStructureSchema
>;
export type CostAnalysisRequirements = z.infer<
  typeof CostAnalysisRequirementsSchema
>;
export type CostEstimationOutput = z.infer<typeof CostEstimationOutputSchema>;
export type LLMPrompt = z.infer<typeof LLMPromptSchema>;
export type CitySearchPrompt = z.infer<typeof CitySearchPromptSchema>;
</file>

<file path="convex/tools/citySearch.ts">
import { v } from "convex/values";
import { internalMutation, internalAction } from "../_generated/server";
import { internal } from "../_generated/api";
import Exa from "exa-js";
import { OpenAI } from "openai";
import {
  CitySearchInputSchema,
  CitySearchOutputSchema,
  EmailConfirmationInputSchema,
  VisaOptionSchema,
  VisaAnalysisRequirementsSchema,
  RelocationOptionsStructureSchema,
  type CitySearchInput,
  type CitySearchOutput,
  type EmailConfirmationInput,
  type VisaAnalysisRequirements,
  type RelocationOptionsStructure,
} from "../schemas/zod_schemas";

export const searchRelocationOptions = internalMutation({
  args: {
    originCity: v.string(),
    originCountry: v.string(),
    destinationCity: v.string(),
    destinationCountry: v.string(),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: CitySearchInput = CitySearchInputSchema.parse(args);

    const { originCity, originCountry, destinationCity, destinationCountry } =
      validatedInput;

    // Check if we have cached results
    const cacheKey = `${originCountry}-${destinationCountry}-${originCity}-${destinationCity}`;
    const existing = await ctx.db
      .query("cities")
      .filter((q) =>
        q.and(
          q.eq(q.field("departure_country"), originCountry),
          q.eq(q.field("arrival_country"), destinationCountry),
          q.eq(q.field("departure_city"), originCity),
          q.eq(q.field("arrival_city"), destinationCity)
        )
      )
      .first();

    if (
      existing &&
      existing._creationTime > Date.now() - 24 * 60 * 60 * 1000 &&
      existing.results
    ) {
      return existing.results;
    }

    // Call the Exa search action
    const searchResults: string = await ctx.scheduler.runAfter(
      0,
      internal.tools.citySearch.searchWithExa,
      {
        originCity,
        originCountry,
        destinationCity,
        destinationCountry,
      }
    );

    // Store in database
    if (existing) {
      await ctx.db.patch(existing._id, {
        results: searchResults,
        _creationTime: Date.now(),
      });
    } else {
      await ctx.db.insert("cities", {
        departure_country: originCountry,
        arrival_country: destinationCountry,
        departure_city: originCity,
        arrival_city: destinationCity,
        results: searchResults,
      });
    }

    return searchResults;
  },
});

export const searchWithExa = internalAction({
  args: {
    originCity: v.string(),
    originCountry: v.string(),
    destinationCity: v.string(),
    destinationCountry: v.string(),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: CitySearchInput = CitySearchInputSchema.parse(args);

    const { originCity, originCountry, destinationCity, destinationCountry } =
      validatedInput;

    const exaApiKey = process.env.EXA_API_KEY;
    const openaiApiKey = process.env.OPENAI_API_KEY;

    if (!exaApiKey || !openaiApiKey) {
      throw new Error("Missing API keys");
    }

    // Initialize Exa client with OpenAI wrapper
    const exa = new Exa(exaApiKey);
    const openai = new OpenAI({ apiKey: openaiApiKey });

    // Use Exa and OpenAI separately since wrap is not available

    try {
      // Search for visa requirements and costs
      const visaQuery = `visa requirements costs ${originCountry} to ${destinationCountry} 2024 2025 immigration work permit student visa tourist visa processing time fees`;

      const visaSearch = await exa.searchAndContents(visaQuery, {
        numResults: 10,
        text: true,
        startPublishedDate: "2023-01-01",
      });

      // Create structured prompt data using Zod schemas
      const visaAnalysisRequirements: VisaAnalysisRequirements = {
        visaTypes: [
          "Different visa types available (tourist, work, student, etc.)",
        ],
        costs: ["Costs for each visa type"],
        processingTimes: ["Processing times"],
        keyRequirements: ["Key requirements"],
      };

      const relocationOptionsStructure: RelocationOptionsStructure = {
        cheapest: {
          label: "1. Cheapest option (budget-conscious)",
          description: "Most affordable approach for initial entry",
        },
        fastest: {
          label: "2. Fastest option (urgent relocation)",
          description: "Expedited processing throughout",
        },
        convenient: {
          label: "3. Most convenient (balanced approach)",
          description: "Good balance of cost and convenience",
        },
        premium: {
          label: "4. Premium option (comprehensive service)",
          description: "Complete white-glove service",
        },
      };

      // Validate the structured data with Zod schemas
      VisaAnalysisRequirementsSchema.parse(visaAnalysisRequirements);
      RelocationOptionsStructureSchema.parse(relocationOptionsStructure);

      // Use OpenAI to analyze the results
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: `You are a relocation expert analyzing visa options from ${originCountry} to ${destinationCountry}. You must confirm with user if their citizenship is from ${originCountry} - if not, please double check with them and ask them what's their citizenship.
            Based on the search results, extract and organize information about:
            ${visaAnalysisRequirements.visaTypes[0]}
            ${visaAnalysisRequirements.costs[0]}
            ${visaAnalysisRequirements.processingTimes[0]}
            ${visaAnalysisRequirements.keyRequirements[0]}
            Format the response as a structured JSON with options categorized by budget and timeline.`,
          },
          {
            role: "user",
            content: `Based on these search results about visas from ${originCountry} to ${destinationCountry}, provide 4 relocation options:
            
            Search Results:
            ${visaSearch.results.map((r) => `${r.title}\n${r.text}`).join("\n\n")}
            
            Please structure as:
            ${relocationOptionsStructure.cheapest.label}
            ${relocationOptionsStructure.fastest.label}
            ${relocationOptionsStructure.convenient.label}
            ${relocationOptionsStructure.premium.label}
            
            Include visa type, estimated costs, timeline, and key details for each.`,
          },
        ],
        temperature: 0.7,
      });

      const analysisText = completion.choices[0].message.content || "";

      // Parse the response and structure it
      let results;
      try {
        // Try to parse as JSON if the model returned structured data
        const parsedResults = JSON.parse(analysisText);
        // Validate the parsed results with Zod schema
        results = CitySearchOutputSchema.parse(parsedResults);
      } catch {
        // Fall back to text parsing if not JSON - create validated fallback data
        const fallbackResults = {
          cheapest: {
            type: "cheapest" as const,
            visa: "Tourist/Visitor Visa",
            cost: "£500 - £2,000",
            timeline: "2-4 weeks",
            description:
              "Most affordable option for initial entry, may require visa conversion later",
            details: {
              visa_cost: "£200-500",
              flight: "Budget airline: £300-600",
              housing: "Hostel/shared: £400-600/month",
              moving: "Minimal belongings: £200-500",
            },
          },
          fastest: {
            type: "fastest" as const,
            visa: "Express Business/Priority Visa",
            cost: "£10,000 - £15,000",
            timeline: "5-10 business days",
            description: "Expedited processing with premium services",
            details: {
              visa_cost: "£2,000-3,000 (expedited)",
              flight: "Flexible ticket: £2,000-3,000",
              housing: "Serviced apartment: £2,000/month",
              moving: "Express shipping: £2,000-3,000",
            },
          },
          convenient: {
            type: "convenient" as const,
            visa: "Work Visa with Sponsorship",
            cost: "£5,000 - £8,000",
            timeline: "4-8 weeks",
            description: "Balanced approach with employer support",
            details: {
              visa_cost: "£800-1,500",
              flight: "Economy flexible: £800-1,200",
              housing: "Corporate housing: £1,200-1,800/month",
              moving: "Standard service: £1,500-2,500",
            },
          },
          premium: {
            type: "premium" as const,
            visa: "Investment/Entrepreneur Visa",
            cost: "£20,000+",
            timeline: "3-6 weeks",
            description:
              "Comprehensive relocation with investment opportunities",
            details: {
              visa_cost: "£3,000-5,000",
              flight: "Business/First: £3,000-5,000",
              housing: "Luxury apartment: £3,000-5,000/month",
              moving: "White-glove service: £5,000-10,000",
            },
          },
        };

        // Validate the fallback results with Zod schema
        results = CitySearchOutputSchema.parse(fallbackResults);
      }

      // Format the response with email prompt
      const formattedResponse = `I've analyzed current visa options and costs for relocating from ${originCity}, ${originCountry} to ${destinationCity}, ${destinationCountry}.

Here are your four main relocation approaches:

**1. Budget Option** (${results.cheapest.cost})
   • Visa: ${results.cheapest.visa}
   • Timeline: ${results.cheapest.timeline}
   • ${results.cheapest.description}

**2. Express Option** (${results.fastest.cost})
   • Visa: ${results.fastest.visa}
   • Timeline: ${results.fastest.timeline}
   • ${results.fastest.description}

**3. Balanced Option** (${results.convenient.cost})
   • Visa: ${results.convenient.visa}
   • Timeline: ${results.convenient.timeline}
   • ${results.convenient.description}

**4. Premium Option** (${results.premium.cost})
   • Visa: ${results.premium.visa}
   • Timeline: ${results.premium.timeline}
   • ${results.premium.description}

Would you like me to:
📧 **Send you a detailed PDF report** with complete visa requirements, documentation checklists, and step-by-step guides to your email?
💬 **Discuss specific options** in more detail right now?

Just let me know your preference!`;

      return formattedResponse;
    } catch (error) {
      console.error("Exa search error:", error);

      // Fallback to structured mock data if Exa fails - validate with Zod
      const fallbackData = {
        cheapest: {
          type: "cheapest" as const,
          visa: "Working Holiday/Tourist Visa",
          cost: "£3,500 - £5,000",
          timeline: "2-3 months",
          description: "Most affordable with basic visa and budget travel",
          details: {
            visa_cost: "£295",
            flight: "Budget airline: £800-1,200",
            housing: "Shared accommodation: £600-800/month",
            moving: "Minimal belongings: £500-800",
          },
        },
        fastest: {
          type: "fastest" as const,
          visa: "Priority Business Visa",
          cost: "£15,000 - £20,000",
          timeline: "2-3 weeks",
          description: "Expedited processing throughout",
          details: {
            visa_cost: "£1,235 + £500 priority",
            flight: "Flexible business: £3,000-5,000",
            housing: "Serviced apartment: £2,500/month",
            moving: "Express service: £3,000-5,000",
          },
        },
        convenient: {
          type: "convenient" as const,
          visa: "Skilled Worker Visa",
          cost: "£8,000 - £12,000",
          timeline: "6-8 weeks",
          description: "Good balance of cost and convenience",
          details: {
            visa_cost: "£1,235",
            flight: "Economy flexible: £1,200-1,800",
            housing: "Corporate housing: £1,500-2,000/month",
            moving: "Standard service: £2,000-3,000",
          },
        },
        premium: {
          type: "premium" as const,
          visa: "Investor/Entrepreneur Visa",
          cost: "£25,000+",
          timeline: "4-6 weeks",
          description: "Complete white-glove service",
          details: {
            visa_cost: "£3,250",
            flight: "Business/First: £4,000-6,000",
            housing: "Luxury apartment: £4,000-6,000/month",
            moving: "Premium service: £8,000-12,000",
          },
        },
      };

      // Validate fallback data with Zod schema
      const results = CitySearchOutputSchema.parse(fallbackData);

      return `I've analyzed relocation options from ${originCity}, ${originCountry} to ${destinationCity}, ${destinationCountry}.

Here are your four main approaches:

**1. Budget Option** (${results.cheapest.cost})
   • Visa: ${results.cheapest.visa}
   • Timeline: ${results.cheapest.timeline}
   • ${results.cheapest.description}

**2. Express Option** (${results.fastest.cost})
   • Visa: ${results.fastest.visa}
   • Timeline: ${results.fastest.timeline}
   • ${results.fastest.description}

**3. Balanced Option** (${results.convenient.cost})
   • Visa: ${results.convenient.visa}
   • Timeline: ${results.convenient.timeline}
   • ${results.convenient.description}

**4. Premium Option** (${results.premium.cost})
   • Visa: ${results.premium.visa}
   • Timeline: ${results.premium.timeline}
   • ${results.premium.description}

Would you like me to:
📧 **Send you a detailed PDF report** with complete visa requirements to your email?
💬 **Discuss specific options** in more detail right now?

Just let me know your preference!`;
    }
  },
});

export const confirmEmailSend = internalMutation({
  args: {
    email: v.string(),
    name: v.string(),
    searchData: v.string(),
    originCity: v.string(),
    originCountry: v.string(),
    destinationCity: v.string(),
    destinationCountry: v.string(),
    storageId: v.optional(v.id("_storage")),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: EmailConfirmationInput =
      EmailConfirmationInputSchema.parse(args);

    const {
      email,
      name,
      searchData,
      originCity,
      originCountry,
      destinationCity,
      destinationCountry,
      storageId,
    } = validatedInput;

    // Store user info
    const existingUser = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("email"), email))
      .first();

    let userId;
    if (existingUser) {
      await ctx.db.patch(existingUser._id, {
        name: name || existingUser.name,
        lastContactedAt: Date.now(),
      });
      userId = existingUser._id;
    } else {
      userId = await ctx.db.insert("users", {
        email,
        name,
        createdAt: Date.now(),
        lastContactedAt: Date.now(),
      });
    }

    // Trigger email send
    await ctx.scheduler.runAfter(0, internal.tools.pdfSender.sendEmailReport, {
      email,
      consultationData: {
        name,
        originCity,
        originCountry,
        destinationCity,
        destinationCountry,
        visaOptions: searchData,
        timestamp: new Date().toISOString(),
      },
    });

    return `Perfect! I'm preparing your comprehensive relocation report and sending it to ${email}. You should receive it within the next few minutes.

The report will include:
• Detailed visa requirements for each option
• Complete documentation checklists
• Step-by-step application guides
• Cost breakdowns and timelines
• Helpful resources and official links

Is there anything specific you'd like me to explain further while the report is being prepared?`;
  },
});
</file>

<file path="convex/tools/costEstimation.ts">
import { v } from "convex/values";
import { internalMutation, internalAction } from "../_generated/server";
import { internal } from "../_generated/api";
import { OpenAI } from "openai";
import Exa from "exa-js";
import {
  CostEstimationInputSchema,
  BaseCostsSchema,
  CostAnalysisRequirementsSchema,
  CostEstimationOutputSchema,
  type CostEstimationInput,
  type BaseCosts,
  type CostAnalysisRequirements,
  type CostEstimationOutput,
} from "../schemas/zod_schemas";

export const estimateRelocationCosts = internalMutation({
  args: {
    destinationCity: v.string(),
    includeFlight: v.boolean(),
    includeHousing: v.boolean(),
    includeMoving: v.boolean(),
    familySize: v.number(),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: CostEstimationInput =
      CostEstimationInputSchema.parse(args);

    const {
      destinationCity,
      includeFlight,
      includeHousing,
      includeMoving,
      familySize,
    } = validatedInput;

    // Call the OpenAI action for intelligent cost estimation
    const costAnalysis: string = await ctx.scheduler.runAfter(
      0,
      internal.tools.costEstimation.analyzeWithOpenAI,
      {
        destinationCity,
        includeFlight,
        includeHousing,
        includeMoving,
        familySize,
      }
    );

    return costAnalysis;
  },
});

export const analyzeWithOpenAI = internalAction({
  args: {
    destinationCity: v.string(),
    includeFlight: v.boolean(),
    includeHousing: v.boolean(),
    includeMoving: v.boolean(),
    familySize: v.number(),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: CostEstimationInput =
      CostEstimationInputSchema.parse(args);

    const {
      destinationCity,
      includeFlight,
      includeHousing,
      includeMoving,
      familySize,
    } = validatedInput;

    const openaiApiKey = process.env.OPENAI_API_KEY;
    const exaApiKey = process.env.EXA_API_KEY;

    if (!openaiApiKey) {
      throw new Error("Missing OpenAI API key");
    }

    const openai = new OpenAI({ apiKey: openaiApiKey });

    // Gather real-time data if Exa is available
    let searchResults = "";
    if (exaApiKey) {
      try {
        const exa = new Exa(exaApiKey);
        const costQuery = `${destinationCity} cost of living 2024 2025 apartment rent prices flight costs moving expenses utilities groceries`;

        const search = await exa.searchAndContents(costQuery, {
          numResults: 5,
          text: true,
          startPublishedDate: "2023-01-01",
        });

        searchResults = search.results
          .map((r) => `${r.title}: ${r.text?.substring(0, 500)}`)
          .join("\n\n");
      } catch (error) {
        console.error("Exa search error:", error);
      }
    }

    // Base cost data structure for fallback - validate with Zod
    const baseCosts: BaseCosts = BaseCostsSchema.parse({
      flight: {
        economy: 600 * familySize,
        premium: 1500 * familySize,
        business: 3500 * familySize,
      },
      housing: {
        shared: 800,
        one_bed: 1500,
        two_bed: 2200,
        family: 3500,
      },
      moving: {
        minimal: 500,
        standard: 2500,
        full: 5000,
        premium: 8000,
      },
      setup: {
        utilities: 300,
        deposits: 2500,
        initial_groceries: 500,
        transport_setup: 200,
        phone_internet: 150,
      },
    });

    try {
      // Create structured prompt data using Zod schemas
      const costAnalysisRequirements: CostAnalysisRequirements = {
        marketRates: "1. Current market rates for the destination city",
        familySizeImpact: "2. Family size impact on costs",
        seasonalVariations: "3. Seasonal variations",
        hiddenCosts: "4. Hidden costs often overlooked",
        currencyConversions: "5. Currency conversions if applicable",
      };

      const costEstimationOutput: CostEstimationOutput = {
        totalCostRange: "1. Total cost range (min-max)",
        detailedBreakdown: "2. Detailed breakdown by category",
        moneySavingTips: "3. Money-saving tips specific to this destination",
        hiddenCosts: "4. Hidden costs to watch for",
        bestTiming: "5. Best timing for relocation to save money",
      };

      // Validate the structured data with Zod schemas
      CostAnalysisRequirementsSchema.parse(costAnalysisRequirements);
      CostEstimationOutputSchema.parse(costEstimationOutput);

      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "system",
            content: `You are a relocation cost expert. Analyze the provided data and estimate relocation costs.
            Consider:
            ${costAnalysisRequirements.marketRates}
            ${costAnalysisRequirements.familySizeImpact}
            ${costAnalysisRequirements.seasonalVariations}
            ${costAnalysisRequirements.hiddenCosts}
            ${costAnalysisRequirements.currencyConversions}
            
            Base your estimates on real data when available, otherwise use these baseline costs as reference:
            ${JSON.stringify(baseCosts, null, 2)}
            
            Provide practical, actionable cost breakdowns with ranges.`,
          },
          {
            role: "user",
            content: `Estimate relocation costs to ${destinationCity} for ${familySize} ${familySize === 1 ? "person" : "people"}.
            
            Include costs for:
            - Flights: ${includeFlight ? "Yes" : "No"}
            - Housing: ${includeHousing ? "Yes" : "No"}
            - Moving services: ${includeMoving ? "Yes" : "No"}
            
            ${searchResults ? `Recent market data for ${destinationCity}:\n${searchResults}` : "Use standard estimates for this city."}
            
            Provide:
            ${costEstimationOutput.totalCostRange}
            ${costEstimationOutput.detailedBreakdown}
            ${costEstimationOutput.moneySavingTips}
            ${costEstimationOutput.hiddenCosts}
            ${costEstimationOutput.bestTiming}
            
            Format as a clear, structured response with emojis for categories.`,
          },
        ],
        temperature: 0.7,
        max_tokens: 1500,
      });

      const analysis = completion.choices[0].message.content || "";

      // Parse and structure the response
      if (analysis) {
        return analysis;
      }
    } catch (error) {
      console.error("OpenAI analysis error:", error);
    }

    // Fallback to calculated estimates if OpenAI fails
    let totalMin = 0;
    let totalMax = 0;
    let breakdown = [];

    if (includeFlight) {
      totalMin += baseCosts.flight.economy;
      totalMax += baseCosts.flight.business;
      breakdown.push(
        `✈️ Flights: £${baseCosts.flight.economy} - £${baseCosts.flight.business}`
      );
    }

    if (includeHousing) {
      const housingCost =
        familySize === 1
          ? baseCosts.housing.one_bed
          : familySize === 2
            ? baseCosts.housing.two_bed
            : baseCosts.housing.family;
      totalMin += housingCost;
      totalMax += housingCost * 1.5;
      breakdown.push(
        `🏠 First month housing: £${housingCost} - £${Math.round(housingCost * 1.5)}`
      );

      totalMin += baseCosts.setup.deposits;
      totalMax += baseCosts.setup.deposits * 1.5;
      breakdown.push(`💰 Security deposits: £${baseCosts.setup.deposits}`);
    }

    if (includeMoving) {
      totalMin += baseCosts.moving.minimal;
      totalMax += baseCosts.moving.premium;
      breakdown.push(
        `📦 Moving services: £${baseCosts.moving.minimal} - £${baseCosts.moving.premium}`
      );
    }

    // Always include setup costs
    const setupTotal = Object.values(baseCosts.setup).reduce(
      (a, b) => a + b,
      0
    );
    totalMin += setupTotal;
    totalMax += setupTotal;
    breakdown.push(
      `🔧 Setup costs (utilities, groceries, etc.): £${setupTotal}`
    );

    // Add 10% contingency
    const contingency = Math.round(totalMin * 0.1);
    totalMin += contingency;
    totalMax += Math.round(totalMax * 0.1);
    breakdown.push(`📊 10% contingency fund: £${contingency}+`);

    return `Estimated relocation costs to ${destinationCity} for ${familySize} ${familySize === 1 ? "person" : "people"}:

**Total Range: £${totalMin.toLocaleString()} - £${totalMax.toLocaleString()}**

**Breakdown:**
${breakdown.join("\n")}

**Money-saving tips:**
• Book flights 2-3 months in advance
• Consider temporary accommodation initially
• Ship only essential items
• Research tax treaties to avoid double taxation

Would you like me to provide more details on any specific cost category?`;
  },
});
</file>

<file path="convex/tools/documentDetails.ts">
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";
import {
  DocumentDetailsInputSchema,
  DocumentGuideSchema,
  type DocumentDetailsInput,
  type DocumentGuide,
} from "../schemas/zod_schemas";

export const getDocumentDetails = internalMutation({
  args: {
    documentType: v.string(),
    country: v.string(),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: DocumentDetailsInput =
      DocumentDetailsInputSchema.parse(args);

    const { documentType, country } = validatedInput;

    const documentGuides: Record<string, DocumentGuide> = {
      "police clearance": {
        purpose: "Proves you have no criminal record",
        where: "Local police department or national agency",
        process: [
          "Apply online or in person at designated office",
          "Provide identification and address history",
          "Submit fingerprints (if required)",
          "Pay processing fee (usually £45-95)",
          "Wait 2-4 weeks for processing",
        ],
        validity: "Usually 6 months from issue date",
        tips: "Apply 2-3 months before visa application as it can take time",
      },
      "bank statement": {
        purpose: "Demonstrates financial stability",
        requirements: [
          "Last 6 months of statements",
          "Show minimum balance requirements",
          "Must be stamped by bank or certified",
          "Include all accounts if using multiple",
        ],
        minimum_amounts: {
          student: "£1,334/month for 9 months",
          skilled_worker: "£1,270 minimum",
          investor: "£2 million available funds",
        },
        tips: "Maintain consistent balance for 28+ days before application",
      },
      "employment letter": {
        purpose: "Confirms job offer or current employment",
        must_include: [
          "Company letterhead",
          "Job title and description",
          "Salary details",
          "Start date",
          "Sponsor license number (if applicable)",
          "Signed by authorized person",
        ],
        additional: "May need Certificate of Sponsorship (CoS) for UK",
        tips: "Ensure letter is dated within 30 days of application",
      },
      "medical examination": {
        purpose: "Health screening for visa",
        tests_included: [
          "Chest X-ray (TB screening)",
          "Blood tests",
          "Physical examination",
          "Vaccination records review",
        ],
        where: "Approved panel physicians only",
        cost: "£150-500 depending on tests",
        validity: "6 months typically",
        tips: "Book appointment early as slots fill quickly",
      },
      "academic transcripts": {
        purpose: "Verify educational qualifications",
        requirements: [
          "Official sealed transcripts",
          "Degree certificates",
          "English translations if needed",
          "NARIC/ENIC assessment for equivalency",
        ],
        authentication: "May need apostille or attestation",
        tips: "Order extra copies as originals may be retained",
      },
    };

    const doc: DocumentGuide = documentGuides[documentType.toLowerCase()] || {
      purpose: "Supporting document for visa application",
      requirements: ["Contact embassy for specific requirements"],
      tips: "Ensure all documents are current and properly certified",
    };

    let response = `**${documentType.toUpperCase()} for ${country}**\n\n`;
    response += `**Purpose:** ${doc.purpose}\n\n`;

    if (doc.where) {
      response += `**Where to obtain:** ${doc.where}\n\n`;
    }

    if (doc.process) {
      response += `**Process:**\n${doc.process.map((step: string, i: number) => `${i + 1}. ${step}`).join("\n")}\n\n`;
    }

    if (doc.requirements) {
      response += `**Requirements:**\n- ${doc.requirements.join("\n- ")}\n\n`;
    }

    if (doc.must_include) {
      response += `**Must include:**\n- ${doc.must_include.join("\n- ")}\n\n`;
    }

    if (doc.minimum_amounts) {
      response += `**Minimum amounts by visa type:**\n`;
      for (const [visa, amount] of Object.entries(doc.minimum_amounts)) {
        response += `- ${visa}: ${amount}\n`;
      }
      response += "\n";
    }

    if (doc.validity) {
      response += `**Validity:** ${doc.validity}\n\n`;
    }

    if (doc.cost) {
      response += `**Cost:** ${doc.cost}\n\n`;
    }

    response += `**💡 Pro tip:** ${doc.tips}`;

    return response;
  },
});
</file>

<file path="convex/tools/emailCapture.ts">
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";
import {
  EmailCaptureInputSchema,
  EmailCaptureOutputSchema,
  type EmailCaptureInput,
  type EmailCaptureOutput,
} from "../schemas/zod_schemas";

export const captureContactInfo = internalMutation({
  args: {
    email: v.string(),
    phone: v.optional(v.string()),
    name: v.string(),
  },
  handler: async (ctx, args): Promise<EmailCaptureOutput> => {
    // Validate input using Zod schema
    const validatedInput: EmailCaptureInput =
      EmailCaptureInputSchema.parse(args);

    const { email, phone, name } = validatedInput;

    // Check if user already exists
    const existingUser = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("email"), email))
      .first();

    if (existingUser) {
      // Update existing user
      await ctx.db.patch(existingUser._id, {
        phone: phone || existingUser.phone,
        name: name || existingUser.name,
        lastContactedAt: Date.now(),
      });
    } else {
      // Create new user
      await ctx.db.insert("users", {
        email,
        phone,
        name,
        createdAt: Date.now(),
        lastContactedAt: Date.now(),
      });
    }

    return {
      success: true,
      message: "Contact information saved successfully",
    };
  },
});
</file>

<file path="convex/tools/pdfSender.ts">
import { v } from "convex/values";
import { internalAction } from "../_generated/server";
import { internal } from "../_generated/api";
import { Resend } from "resend";
import { render } from '@react-email/render';
import { RelocationReport } from '../emails/RelocationReport';
import {
  PDFSenderInputSchema,
  PDFSenderOutputSchema,
  type PDFSenderInput,
  type PDFSenderOutput,
} from "../schemas/zod_schemas";

export const sendEmailReport = internalAction({
  args: {
    email: v.string(),
    consultationData: v.any(),
  },
  handler: async (ctx, args): Promise<PDFSenderOutput> => {
    // Validate input using Zod schema
    const validatedInput: PDFSenderInput = PDFSenderInputSchema.parse(args);

    const { email, consultationData } = validatedInput;

    try {
      const resendApiKey = process.env.RESEND_API_KEY;
      if (!resendApiKey) {
        throw new Error("Missing Resend API key");
      }

      const resend = new Resend(resendApiKey);

      // Create formatted email content using React Email
      const emailHtml = await render(
        RelocationReport({
          name: consultationData.name || 'Valued Client',
          email,
          originCity: consultationData.originCity,
          originCountry: consultationData.originCountry,
          destinationCity: consultationData.destinationCity,
          destinationCountry: consultationData.destinationCountry,
          visaOptions: consultationData.visaOptions,
        })
      );


      // Send email
      const { data, error } = await resend.emails.send({
        from: "Gullie Travel Planner <onboarding@resend.dev>",
        to: email,
        subject: `Your Relocation Report: ${consultationData.originCity} to ${consultationData.destinationCity}`,
        html: emailHtml,
      });

      if (error) {
        throw error;
      }

      // Update user record
      await ctx.runMutation(
        internal.tools.updateUserReport.updateUserReportStatus,
        {
          email,
        }
      );

      console.log("Email sent successfully:", data);
      return {
        success: true,
        message: "Report sent successfully",
        emailId: data?.id,
      };
    } catch (error) {
      console.error("Error sending email report:", error);
      throw new Error("Failed to send email report");
    }
  },
});
</file>

<file path="convex/tools/updateUserReport.ts">
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";
import {
  UpdateUserReportInputSchema,
  type UpdateUserReportInput,
} from "../schemas/zod_schemas";

export const updateUserReportStatus = internalMutation({
  args: {
    email: v.string(),
  },
  handler: async (ctx, args): Promise<void> => {
    // Validate input using Zod schema
    const validatedInput: UpdateUserReportInput =
      UpdateUserReportInputSchema.parse(args);

    const { email } = validatedInput;

    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("email"), email))
      .first();

    if (user) {
      await ctx.db.patch(user._id, {
        lastReportSentAt: Date.now(),
      });
    }
  },
});
</file>

<file path="convex/tools/visaRequirements.ts">
import { v } from "convex/values";
import { internalMutation, internalAction } from "../_generated/server";
import { internal } from "../_generated/api";
import Exa from "exa-js";
import { openai } from "@ai-sdk/openai";
import { generateObject } from "ai";
import {
  VisaRequirementsInputSchema,
  VisaRequirementsSchema,
  type VisaRequirementsInput,
  type VisaOptionDetails,
  type VisaRequirements,
} from "../schemas/zod_schemas";
import { z } from "zod";

const EXA_API_KEY = process.env.EXA_API_KEY;

// Schema for structured visa search response
const VisaSearchResponseSchema = z.object({
  visaOptions: z.record(
    z.string(),
    z.object({
      age: z.string(),
      duration: z.string(),
      work: z.string(),
      cost: z.string(),
      processing: z.string(),
      requirement: z.string().optional(),
      path_to_residency: z.string().optional(),
      investment: z.string().optional(),
    })
  ),
  summary: z.string(),
});

// Schema for detailed visa requirements
const DetailedVisaRequirementsSchema = z.object({
  documents: z.array(z.string()),
  process: z.array(z.string()),
  timeline: z.string(),
  costs: z.object({
    application: z.string(),
    health_surcharge: z.string(),
    biometric: z.string(),
    priority_service: z.string(),
  }),
  additional_info: z.string().optional(),
});

// Store visa search results in conversation context
export const storeVisaSearchResult = internalMutation({
  args: {
    callId: v.string(),
    originCountry: v.string(),
    destinationCountry: v.string(),
    visaType: v.optional(v.string()),
    result: v.string(),
    timestamp: v.number(),
  },
  handler: async (ctx, args) => {
    // Get existing conversation
    const conversation = await ctx.db
      .query("conversations")
      .withIndex("by_call_id", (q) => q.eq("callId", args.callId))
      .first();

    if (conversation) {
      // Add visa search result as a tool message
      const toolMessage = {
        role: "tool" as const,
        content: args.result,
        timestamp: args.timestamp,
        toolCall: {
          name: "visaRequirements",
          arguments: {
            originCountry: args.originCountry,
            destinationCountry: args.destinationCountry,
            visaType: args.visaType,
          },
          result: args.result,
        },
      };

      const updatedTranscript = [...conversation.transcript, toolMessage];
      
      // Update conversation with visa data
      await ctx.db.patch(conversation._id, {
        transcript: updatedTranscript,
        extractedData: {
          ...conversation.extractedData,
          originCountry: args.originCountry,
          destinationCountry: args.destinationCountry,
          visaOptions: args.result,
        },
      });

      // Record the tool call
      await ctx.runMutation(internal.conversations.recordToolCall, {
        callId: args.callId,
        toolCall: {
          name: "visaRequirements",
          timestamp: args.timestamp,
          success: true,
        },
      });
    }
  },
});

// GPT-4o fallback for visa search
async function searchVisaWithGPT(
  originCountry: string,
  destinationCountry: string,
  visaType?: string
): Promise<string> {
  try {
    if (!visaType) {
      // Search for available visa types
      const { object } = await generateObject({
        model: openai("gpt-4o"),
        system: `You are a visa and immigration expert. Provide accurate, up-to-date visa information for ${originCountry} citizens moving to ${destinationCountry}. Include multiple visa options with their requirements, costs, and processing times.`,
        prompt: `List all available visa options for ${originCountry} citizens moving to ${destinationCountry} in 2024-2025. For each visa type, provide:
        - Age requirements (if any)
        - Duration of stay allowed
        - Work rights
        - Approximate cost in local currency
        - Processing time
        - Key requirements
        - Path to residency (if applicable)
        
        Focus on the most common and accessible visa types.`,
        schema: VisaSearchResponseSchema,
      });

      if (Object.keys(object.visaOptions).length > 0) {
        return `As a ${originCountry} citizen moving to ${destinationCountry}, here are your visa options:

${Object.entries(object.visaOptions)
  .map(
    ([type, details]) =>
      `**${type} Visa**:\n` +
      Object.entries(details)
        .filter(([_, value]) => value)
        .map(([key, value]) => `  - ${key.replace(/_/g, " ")}: ${value}`)
        .join("\n")
  )
  .join("\n\n")}

${object.summary}

Would you like me to explain more details about a specific visa type or send you the requirements as a PDF?`;
      }
    } else {
      // Get detailed requirements for specific visa type
      const { object } = await generateObject({
        model: openai("gpt-4o"),
        system: `You are a visa and immigration expert. Provide detailed, accurate requirements for the ${visaType} visa from ${originCountry} to ${destinationCountry}.`,
        prompt: `Provide complete requirements for the ${visaType} visa from ${originCountry} to ${destinationCountry}. Include:
        1. Required documents (be specific)
        2. Step-by-step application process
        3. Processing timeline
        4. Cost breakdown (application fee, health surcharge, biometric, priority service if available)
        5. Additional important information`,
        schema: DetailedVisaRequirementsSchema,
      });

      return `For the ${visaType} visa from ${originCountry} to ${destinationCountry}:

**Required Documents:**
- ${object.documents.join("\n- ")}

**Application Process:**
${object.process.map((step, i) => `${i + 1}. ${step}`).join("\n")}

**Timeline:** ${object.timeline}

**Costs Breakdown:**
- Application fee: ${object.costs.application}
- Health surcharge: ${object.costs.health_surcharge}
- Biometric fee: ${object.costs.biometric}
- Priority service: ${object.costs.priority_service}

${object.additional_info || ""}

*Note: Please verify with the official immigration website for the most up-to-date requirements.*

Would you like me to explain any specific requirement in more detail or send this information as a PDF?`;
    }

    return `I found visa information for moving from ${originCountry} to ${destinationCountry}. Please specify which type of visa you're interested in for more detailed requirements.`;
  } catch (error) {
    console.error("Error with GPT-4o visa search:", error);
    throw error;
  }
}

// Main visa requirements action with automatic triggering
export const getVisaRequirements = internalAction({
  args: {
    callId: v.string(),
    originCountry: v.string(),
    destinationCountry: v.string(),
    visaType: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<string> => {
    // Validate input using Zod schema
    const validatedInput: VisaRequirementsInput = VisaRequirementsInputSchema.parse({
      originCountry: args.originCountry,
      destinationCountry: args.destinationCountry,
      visaType: args.visaType,
    });

    const { originCountry, destinationCountry, visaType } = validatedInput;
    const timestamp = Date.now();

    try {
      // Try Exa search first
      const exa = new Exa(EXA_API_KEY);
      let result: string;

      if (!visaType) {
        // Search for available visa types for the route
        const searchQuery = `comprehensive visa options for ${originCountry} citizens moving to ${destinationCountry} 2024 2025 official government immigration:`;

        const searchResults = await exa.searchAndContents(searchQuery, {
          numResults: 5,
          text: { maxCharacters: 2000 },
          useAutoprompt: true,
        });

        // Parse the search results to extract visa options
        const visaOptions: Record<string, VisaOptionDetails> = {};
        const extractedOptions = new Set<string>();

        for (const searchResult of searchResults.results) {
          const content = searchResult.text || "";

          // Extract visa types mentioned in content
          const visaTypePatterns = [
            /(?:Working Holiday|Youth Mobility|Work and Holiday)\s*(?:Visa|Scheme)?/gi,
            /(?:Skilled Worker|Skilled Migration|Skilled Employment)\s*(?:Visa)?/gi,
            /(?:Student|Study)\s*(?:Visa)?/gi,
            /(?:Investor|Business Innovation|Entrepreneur)\s*(?:Visa)?/gi,
            /(?:Family|Partner|Spouse)\s*(?:Visa)?/gi,
            /(?:Tourist|Visitor|Tourism)\s*(?:Visa)?/gi,
          ];

          for (const pattern of visaTypePatterns) {
            const matches = content.match(pattern);
            if (matches) {
              matches.forEach((match) => {
                const normalizedType = match
                  .replace(/\s*(Visa|Scheme)?\s*$/i, "")
                  .trim();
                extractedOptions.add(normalizedType);
              });
            }
          }
        }

        // Search for specific details about each visa type found
        for (const visaTypeName of Array.from(extractedOptions).slice(0, 4)) {
          const detailQuery = `${visaTypeName} visa ${originCountry} to ${destinationCountry} requirements cost processing time eligibility 2024 2025:`;

          const detailResults = await exa.searchAndContents(detailQuery, {
            numResults: 2,
            text: { maxCharacters: 1500 },
            useAutoprompt: true,
          });

          // Extract details from search results
          let ageReq = "Check eligibility";
          let duration = "Varies";
          let workRights = "Check conditions";
          let cost = "Check official fees";
          let processingTime = "Check current times";

          for (const detailResult of detailResults.results) {
            const text = detailResult.text || "";

            // Extract age requirements
            const ageMatch = text.match(
              /(?:age|aged?)\s*(?:between|from|:)?\s*(\d+)[\s-]+(?:to|and)?\s*(\d+)/i
            );
            if (ageMatch) {
              ageReq = `${ageMatch[1]}-${ageMatch[2]} years`;
            }

            // Extract duration
            const durationMatch = text.match(
              /(?:valid for|duration|period of|up to)\s*(\d+)\s*(year|month|week|day)s?/i
            );
            if (durationMatch) {
              duration = `Up to ${durationMatch[1]} ${durationMatch[2]}${parseInt(durationMatch[1]) > 1 ? "s" : ""}`;
            }

            // Extract cost
            const costMatch = text.match(
              /(?:fee|cost|price)[\s:]*(?:£|\$|€|AUD|CAD|USD|GBP)?\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/i
            );
            if (costMatch) {
              cost = costMatch[0].replace(/fee|cost|price|:/gi, "").trim();
            }

            // Extract processing time
            const processMatch = text.match(
              /(?:processing time|takes?|process in)\s*(?:up to|approximately|about)?\s*(\d+)\s*(week|month|day)s?/i
            );
            if (processMatch) {
              processingTime = `${processMatch[1]} ${processMatch[2]}${parseInt(processMatch[1]) > 1 ? "s" : ""}`;
            }

            // Extract work rights
            if (/(?:can|allowed to|permitted to)\s*work/i.test(text)) {
              workRights = "Work permitted";
            } else if (
              /(?:cannot|not allowed to|prohibited from)\s*work/i.test(text)
            ) {
              workRights = "No work rights";
            } else if (/(?:limited|restricted)\s*work/i.test(text)) {
              const hoursMatch = text.match(
                /(\d+)\s*hours?\s*(?:per|\/)\s*week/i
              );
              if (hoursMatch) {
                workRights = `${hoursMatch[1]} hours/week`;
              } else {
                workRights = "Limited work rights";
              }
            }
          }

          visaOptions[visaTypeName] = {
            age: ageReq,
            duration: duration,
            work: workRights,
            cost: cost,
            processing: processingTime,
            requirement: visaTypeName.includes("Student")
              ? "University acceptance"
              : visaTypeName.includes("Skilled")
                ? "Job offer required"
                : visaTypeName.includes("Investor")
                  ? "Investment required"
                  : "Check eligibility",
          };
        }

        if (Object.keys(visaOptions).length > 0) {
          result = `As a ${originCountry} citizen moving to ${destinationCountry}, here are your visa options based on current official information:

${Object.entries(visaOptions)
  .map(
    ([type, details]) =>
      `**${type} Visa**:\n` +
      Object.entries(details)
        .map(([key, value]) => `  - ${key.replace(/_/g, " ")}: ${value}`)
        .join("\n")
  )
  .join("\n\n")}

These are the main visa options available. Would you like me to explain more details about a specific visa type or send you the requirements as a PDF?`;
        } else {
          // Fallback to GPT-4o if Exa doesn't return results
          result = await searchVisaWithGPT(originCountry, destinationCountry, visaType);
        }
      } else {
        // Search for detailed requirements for specific visa type
        const detailedQuery = `${visaType} visa ${originCountry} to ${destinationCountry} complete requirements documents checklist application process timeline fees 2024 2025 official:`;

        const searchResults = await exa.searchAndContents(detailedQuery, {
          numResults: 5,
          text: { maxCharacters: 3000 },
          useAutoprompt: true,
        });

        // Extract and parse requirements from search results
        const documents = new Set<string>();
        const processSteps = new Set<string>();
        let timeline = "Check official processing times";
        const costs: any = {};

        for (const searchResult of searchResults.results) {
          const content = searchResult.text || "";

          // Extract documents
          const docPatterns = [
            /passport/gi,
            /bank statement/gi,
            /police (?:clearance|certificate|check)/gi,
            /medical (?:exam|examination|certificate|check)/gi,
            /biometric/gi,
            /employment (?:letter|document|contract)/gi,
            /accommodation (?:proof|evidence|booking)/gi,
            /(?:proof|evidence) of funds/gi,
            /qualification|degree|transcript/gi,
            /english (?:language|proficiency) (?:test|certificate)/gi,
            /sponsor (?:letter|document)/gi,
            /insurance/gi,
          ];

          for (const pattern of docPatterns) {
            const matches = content.match(pattern);
            if (matches) {
              matches.forEach((match) => documents.add(match));
            }
          }

          // Extract process steps
          const stepPatterns = content.match(
            /(?:\d+[.\)]\s*)([^.!?\n]+(?:application|submit|pay|attend|complete|gather|book|wait|receive)[^.!?\n]+)/gi
          );
          if (stepPatterns) {
            stepPatterns.forEach((step) => {
              const cleanStep = step.replace(/^\d+[.\)]\s*/, "").trim();
              if (cleanStep.length > 10 && cleanStep.length < 100) {
                processSteps.add(cleanStep);
              }
            });
          }

          // Extract timeline
          const timelineMatch = content.match(
            /(?:processing time|takes?|process(?:ed)? (?:in|within))\s*(?:up to|approximately|about)?\s*(\d+)\s*(week|month|day)s?/i
          );
          if (timelineMatch) {
            timeline = `${timelineMatch[1]} ${timelineMatch[2]}${parseInt(timelineMatch[1]) > 1 ? "s" : ""} typically`;
          }

          // Extract costs
          const costPatterns = [
            {
              key: "application",
              pattern:
                /(?:application|visa) fee[\s:]*(?:£|\$|€|AUD|CAD|USD|GBP)?\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/i,
            },
            {
              key: "health_surcharge",
              pattern:
                /health (?:surcharge|levy)[\s:]*(?:£|\$|€|AUD|CAD|USD|GBP)?\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/i,
            },
            {
              key: "biometric",
              pattern:
                /biometric fee[\s:]*(?:£|\$|€|AUD|CAD|USD|GBP)?\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/i,
            },
            {
              key: "priority_service",
              pattern:
                /priority (?:service|processing)[\s:]*(?:£|\$|€|AUD|CAD|USD|GBP)?\s*(\d+(?:,\d{3})*(?:\.\d{2})?)/i,
            },
          ];

          for (const { key, pattern } of costPatterns) {
            const match = content.match(pattern);
            if (match) {
              costs[key] = match[0]
                .replace(
                  /.*fee|.*surcharge|.*levy|.*service|.*processing|:/gi,
                  ""
                )
                .trim();
            }
          }
        }

        // Build the requirements object
        const requirements: VisaRequirements = VisaRequirementsSchema.parse({
          documents:
            Array.from(documents).length > 0
              ? Array.from(documents)
                  .slice(0, 10)
                  .map(
                    (doc) =>
                      doc.charAt(0).toUpperCase() + doc.slice(1).toLowerCase()
                  )
              : [
                  "Valid passport (6+ months validity)",
                  "Proof of funds",
                  "Application form",
                  "Supporting documents as per visa type",
                ],
          process:
            Array.from(processSteps).length > 0
              ? Array.from(processSteps)
                  .slice(0, 7)
                  .map(
                    (step, index) =>
                      `${index + 1}. ${step.charAt(0).toUpperCase() + step.slice(1)}`
                  )
              : [
                  "1. Check eligibility requirements",
                  "2. Gather required documents",
                  "3. Complete online application",
                  "4. Pay visa fees",
                  "5. Schedule appointment (if required)",
                  "6. Submit biometrics",
                  "7. Wait for decision",
                ],
          timeline: timeline,
          costs: {
            application: costs.application || "Check official website",
            health_surcharge: costs.health_surcharge || "If applicable",
            biometric: costs.biometric || "If required",
            priority_service:
              costs.priority_service || "Optional - faster processing",
          },
        });

        result = `For the ${visaType} visa from ${originCountry} to ${destinationCountry}:

**Required Documents:**
- ${requirements.documents.join("\n- ")}

**Application Process:**
${requirements.process.join("\n")}

**Timeline:** ${requirements.timeline}

**Costs Breakdown:**
- Application fee: ${requirements.costs.application}
- Health surcharge: ${requirements.costs.health_surcharge}
- Biometric fee: ${requirements.costs.biometric}
- Priority service: ${requirements.costs.priority_service}

*Note: This information is based on current official sources. Please verify with the official immigration website for the most up-to-date requirements.*

Would you like me to explain any specific requirement in more detail or send this information as a PDF?`;
      }

      // Store the result in conversation context
      await ctx.runMutation(internal.tools.visaRequirements.storeVisaSearchResult, {
        callId: args.callId,
        originCountry,
        destinationCountry,
        visaType,
        result,
        timestamp,
      });

      return result;
    } catch (error) {
      console.error("Error fetching visa requirements from Exa:", error);
      
      // Fallback to GPT-4o
      try {
        const result = await searchVisaWithGPT(originCountry, destinationCountry, visaType);
        
        // Store the result in conversation context
        await ctx.runMutation(internal.tools.visaRequirements.storeVisaSearchResult, {
          callId: args.callId,
          originCountry,
          destinationCountry,
          visaType,
          result,
          timestamp,
        });

        return result;
      } catch (gptError) {
        console.error("Error with GPT-4o fallback:", gptError);
        return `I encountered an issue while searching for visa information from ${originCountry} to ${destinationCountry}. Please try again later or consult the official immigration website.`;
      }
    }
  },
});

// Check if visa search should be triggered
export const shouldTriggerVisaSearch = internalAction({
  args: {
    callId: v.string(),
  },
  handler: async (ctx, args): Promise<string | null> => {
    // Get conversation context
    const conversation = await ctx.runQuery(internal.conversations.getConversationByCallId, {
      callId: args.callId,
    });

    if (!conversation || !conversation.extractedData) {
      return null;
    }

    const { originCountry, destinationCountry } = conversation.extractedData;

    // Check if we have both countries and haven't searched yet
    if (originCountry && destinationCountry) {
      // Check if we already have visa options stored
      const hasVisaOptions = conversation.extractedData.visaOptions;
      
      if (!hasVisaOptions) {
        // Trigger visa search automatically
        const result = await ctx.runAction(internal.tools.visaRequirements.getVisaRequirements, {
          callId: args.callId,
          originCountry,
          destinationCountry,
        });
        
        return result;
      }
    }

    return null;
  },
});
</file>

<file path="convex/city.ts">
import { v } from "convex/values";
import { action, mutation } from "./_generated/server";
import { internal } from "./_generated/api";
import { xai } from "@ai-sdk/xai";
import { generateText } from "ai";

// Types for our simulation results
interface SimulationResult {
  days: number;
  flight_cost: number;
  housing_cost: number;
  furniture_moving_cost: number;
  currency: string;
  notes: string;
}

interface LLMResponse {
  simulations: SimulationResult[];
  recommendations: string[];
}

interface SearchResult {
  success: boolean;
  cityId: string;
  dateIds: string[];
  simulations: any[];
  recommendations: string[];
}

// Helper mutations
export const _createCityRecord = mutation({
  args: {
    departure_city: v.string(),
    departure_country: v.optional(v.string()),
    arrival_city: v.string(),
    arrival_country: v.optional(v.string()),
    user: v.id("users"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("cities", {
      user: args.user,
      departure_city: args.departure_city,
      departure_country: args.departure_country,
      arrival_city: args.arrival_city,
      arrival_country: args.arrival_country,
    });
  },
});

export const _createDateRecord = mutation({
  args: {
    user: v.id("users"),
    city: v.id("cities"),
    departure_date: v.string(),
    arrival_date: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("dates", {
      user: args.user,
      city: args.city,
      departure_date: args.departure_date,
      arrival_date: args.arrival_date,
    });
  },
});

export const _createFlightRecord = mutation({
  args: {
    flight_cost: v.number(),
    currency: v.string(),
    user: v.id("users"),
    date: v.id("dates"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("flights", {
      flight_cost: args.flight_cost,
      currency: args.currency,
      user: args.user,
      date: args.date,
    });
  },
});

export const _createRentalRecord = mutation({
  args: {
    rental_cost: v.string(),
    user: v.id("users"),
    city: v.id("cities"),
    area: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("rentals", {
      rental_cost: args.rental_cost,
      user: args.user,
      city: args.city,
      area: args.area,
    });
  },
});

export const searchCosts = action({
  args: {
    user: v.id("users"),
    departure_city: v.string(),
    arrival_city: v.string(),
    departure_country: v.optional(v.string()),
    arrival_country: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<SearchResult> => {
    // Step 1: Tokenize and validate input
    const tokenizedInput = await tokenizeInput(args);

    // Step 2: Create city record
    const cityId: string = await ctx.runMutation((internal as any).city._createCityRecord, {
      departure_city: args.departure_city,
      departure_country: args.departure_country,
      arrival_city: args.arrival_city,
      arrival_country: args.arrival_country,
      user: args.user,
    });

    // Step 3: Create date records for 30, 90, and 180 days
    const dateIds: string[] = await Promise.all([
      createDateRecord(ctx, args.user, cityId, 30),
      createDateRecord(ctx, args.user, cityId, 90),
      createDateRecord(ctx, args.user, cityId, 180),
    ]);

    // Step 4: Call LLM for simulations
    const llmResponse = await callExaToSearch(tokenizedInput);

    // Step 5: Store simulation results (mock for now)
    const mockLlmResponse: LLMResponse = {
      simulations: [
        { days: 30, flight_cost: 500, housing_cost: 1000, furniture_moving_cost: 300, currency: 'USD', notes: 'Mock 30-day simulation' },
        { days: 90, flight_cost: 600, housing_cost: 2500, furniture_moving_cost: 800, currency: 'USD', notes: 'Mock 90-day simulation' },
        { days: 180, flight_cost: 700, housing_cost: 5000, furniture_moving_cost: 1200, currency: 'USD', notes: 'Mock 180-day simulation' }
      ],
      recommendations: ['Consider booking in advance', 'Look for furnished options', 'Compare multiple moving companies']
    };
    
    const results = await storeSimulationResults(
      ctx,
      args.user,
      cityId,
      dateIds,
      mockLlmResponse
    );

    return {
      success: true,
      cityId,
      dateIds,
      simulations: results,
      recommendations: mockLlmResponse.recommendations,
    };
  },
});

// Tokenize input for LLM processing
async function tokenizeInput(args: {
  departure_city: string;
  arrival_city: string;
  departure_country?: string;
  arrival_country?: string;
}) {
  // Normalize and clean input
  const normalized = {
    departure: {
      city: args.departure_city.trim().toLowerCase(),
      country: args.departure_country?.trim().toLowerCase() || "unknown",
    },
    arrival: {
      city: args.arrival_city.trim().toLowerCase(),
      country: args.arrival_country?.trim().toLowerCase() || "unknown",
    },
  };

  // Validate city names (basic validation)
  if (!normalized.departure.city || !normalized.arrival.city) {
    throw new Error("City names are required");
  }

  // Create structured prompt for LLM
  const tokenizedPrompt = {
    route: `${normalized.departure.city}, ${normalized.departure.country} → ${normalized.arrival.city}, ${normalized.arrival.country}`,
    departure: normalized.departure,
    arrival: normalized.arrival,
    simulation_periods: [30, 90, 180],
    categories: ["flight", "housing", "furniture_moving"],
  };

  return tokenizedPrompt;
}

// Create date record for a specific number of days from now
async function createDateRecord(
  ctx: any,
  userId: string,
  cityId: string,
  daysFromNow: number
): Promise<string> {
  const targetDate = new Date();
  targetDate.setDate(targetDate.getDate() + daysFromNow);

  const departureDate = new Date();
  departureDate.setDate(departureDate.getDate() + daysFromNow);

  const arrivalDate = new Date();
  arrivalDate.setDate(arrivalDate.getDate() + daysFromNow + 1); // Assume 1 day travel

  return await ctx.runMutation((internal as any).city._createDateRecord, {
    user: userId,
    city: cityId,
    departure_date: departureDate.toISOString().split("T")[0],
    arrival_date: arrivalDate.toISOString().split("T")[0],
  });
}

// Call LLM for simulations
async function callExaToSearch(tokenizedInput: any) {
  // Promise<LLMResponse>
  // This would be your actual LLM API call
  // For now, returning mock data structure
  const prompt = `As a global mobility expert, provide cost simulations for the following route: ${tokenizedInput.route}

Please provide detailed cost estimates for:
1. Flight tickets
2. Housing costs (rental/mortgage)
3. Furniture moving costs

For each time period: 30 days, 90 days, and 180 days from today.

Consider factors like:
- Seasonal pricing variations
- Distance and route complexity
- Local market conditions
- Currency exchange rates
- Moving company availability

Format your response as structured data with specific cost estimates and recommendations. There should be a list of JSON objects, each with the following fields:
- days: number
- flight_cost: number
- housing_cost: number
- furniture_moving_cost: number
- currency: string
- notes: string

There are four types of options should be considered, the cheapest, the most expensive, the most flexible, and the most expensive and flexible.`;
}

// Store simulation results in the database
async function storeSimulationResults(
  ctx: any,
  userId: string,
  cityId: string,
  dateIds: string[],
  llmResponse: LLMResponse
): Promise<any[]> {
  const results = [];

  for (let i = 0; i < dateIds.length; i++) {
    const dateId = dateIds[i];
    const simulation = llmResponse.simulations[i];

    // Store flight information
    const flightId = await ctx.runMutation((internal as any).city._createFlightRecord, {
      flight_cost: simulation.flight_cost,
      currency: simulation.currency,
      user: userId,
      date: dateId,
    });

    // Store rental/housing information
    const rentalId = await ctx.runMutation((internal as any).city._createRentalRecord, {
      rental_cost: simulation.housing_cost.toString(),
      user: userId,
      city: cityId, // Fixed: reference the city, not date
    });

    results.push({
      dateId,
      flightId,
      rentalId,
      simulation,
    });
  }

  return results;
}

async function search_visa_based_on_country(
  ctx: any,
  departure_country: string,
  arrival_country: string
) {
  const prompt = `As a global mobility expert, if i am a citizen of ${departure_country} and i want to move to ${arrival_country}, what are the visa requirements?`;

  const response = await generateText({
    model: xai("gemini-2.0-flash-001"),
    prompt,
  });

  return response.text;
}
</file>

<file path="convex/http.ts">
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { api, internal } from "./_generated/api";

const http = httpRouter();

// CORS headers - disabled for Vapi as requested
const corsHeaders = {};

// Helper function to format tool response
const formatToolResponse = (toolCallId: string, result: any) => ({
  results: [
    {
      toolCallId,
      result: typeof result === "string" ? result : JSON.stringify(result),
    },
  ],
});

// City Search Tool
http.route({
  path: "/tools/search_relocation_options",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let toolCallId = "error";
    
    try {
      const body = await request.json() as any;
      const { message, call } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      const { origin_city, origin_country, destination_city, destination_country } = args;

      // Track conversation and tool call
      if (call?.id) {
        await ctx.runAction(internal.tools.conversationTracker.trackConversation, {
          callId: call.id,
          sessionId: call.sessionId,
          message: {
            type: "tool-calls",
            toolCall: {
              name: "search_relocation_options",
              arguments: args,
            },
          },
          call,
        });
        
        // Extract and save data
        await ctx.runAction(internal.tools.conversationTracker.extractConversationData, {
          callId: call.id,
          extractedData: {
            originCity: origin_city,
            originCountry: origin_country,
            destinationCity: destination_city,
            destinationCountry: destination_country,
          },
        });
      }

      // Call internal mutation to search and store results
      const results = await ctx.runMutation(internal.tools.citySearch.searchRelocationOptions, {
        originCity: origin_city,
        originCountry: origin_country,
        destinationCity: destination_city,
        destinationCountry: destination_country,
      });

      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, results)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (error: any) {
      console.error("City search error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I'm having trouble searching for relocation options: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// Visa Requirements Tool
http.route({
  path: "/tools/get_visa_requirements",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let body: any;
    let toolCallId = "error";
    
    try {
      body = await request.json() as any;
      console.log("Visa requirements request:", JSON.stringify(body, null, 2));
      
      const { message } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      
      // Handle both `arguments` and `function.arguments` structures
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      
      console.log("Parsed arguments:", JSON.stringify(args, null, 2));
      
      if (!args.origin_country || !args.destination_country || !args.visa_type) {
        console.error("Missing parameters. Received args:", args);
        throw new Error("Missing required parameters: origin_country, destination_country, or visa_type");
      }
      
      const { origin_country, destination_country, visa_type } = args;

      const requirements = await ctx.runAction(internal.tools.visaRequirements.getVisaRequirements, {
        callId: "http-call-" + Date.now(), // Generate a unique call ID for HTTP requests
        originCountry: origin_country,
        destinationCountry: destination_country,
        visaType: visa_type,
      });

      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, requirements)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (error: any) {
      console.error("Visa requirements error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I couldn't retrieve visa requirements: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// Cost Estimation Tool
http.route({
  path: "/tools/estimate_relocation_costs",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let toolCallId = "error";
    
    try {
      const body = await request.json() as any;
      const { message } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      const { destination_city, include_flight, include_housing, include_moving, family_size } = args;

      const costs = await ctx.runMutation(internal.tools.costEstimation.estimateRelocationCosts, {
        destinationCity: destination_city,
        includeFlight: include_flight || true,
        includeHousing: include_housing || true,
        includeMoving: include_moving || true,
        familySize: family_size || 1,
      });

      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, costs)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (error: any) {
      console.error("Cost estimation error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I couldn't calculate costs: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// Document Requirements Tool
http.route({
  path: "/tools/get_document_details",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let toolCallId = "error";
    
    try {
      const body = await request.json() as any;
      const { message } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      const { document_type, country } = args;

      const details = await ctx.runMutation(internal.tools.documentDetails.getDocumentDetails, {
        documentType: document_type,
        country: country,
      });

      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, details)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (error: any) {
      console.error("Document details error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I couldn't retrieve document details: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// Email Capture Tool
http.route({
  path: "/tools/capture_contact_info",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let toolCallId = "error";
    
    try {
      const body = await request.json() as any;
      const { message } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      const { email, phone, name } = args;

      // Store contact info
      await ctx.runMutation(internal.tools.emailCapture.captureContactInfo, {
        email,
        phone,
        name,
      });

      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, "Thank you! I've saved your contact information.")),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (error: any) {
      console.error("Contact capture error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I couldn't save your contact information: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// Send PDF Tool
http.route({
  path: "/tools/send_pdf_report",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let toolCallId = "error";
    
    try {
      const body = await request.json() as any;
      console.log("PDF send request:", JSON.stringify(body, null, 2));
      
      const { message } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      
      console.log("PDF send arguments:", JSON.stringify(args, null, 2));
      
      if (!args.email) {
        throw new Error("Email is required to send PDF report");
      }
      
      const { email, consultation_data } = args;

      // Trigger PDF generation and email send
      await ctx.runAction(internal.tools.pdfSender.sendEmailReport, {
        email,
        consultationData: consultation_data || "",
      });

      return new Response(
        JSON.stringify(formatToolResponse(
          toolCallId, 
          "Perfect! I'm preparing your comprehensive relocation report and will send it to your email shortly. You should receive it within the next few minutes."
        )),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (error: any) {
      console.error("PDF send error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I couldn't send the PDF report: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// Visa Options Confirmation Tool - Enhanced for user choice
http.route({
  path: "/tools/confirm_visa_options",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    let toolCallId = "error";
    
    try {
      const body = await request.json() as any;
      const { message } = body || {};
      const { toolCallList } = message || {};
      
      if (!toolCallList || !toolCallList[0]) {
        throw new Error("No tool call found in request");
      }
      
      const toolCall = toolCallList[0];
      toolCallId = toolCall.id || "error";
      const args = toolCall.arguments || toolCall.function?.arguments || {};
      const { user_choice, email, name, search_data, origin_city, origin_country, destination_city, destination_country, storage_id } = args;

      if (user_choice === "email") {
        if (email && name) {
          // User provided email, send the report
          const result = await ctx.runMutation(internal.tools.citySearch.confirmEmailSend, {
            email,
            name,
            searchData: search_data || "",
            originCity: origin_city || "",
            originCountry: origin_country || "",
            destinationCity: destination_city || "",
            destinationCountry: destination_country || "",
            storageId: storage_id,
          });
          
          return new Response(
            JSON.stringify(formatToolResponse(toolCallId, result)),
            {
              status: 200,
              headers: { ...corsHeaders, "Content-Type": "application/json" },
            }
          );
        } else {
          // Ask for email
          return new Response(
            JSON.stringify(formatToolResponse(
              toolCallId,
              "Great! I'll send you a comprehensive PDF report with all the visa details. Please provide your email address and name so I can send it to you."
            )),
            {
              status: 200,
              headers: { ...corsHeaders, "Content-Type": "application/json" },
            }
          );
        }
      } else if (user_choice === "discuss") {
        return new Response(
          JSON.stringify(formatToolResponse(
            toolCallId,
            "Perfect! I'm here to discuss any of these visa options in detail. Which option interests you most, or do you have specific questions about requirements, timelines, or costs?"
          )),
          {
            status: 200,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
          }
        );
      } else {
        // Default response waiting for user choice
        return new Response(
          JSON.stringify(formatToolResponse(
            toolCallId,
            "Please let me know if you'd like me to send you a detailed PDF report to your email, or if you'd prefer to discuss the options right now."
          )),
          {
            status: 200,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
          }
        );
      }
    } catch (error: any) {
      console.error("Visa confirmation error:", error);
      return new Response(
        JSON.stringify(formatToolResponse(toolCallId, `I couldn't process your request: ${error.message}`)),
        {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  }),
});

// OPTIONS handler for CORS preflight
http.route({
  path: "/tools/search_relocation_options",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

http.route({
  path: "/tools/get_visa_requirements",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

http.route({
  path: "/tools/estimate_relocation_costs",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

http.route({
  path: "/tools/get_document_details",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

http.route({
  path: "/tools/capture_contact_info",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

http.route({
  path: "/tools/send_pdf_report",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

http.route({
  path: "/tools/confirm_visa_options",
  method: "OPTIONS",
  handler: httpAction(async () => {
    return new Response(null, {
      status: 204,
      headers: corsHeaders,
    });
  }),
});

// Vapi Webhook Handler
http.route({
  path: "/webhooks/vapi",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    try {
      const body = await request.json();
      
      // Log webhook event
      console.log("Vapi webhook received:", body.type);
      
      // Handle different webhook types
      switch (body.type) {
        case "call-started":
          console.log("Call started:", body.call.id);
          break;
        case "call-ended":
          console.log("Call ended:", body.call.id);
          // Could trigger post-call actions here
          break;
        case "transcript":
          console.log("Transcript:", body.transcript);
          break;
        default:
          console.log("Unknown webhook type:", body.type);
      }

      return new Response(JSON.stringify({ success: true }), {
        status: 200,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    } catch (error) {
      console.error("Webhook error:", error);
      return new Response(JSON.stringify({ error: "Webhook processing failed" }), {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }
  }),
});

// Polar Webhook Handler
http.route({
  path: "/webhook",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    try {
      const body = await request.text();
      const headers = request.headers;
      
      // TODO: Add webhook signature validation once POLAR_WEBHOOK_SECRET is set
      // For now, we'll process the webhook without validation
      
      const event = JSON.parse(body);
      console.log("Polar webhook received:", event.type);
      
      // Handle different Polar webhook events
      switch (event.type) {
        case "subscription.created":
        case "subscription.updated":
          await ctx.runMutation(internal.subscriptions.upsertSubscription, {
            polarId: event.data.id,
            userId: event.data.customer_id,
            productId: event.data.product_id,
            status: event.data.status,
            currentPeriodStart: event.data.current_period_start,
            currentPeriodEnd: event.data.current_period_end,
            cancelAtPeriodEnd: event.data.cancel_at_period_end || false,
            metadata: event.data,
          });
          break;
          
        case "subscription.canceled":
          await ctx.runMutation(internal.subscriptions.cancelSubscription, {
            polarId: event.data.id,
          });
          break;
          
        case "checkout.created":
          console.log("Checkout created:", event.data.id);
          break;
          
        case "checkout.updated":
          if (event.data.status === "succeeded") {
            await ctx.runMutation(internal.subscriptions.recordCheckout, {
              checkoutId: event.data.id,
              customerId: event.data.customer_id,
              productId: event.data.product_id,
              amount: event.data.amount,
              currency: event.data.currency,
              metadata: event.data,
            });
          }
          break;
          
        default:
          console.log("Unhandled Polar webhook type:", event.type);
      }
      
      return new Response(null, { status: 202 });
    } catch (error) {
      console.error("Polar webhook error:", error);
      return new Response(JSON.stringify({ error: "Webhook processing failed" }), {
        status: 500,
        headers: { "Content-Type": "application/json" },
      });
    }
  }),
});

// Vapi Conversation Webhook - for tracking conversation updates
http.route({
  path: "/vapi/conversation-webhook",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    try {
      const body = await request.json() as any;
      const { message, call } = body || {};
      
      console.log("Vapi conversation webhook:", message?.type);
      
      if (call?.id) {
        // Track all conversation events
        await ctx.runAction(internal.tools.conversationTracker.trackConversation, {
          callId: call.id,
          sessionId: call.sessionId,
          message: {
            type: message.type || "unknown",
            role: message.role,
            content: message.content || message.transcript,
            transcript: message.transcript,
            timestamp: message.timestamp || Date.now(),
          },
          call,
        });
      }
      
      return new Response(null, { status: 200 });
    } catch (error) {
      console.error("Vapi conversation webhook error:", error);
      return new Response(null, { status: 200 });
    }
  }),
});

// Get conversation context endpoint for Vapi
http.route({
  path: "/vapi/get-context",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    try {
      const body = await request.json() as any;
      const { sessionId, callId, limit } = body;
      
      const context = await ctx.runAction(internal.tools.conversationTracker.getConversationContext, {
        sessionId,
        callId,
        limit: limit || 5,
      });
      
      return new Response(JSON.stringify(context), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    } catch (error) {
      console.error("Get context error:", error);
      return new Response(JSON.stringify({ 
        transcript: [], 
        extractedData: {}, 
        conversationCount: 0 
      }), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      });
    }
  }),
});

export default http;
</file>

<file path="convex/README.md">
# Gullie Travel Planner - Convex Backend

This is the backend for a travel planning system that uses **LLM integration with Zod schemas** and **Exa MCP server integration** to provide structured, validated cost simulations and real-time travel search results for international relocations.

## 🚀 **Key Features**

The system is built with Convex and provides:

- **Input Validation**: Zod schemas ensure data integrity and type safety
- **Structured LLM Prompts**: Consistent, detailed prompts for better AI responses
- **Response Validation**: Zod validation ensures LLM responses meet expected structure
- **Real-time Exa Integration**: Live travel data from Exa MCP server
- **4 Travel Preference Types**: Cheapest, luxury, fastest, and cost-effective options
- **Multi-period Analysis**: Provides estimates for 30, 90, and 180 days
- **Cost Categories**: Flight tickets, housing, and furniture moving costs
- **Risk Assessment**: Built-in risk analysis and recommendations

## 🏗️ **Architecture Overview**

### **1. Zod Schema System (`/schemas/zod-schemas.ts`)**

The core of the system uses Zod for:

- **Input Validation**: Ensures all travel inputs meet requirements
- **LLM Response Validation**: Validates AI-generated responses
- **Type Safety**: Full TypeScript integration with runtime validation
- **Structured Prompts**: Consistent LLM prompting for reliable results

#### **Key Schemas:**

- `CostSchema` - Base monetary values with currency
- `FlightCostSchema` - Detailed flight cost breakdown
- `HousingCostSchema` - Property rental and utility costs
- `MovingCostSchema` - Furniture moving and logistics costs
- `SimulationResultSchema` - Complete cost simulation for each time period
- `LLMResponseSchema` - Full AI response structure
- `TravelInputSchema` - User input validation

### **2. Exa MCP Integration (`/mcp.ts`)**

Real-time travel data integration using Exa's MCP server:

- **4 Travel Preferences**: Cheapest, luxury, fastest, cost-effective
- **Live Search Results**: Real-time data from travel websites
- **Categorized Results**: Flights, accommodation, and general travel info
- **Quality Assessment**: Data quality scoring and validation

#### **Travel Preference Types:**

- **🤑 Cheapest**: Budget travel, low-cost accommodation, economy flights
- **💎 Luxury**: Premium flights, 5-star hotels, exclusive experiences
- **⚡ Fastest**: Direct routes, quickest travel time, express options
- **⚖️ Cost-effective**: Best value, optimal price-quality ratio, mid-range options

### **3. Schema Files (`/schemas/`)**

- `user.ts` - User information (name, nationality)
- `city.ts` - Departure/arrival city and country data
- `date.ts` - Travel dates and user associations
- `visa.ts` - Visa requirements and costs
- `flight.ts` - Flight cost information
- `rental.ts` - Housing/rental cost data
- `message.ts` - Message storage with vector embeddings

### **4. LLM Integration (`llm-integration.ts`)**

The main actions that handle:

- Input validation using Zod schemas
- Structured prompt generation
- LLM API calls with consistent formatting
- Response validation and error handling
- **Exa data integration** for enhanced results
- Structured result formatting

### **5. Examples (`/examples/`)**

- `usage-examples.ts` - Basic Zod schema usage examples
- `exa-integration-examples.ts` - Comprehensive Exa integration examples
- Input validation demonstrations
- Prompt generation examples
- Mock LLM response validation
- **Real-time Exa search demonstrations**

## 📋 **Usage**

### **Basic Travel Planning (Legacy)**

```typescript
import { planTravel } from "./llm-integration";

const result = await planTravel({
  user: "user_id",
  departure_city: "New York",
  arrival_city: "London",
  departure_country: "United States",
  arrival_country: "United Kingdom",
});
```

### **Enhanced Travel Planning with Exa Integration**

```typescript
import { planTravelWithExa } from "./llm-integration";

const result = await planTravelWithExa({
  user: "user_id",
  departure_city: "San Francisco",
  arrival_city: "Tokyo",
  departure_country: "United States",
  arrival_country: "Japan",
  budget_constraints: {
    max_total_cost: 15000,
    preferred_currency: "USD",
    cost_priority: "balanced",
  },
  special_requirements: {
    pets: true,
    children: false,
    business_travel: true,
  },
});
```

### **Direct Exa Search Usage**

```typescript
import { getAllTravelPreferences, getTravelRecommendations } from "./mcp";

// Get all 4 preference types
const allOptions = await getAllTravelPreferences({
  departure_city: "Toronto",
  arrival_city: "Berlin",
  budget: 8000,
  currency: "EUR",
});

// Get specific preference type
const luxuryOptions = await getTravelRecommendations({
  departure_city: "London",
  arrival_city: "Dubai",
  preference: "luxury",
  budget: 20000,
  currency: "USD",
});
```

### **Using Zod Schemas Directly**

```typescript
import {
  validateTravelInput,
  validateLLMResponse,
  createStructuredPrompt,
} from "./schemas/zod-schemas";

// Validate user input
const travelInput = {
  departure_city: "Toronto",
  arrival_city: "Berlin",
  // ... other fields
};

const validatedInput = validateTravelInput(travelInput);

// Create structured prompt for LLM
const prompt = createStructuredPrompt(validatedInput);

// Validate LLM response
const validatedResponse = validateLLMResponse(llmResponse);
```

## 🔍 **Response Structure**

### **Enhanced Response with Exa Data**

The system now returns comprehensive results including real-time Exa search data:

```typescript
{
  success: true,
  input: validatedInput,
  exa_search_results: {
    departure_city: "San Francisco",
    arrival_city: "Tokyo",
    search_date: "2024-01-15T10:30:00Z",
    preferences: [
      {
        preference: "cheapest",
        total_results: 12,
        categorized_results: {
          flights: [...],
          accommodation: [...],
          general: [...]
        },
        top_recommendations: [...]
      },
      {
        preference: "luxury",
        total_results: 8,
        // ... similar structure
      },
      // ... fastest and cost-effective preferences
    ]
  },
  simulations: [...], // LLM-generated cost simulations
  general_recommendations: [...],
  market_insights: {...},
  visa_requirements: {...},
  additional_costs: {...},
  metadata: {
    total_cost_30_days: 5000,
    total_cost_90_days: 4330,
    total_cost_180_days: 3870,
    currency: "USD",
    best_time_to_book: "180 days (low season)",
    risk_assessment: "Medium - Limited availability in most periods",
    exa_data_quality: "Excellent - High quality real-time data"
  },
  prompt_metadata: {...}
}
```

## 🤖 **LLM Integration with Zod & Exa**

### **1. Structured Prompting with Real-time Data**

The system uses Zod schemas and Exa data to generate enhanced prompts:

```typescript
// System prompt defines the AI's role and expertise
const systemPrompt = `You are a global mobility expert specializing in international relocation cost analysis...`;

// User prompt is dynamically generated with travel details
const userPrompt = `Analyze the relocation costs for moving from New York, United States to London, United Kingdom...`;

// Enhanced prompt includes Exa search results
const enhancedPrompt = `${userPrompt}

Real-time travel data from Exa search:
${formatExaResultsForPrompt(exaResults)}

${formatInstructions}`;
```

### **2. Response Validation**

Every LLM response is validated against Zod schemas:

```typescript
try {
  const validatedResponse = validateLLMResponse(llmResponse);
  // Response is guaranteed to match expected structure
} catch (error) {
  // Handle validation errors gracefully
  console.error("LLM response validation failed:", error);
  return createFallbackResponse();
}
```

### **3. Exa Data Quality Assessment**

The system automatically assesses the quality of real-time data:

```typescript
function assessExaDataQuality(exaResults: any): string {
  if (!exaResults || !exaResults.preferences) {
    return "No data available";
  }

  const totalResults = exaResults.preferences.reduce(
    (sum: number, pref: any) => sum + pref.total_results,
    0
  );
  const avgResults = totalResults / exaResults.preferences.length;

  if (avgResults >= 8) return "Excellent - High quality real-time data";
  if (avgResults >= 5) return "Good - Moderate quality real-time data";
  if (avgResults >= 3) return "Fair - Limited real-time data";
  return "Poor - Minimal real-time data";
}
```

## 🔧 **Exa MCP Server Configuration**

### **1. Server Setup**

```typescript
// Exa MCP Server Configuration
const EXA_SERVER_URL = "https://server.smithery.ai/exa/mcp";
const EXA_API_KEY = "your_api_key_here";
const EXA_PROFILE = "your_profile_here";

// Create MCP transport and client
const transport = new StreamableHTTPClientTransport(new URL(serverUrl));
const client = new Client({
  name: "exa-search-smithery-mcp",
  version: "1.0.0",
});
```

### **2. Search Configuration**

```typescript
// Use Exa's search capabilities with travel-specific domains
const searchResult = await client.callTool({
  name: "search",
  arguments: {
    query: searchQuery,
    num_results: 10,
    include_domains: [
      "skyscanner.com",
      "kayak.com",
      "booking.com",
      "airbnb.com",
      "expedia.com",
      "hotels.com",
      "tripadvisor.com",
      "lonelyplanet.com",
      "nomadlist.com",
    ],
    use_autoprompt: true,
    type: "keyword",
  },
});
```

## 🧪 **Testing and Examples**

### **Running Exa Integration Examples**

```typescript
import { runAllExaExamples } from "./examples/exa-integration-examples";

// Run all demonstration examples
await runAllExaExamples();
```

### **Individual Exa Examples**

```typescript
import { examples } from "./examples/exa-integration-examples";

// Use predefined examples
await examples.basic(); // Basic search for all preferences
await examples.specific(); // Specific preference search
await examples.budget(); // Budget comparison across preferences
await examples.family(); // Family travel planning
await examples.business(); // Business travel optimization
await examples.seasonal(); // Seasonal travel planning
```

### **Exa Search Examples**

```typescript
// Example 1: Basic search for all preferences
const allOptions = await getAllTravelPreferences({
  departure_city: "New York",
  arrival_city: "London",
  dates: { departure: "2024-06-01" },
  budget: 5000,
  currency: "USD",
});

// Example 2: Luxury preference search
const luxuryOptions = await getTravelRecommendations({
  departure_city: "San Francisco",
  arrival_city: "Tokyo",
  preference: "luxury",
  budget: 15000,
  currency: "USD",
});

// Example 3: Business travel optimization
const businessOptions = await getAllTravelPreferences({
  departure_city: "Chicago",
  arrival_city: "Singapore",
  budget: 10000,
  currency: "USD",
});
```

## 🚀 **Deployment as MCP Tool**

This system is ready to be deployed as an MCP (Model Context Protocol) tool server that:

- Accepts structured travel planning requests
- Validates all inputs using Zod schemas
- Generates consistent LLM prompts
- **Integrates real-time Exa search data**
- Returns validated, structured cost simulations
- Provides comprehensive risk assessments and recommendations
- **Offers 4 travel preference types for comparison**

### **API Endpoints**

- `POST /api/plan-travel` - Basic travel planning (legacy)
- `POST /api/plan-travel-with-exa` - Enhanced travel planning with Exa integration
- `GET /api/exa-search` - Direct Exa search functionality
- `GET /api/simulations/:id` - Retrieve specific simulation results
- `GET /api/recommendations` - Get general mobility recommendations

## 🔮 **Future Enhancements**

1. **Enhanced Exa Integration**

   - Real-time flight pricing APIs
   - Live accommodation availability
   - Currency exchange rate integration
   - Seasonal trend analysis

2. **Advanced Analytics**

   - Cost trend analysis with real-time data
   - Seasonal pattern recognition
   - Budget optimization recommendations
   - Preference-based learning

3. **Multi-language Support**

   - Localized cost estimates
   - Regional market insights
   - Cultural relocation factors
   - Local Exa search sources

4. **Enhanced Zod Schemas**
   - More granular cost breakdowns
   - Regional-specific validations
   - Dynamic schema generation
   - Exa data validation schemas

## 🛠️ **Development**

### **Running Locally**

```bash
npm install
npx convex dev
```

### **Testing Exa Integration**

```bash
# Test Exa MCP connection
npx convex run mcp:initializeExaClient

# Test travel search
npx convex run mcp:searchTravelInfo --args '{"departure_city":"New York","arrival_city":"London","preference":"cheapest"}'

# Test all preferences
npx convex run mcp:getAllTravelPreferences --args '{"departure_city":"Toronto","arrival_city":"Berlin"}'
```

### **Schema Updates**

After modifying Zod schemas, run:

```bash
npx convex codegen
```

### **Adding New Exa Features**

1. Define new search parameters in `mcp.ts`
2. Add new preference types if needed
3. Update search result processing
4. Add examples to `exa-integration-examples.ts`
5. Update documentation

## 📚 **Contributing**

1. Follow the existing Zod schema structure
2. Add proper TypeScript types and validation
3. Include comprehensive error handling
4. Update documentation and examples
5. Test with various input scenarios
6. Ensure all schemas pass validation
7. **Test Exa integration thoroughly**
8. **Validate real-time data quality**

## 🔗 **Key Benefits of Zod + Exa Integration**

- **Type Safety**: Runtime validation with TypeScript integration
- **Consistent Prompts**: Structured LLM prompting for reliable results
- **Error Prevention**: Catches issues before they reach the LLM
- **Maintainability**: Clear schema definitions and validation rules
- **Scalability**: Easy to extend with new cost categories and requirements
- **Reliability**: Guaranteed response structure for downstream processing
- **Real-time Data**: Live travel information from Exa MCP server
- **Multiple Preferences**: 4 travel preference types for comprehensive planning
- **Data Quality**: Automatic assessment of real-time data quality
- **Enhanced LLM**: Better AI responses with real-time context
</file>

<file path="public/SYSTEM.md">
# Global Mobility Expert Agent Prompt

## Identity & Purpose

You are Gullie, a global mobility and relocation expert assistant. Your primary purpose is to help individuals and families navigate international relocations by providing focused, step-by-step guidance on visa requirements, moving logistics, cost estimates, and practical considerations. Be warm, engaging and fun, don't be cold. Laugh with people. You must confirm their citizenship.

## Core Communication Principle

**ONE QUESTION AT A TIME**: Always ask just one question and wait for the user's response before proceeding. Never overwhelm users with multiple questions or long explanations or offer long options, if you really need to do that, slow down. Keep responses concise and focused. You must confirm their citizenship.

## Tool Call Strategy

**PROACTIVE TOOL CALLING**: As soon as you have the required parameters for a tool call, trigger it immediately in the background. Don't wait for the user to ask. This ensures information is ready when needed.

### Required Parameters for Tool Calls:

1. **get_visa_requirements**: 
   - `origin_country`: User's passport/citizenship country (MUST CONFIRM)
   - `destination_country`: Where they're moving to
   - Trigger IMMEDIATELY when both are known
   - Continue conversation naturally while search runs in background

2. **cost_estimation**:
   - `destinationCity`: The city they're moving to
   - `familySize`: Number of people relocating
   - Trigger when these are known

3. **city_search**:
   - `originCity` and `originCountry`
   - `destinationCity` and `destinationCountry`
   - Trigger when all four are known

### Tool Call Behavior:
- All tool calls run asynchronously in the background
- Results are automatically stored in conversation context
- Access stored results when user asks related questions
- If tool call fails, fallback to GPT-4o for structured response
- NEVER tell user "I'm searching for..." - just continue conversation naturally

## Voice & Persona

- Fun, engaging

### Personality

- **Warm, Caring, Engaging but Concise and Focused**: Give brief, helpful answers and ask one question at a time
- **Expert but Approachable**: Demonstrate knowledge without overwhelming detail
- **Patient and Supportive**: Understand the stress of international moves
- **Step-by-Step**: Break complex processes into digestible pieces
- **Knows how to smile and laugh**: When you laugh, people understand and connect with you better

### Response Style

- **Keep responses under 2-3 sentences** unless specifically asked for detailed information
- **Ask one question per response** and wait for the user's answer
- **Use simple, clear language** - avoid jargon unless necessary, but definitely warm and caring
- **Be conversational** but professional, and don't give a long list of option

## Conversation Flow

### Introduction

Start with: "Hi there, I'm Gullie, your global mobility expert. I'm here to help you navigate your international relocation. Could you tell me which country and city you're moving from, and where you're planning to relocate to?"

**Wait for their response before asking anything else.**

### Information Gathering (One Question at a Time)

1. **First**: "What passport do you hold? I need to confirm your citizenship to check visa requirements."
   - AS SOON AS YOU HAVE ORIGIN AND DESTINATION COUNTRIES → Trigger visa_requirements tool
2. **After they answer**: "What's your target timeline for this move?"
3. **After they answer**: "Will you be moving alone, or do you have family members joining you?"
   - When you know family size and destination → Trigger cost_estimation tool
4. **After they answer**: "What's most important to you - minimizing costs, moving quickly, or having the most support?"

**Never ask multiple questions at once.**

### Using Stored Context

When user asks about visas, costs, or other topics:
1. Check if relevant tool results exist in conversation context
2. Use stored results to answer immediately
3. If no results exist, trigger appropriate tool call
4. Continue conversation naturally while tool runs

### Visa Analysis

1. **When visa results are ready**: Use stored visa options from context
2. **Brief Overview**: "Based on your [country] passport, here are the main visa options for [destination]: [list 2-3 main types from stored results]."
3. **Single Question**: "Which visa type would you like me to explain first?"
4. **Focused Response**: Provide details for that specific visa type only from stored context

### Moving Logistics

1. **One Topic at a Time**: "Let's start with flights. When would you like to travel?"
2. **Wait for Answer**: Then move to the next topic: "Now let's discuss housing. Do you prefer temporary or permanent housing?"

## Response Guidelines

### DO:

- Ask **one question per response**
- Keep explanations **brief and focused**
- **Wait for user input** before proceeding
- Use **simple, clear language**
- Break complex topics into **small steps**
- **Trigger tool calls proactively** when you have required params
- **Use stored context** from previous tool calls

### DON'T:

- Ask multiple questions at once
- Give long, comprehensive explanations unless specifically requested
- Overwhelm users with too much information
- Assume users want detailed breakdowns immediately
- Tell users you're "searching" or "looking up" information
- Wait for users to ask before triggering tool calls

## Scenario Examples

### User: "I want to move from New York to London"

**Good Response**: "Great! I assume you are US citizen holding a US passport?"
[IMMEDIATELY trigger visa_requirements with origin_country="United States", destination_country="United Kingdom" in background]

**Bad Response**: "Excellent! London is a fantastic city. Let me walk you through everything you'll need: visa requirements, housing options, cost estimates, school systems, healthcare, transportation, cultural considerations, and more. First, what's your timeline, family situation, budget, and preferred moving date?"

### User: "What visa do I need?"

**Good Response**: [Check stored visa results from earlier tool call] "For moving from the US to the UK, you can choose from a work visa, family visa, or student visa. Any ideas?"

**Bad Response**: "Let me search for visa options for you..." [Then listing everything]

## Tool Usage

When using tools:

1. **Trigger immediately** when you have required parameters
2. **Don't announce** that you're searching
3. **Continue conversation** naturally while tool runs
4. **Access stored results** when relevant questions arise
5. **Present key findings** in 1-2 sentences from stored context
6. **Ask one follow-up question**

## Knowledge Base

You have access to comprehensive information about:

- Visa requirements and processes (stored in context after tool calls)
- Moving logistics and costs (stored in context after tool calls)
- Document preparation
- Housing and school options
- Cost estimates (stored in context after tool calls)

**Use stored knowledge from tool calls to answer specific questions, not to provide overwhelming overviews.**

## Response Refinement

- **Scope Restriction**: For non-mobility questions: "I'm sorry, I can only answer questions related to global relocation. What specific aspect of your international move can I help with?"
- **Complex Explanations**: Only provide detailed breakdowns when specifically requested
- **Document Requirements**: Explain one document at a time, not all at once

## Search Protocol

When information is needed:

1. **Check stored context first** from previous tool calls
2. **If not available, trigger tool** with required parameters
3. **Continue conversation** without mentioning the search
4. **Present results naturally** when relevant
5. **Ask one specific question** about what they'd like to know more about

## State Management

All tool call results are automatically:
- Stored in conversation context
- Associated with the current call/session ID
- Available for the entire conversation
- Structured according to zod schemas for consistency

## Remember

- **One question per response**
- **Keep explanations brief**
- **Wait for user input**
- **Build understanding step by step**
- **Don't overwhelm with information**
- **Trigger tools proactively**
- **Use stored context efficiently**

Your goal is to make international relocation feel manageable by breaking it into small, digestible pieces that users can process one at a time, while ensuring all necessary information is gathered and processed in the background for immediate access when needed.
</file>

<file path="scripts/register-vapi-tools.ts">
#!/usr/bin/env bun

const VAPI_API_KEY = process.env.VAPI_API_KEY;
const VAPI_ASSISTANT_ID = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;
const CONVEX_SITE_URL = "https://impartial-ladybug-267.convex.site";

interface VapiTool {
  type: "function";
  function: {
    name: string;
    description: string;
    parameters: {
      type: "object";
      properties: Record<string, any>;
      required?: string[];
    };
  };
  server: {
    url: string;
  };
}

interface ExistingTool extends VapiTool {
  id: string;
  createdAt: string;
  updatedAt: string;
  orgId: string;
}

const tools: VapiTool[] = [
  {
    type: "function",
    function: {
      name: "search_relocation_options",
      description: "Search for visa and relocation options between two countries. Returns 4 options: budget, express, balanced, and premium relocation plans with costs and timelines.",
      parameters: {
        type: "object",
        properties: {
          origin_city: {
            type: "string",
            description: "The city of origin (e.g., 'London', 'New York', 'Mumbai')"
          },
          origin_country: {
            type: "string",
            description: "The country of origin (e.g., 'United Kingdom', 'USA', 'India')"
          },
          destination_city: {
            type: "string",
            description: "The destination city (e.g., 'San Francisco', 'Toronto', 'Berlin')"
          },
          destination_country: {
            type: "string",
            description: "The destination country (e.g., 'United States', 'Canada', 'Germany')"
          }
        },
        required: ["origin_city", "origin_country", "destination_city", "destination_country"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/search_relocation_options`
    }
  },
  {
    type: "function",
    function: {
      name: "get_visa_requirements",
      description: "Get detailed visa requirements for a specific country pair and visa type. Returns processing times, costs, required documents, and application procedures.",
      parameters: {
        type: "object",
        properties: {
          origin_country: {
            type: "string",
            description: "The country of citizenship or passport country (e.g., 'United Kingdom', 'USA', 'India')"
          },
          destination_country: {
            type: "string",
            description: "The destination country where visa is needed (e.g., 'United States', 'Canada', 'Germany')"
          },
          visa_type: {
            type: "string",
            description: "Type of visa being applied for",
            enum: ["tourist", "work", "student", "business"]
          }
        },
        required: ["origin_country", "destination_country", "visa_type"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/get_visa_requirements`
    }
  },
  {
    type: "function",
    function: {
      name: "estimate_relocation_costs",
      description: "Calculate detailed cost estimates for relocating to a new city, including flights, housing, moving expenses, and initial setup costs.",
      parameters: {
        type: "object",
        properties: {
          destination_city: {
            type: "string",
            description: "The destination city for relocation (e.g., 'London', 'New York', 'Singapore')"
          },
          include_flight: {
            type: "boolean",
            description: "Include flight costs in the estimate",
            default: true
          },
          include_housing: {
            type: "boolean",
            description: "Include housing costs in the estimate",
            default: true
          },
          include_moving: {
            type: "boolean",
            description: "Include moving/shipping costs in the estimate",
            default: true
          },
          family_size: {
            type: "number",
            description: "Number of family members relocating",
            default: 1
          }
        },
        required: ["destination_city"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/estimate_relocation_costs`
    }
  },
  {
    type: "function",
    function: {
      name: "get_document_details",
      description: "Get detailed information about specific documents required for relocation, including how to obtain them, processing times, and validity periods.",
      parameters: {
        type: "object",
        properties: {
          document_type: {
            type: "string",
            description: "Type of document needed for relocation",
            enum: ["passport", "visa", "birth_certificate", "marriage_certificate", "bank_statement", "employment_letter"]
          },
          country: {
            type: "string",
            description: "Country for which document details are needed (e.g., 'United States', 'Canada', 'United Kingdom')"
          }
        },
        required: ["document_type", "country"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/get_document_details`
    }
  },
  {
    type: "function",
    function: {
      name: "capture_contact_info",
      description: "Save user contact information for follow-up and sending detailed reports. This allows us to provide personalized assistance.",
      parameters: {
        type: "object",
        properties: {
          email: {
            type: "string",
            description: "User's email address for sending reports"
          },
          phone: {
            type: "string",
            description: "User's phone number for follow-up calls (optional)"
          },
          name: {
            type: "string",
            description: "User's full name for personalization"
          }
        },
        required: ["email", "name"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/capture_contact_info`
    }
  },
  {
    type: "function",
    function: {
      name: "send_pdf_report",
      description: "Generate and send a comprehensive PDF report to the user's email with detailed visa requirements, cost breakdowns, and step-by-step relocation guide.",
      parameters: {
        type: "object",
        properties: {
          email: {
            type: "string",
            description: "Email address to send the PDF report to"
          },
          consultation_data: {
            type: "object",
            description: "Consultation data to include in the PDF report",
            properties: {
              name: { 
                type: "string",
                description: "User's name"
              },
              originCity: { 
                type: "string",
                description: "City of origin"
              },
              originCountry: { 
                type: "string",
                description: "Country of origin"
              },
              destinationCity: { 
                type: "string",
                description: "Destination city"
              },
              destinationCountry: { 
                type: "string",
                description: "Destination country"
              },
              visaOptions: { 
                type: "string",
                description: "Visa options and recommendations"
              }
            }
          }
        },
        required: ["email", "consultation_data"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/send_pdf_report`
    }
  },
  {
    type: "function",
    function: {
      name: "confirm_visa_options",
      description: "Handle user's preference to either receive a detailed PDF report via email or discuss visa options in the current conversation.",
      parameters: {
        type: "object",
        properties: {
          user_choice: {
            type: "string",
            description: "User's preference for receiving information",
            enum: ["email", "discuss"]
          },
          email: {
            type: "string",
            description: "User's email address if they chose to receive PDF report"
          },
          name: {
            type: "string",
            description: "User's name if they chose to receive PDF report"
          },
          search_data: {
            type: "string",
            description: "Search results and visa options to include in the report"
          },
          origin_city: {
            type: "string",
            description: "Origin city from the search"
          },
          origin_country: {
            type: "string",
            description: "Origin country from the search"
          },
          destination_city: {
            type: "string",
            description: "Destination city from the search"
          },
          destination_country: {
            type: "string",
            description: "Destination country from the search"
          },
          storage_id: {
            type: "string",
            description: "Storage ID for any uploaded documents (optional)"
          }
        },
        required: ["user_choice"]
      }
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/confirm_visa_options`
    }
  }
];

async function listExistingTools(): Promise<ExistingTool[]> {
  try {
    const response = await fetch('https://api.vapi.ai/tool?limit=1000', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`
      }
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('Failed to list tools:', error);
      return [];
    }

    const tools = await response.json();
    return tools;
  } catch (error) {
    console.error('Error listing tools:', error);
    return [];
  }
}

async function createTool(tool: VapiTool): Promise<{ id: string; name: string } | null> {
  try {
    const response = await fetch('https://api.vapi.ai/tool', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${VAPI_API_KEY}`
      },
      body: JSON.stringify(tool)
    });

    if (!response.ok) {
      const error = await response.text();
      console.error(`Failed to create tool ${tool.function.name}:`, error);
      return null;
    }

    const result = await response.json();
    console.log(`✅ Created tool: ${tool.function.name} (ID: ${result.id})`);
    return { id: result.id, name: tool.function.name };
  } catch (error) {
    console.error(`Error creating tool ${tool.function.name}:`, error);
    return null;
  }
}

async function updateTool(toolId: string, tool: VapiTool): Promise<boolean> {
  try {
    const response = await fetch(`https://api.vapi.ai/tool/${toolId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${VAPI_API_KEY}`
      },
      body: JSON.stringify(tool)
    });

    if (!response.ok) {
      const error = await response.text();
      console.error(`Failed to update tool ${tool.function.name}:`, error);
      return false;
    }

    console.log(`✅ Updated tool: ${tool.function.name} (ID: ${toolId})`);
    return true;
  } catch (error) {
    console.error(`Error updating tool ${tool.function.name}:`, error);
    return false;
  }
}

async function deleteTool(toolId: string): Promise<boolean> {
  try {
    const response = await fetch(`https://api.vapi.ai/tool/${toolId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`
      }
    });

    if (!response.ok) {
      const error = await response.text();
      console.error(`Failed to delete tool ${toolId}:`, error);
      return false;
    }

    return true;
  } catch (error) {
    console.error(`Error deleting tool ${toolId}:`, error);
    return false;
  }
}

async function updateAssistantTools(toolIds: string[]) {
  try {
    const response = await fetch(`https://api.vapi.ai/assistant/${VAPI_ASSISTANT_ID}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: {
          provider: "openai",
          model: "gpt-4o",
          toolIds: toolIds
        }
      })
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('Failed to update assistant:', error);
      return false;
    }

    console.log('✅ Assistant updated with all tools');
    return true;
  } catch (error) {
    console.error('Error updating assistant:', error);
    return false;
  }
}

async function main() {
  console.log('🚀 Starting Vapi tool registration...');
  console.log(`📍 Using Convex site URL: ${CONVEX_SITE_URL}`);
  console.log(`🤖 Assistant ID: ${VAPI_ASSISTANT_ID}\n`);

  if (!VAPI_API_KEY) {
    console.error('❌ VAPI_API_KEY not found in environment variables');
    process.exit(1);
  }

  if (!VAPI_ASSISTANT_ID) {
    console.error('❌ NEXT_PUBLIC_VAPI_ASSISTANT_ID not found in environment variables');
    process.exit(1);
  }

  // Step 1: List existing tools
  console.log('📋 Fetching existing tools...');
  const existingTools = await listExistingTools();
  console.log(`Found ${existingTools.length} existing tools\n`);

  // Create a map of existing tools by name
  const existingToolsByName = new Map<string, ExistingTool[]>();
  for (const tool of existingTools) {
    if (tool.type === 'function' && tool.function?.name) {
      const name = tool.function.name;
      if (!existingToolsByName.has(name)) {
        existingToolsByName.set(name, []);
      }
      existingToolsByName.get(name)!.push(tool);
    }
  }

  // Step 2: Process each tool
  const finalToolIds: string[] = [];

  for (const tool of tools) {
    const toolName = tool.function.name;
    const existing = existingToolsByName.get(toolName) || [];

    if (existing.length === 0) {
      // Create new tool
      console.log(`🆕 Creating new tool: ${toolName}`);
      const result = await createTool(tool);
      if (result) {
        finalToolIds.push(result.id);
      }
    } else if (existing.length === 1) {
      // Update existing tool
      console.log(`🔄 Updating existing tool: ${toolName}`);
      const success = await updateTool(existing[0].id, tool);
      if (success) {
        finalToolIds.push(existing[0].id);
      }
    } else {
      // Multiple duplicates - clean up and keep one
      console.log(`⚠️  Found ${existing.length} duplicates for ${toolName}, cleaning up...`);
      
      // Sort by creation date (newest first)
      existing.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
      
      // Keep the newest, delete the rest
      for (let i = 1; i < existing.length; i++) {
        console.log(`  🗑️  Deleting duplicate: ${existing[i].id}`);
        await deleteTool(existing[i].id);
      }
      
      // Update the one we kept
      console.log(`  🔄 Updating kept tool: ${existing[0].id}`);
      const success = await updateTool(existing[0].id, tool);
      if (success) {
        finalToolIds.push(existing[0].id);
      }
    }
  }

  // Step 3: Clean up any old tools not in our list
  const ourToolNames = new Set(tools.map(t => t.function.name));
  for (const [name, toolList] of existingToolsByName) {
    if (!ourToolNames.has(name)) {
      console.log(`🗑️  Removing obsolete tool: ${name}`);
      for (const tool of toolList) {
        await deleteTool(tool.id);
      }
    }
  }

  console.log(`\n📝 Registered ${finalToolIds.length}/${tools.length} tools`);

  // Step 4: Update assistant with final tool list
  if (finalToolIds.length > 0) {
    console.log('\n🔄 Updating assistant with tools...');
    const success = await updateAssistantTools(finalToolIds);
    
    if (success) {
      console.log('\n✨ All tools registered and assistant updated successfully!');
      console.log('\nTool IDs for reference:');
      finalToolIds.forEach(id => console.log(`  - ${id}`));
    } else {
      console.log('\n⚠️  Tools registered but assistant update failed. Please update manually.');
    }
  } else {
    console.log('\n❌ No tools were registered. Please check the errors above.');
  }
}

main().catch(console.error);
</file>

<file path="scripts/updateVapiAssistant.ts">
// Script to update Vapi assistant with custom tools
// Run with: npx tsx scripts/updateVapiAssistant.ts

import * as dotenv from "dotenv";
import { readFileSync } from "fs";
import { join } from "path";

dotenv.config({ path: ".env.local" });

const VAPI_API_KEY = process.env.VAPI_API_KEY;
const VAPI_ASSISTANT_ID = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;
const CONVEX_SITE_URL = process.env.NEXT_PUBLIC_CONVEX_URL;

if (!VAPI_API_KEY || !VAPI_ASSISTANT_ID || !CONVEX_SITE_URL) {
  console.error("Missing required environment variables");
  process.exit(1);
}

// Read system prompt from file
let systemPrompt: string;
const systemPromptPath = join(process.cwd(), "public/SYSTEM.md");

try {
  // Check if file exists first
  const fs = require("fs");
  if (!fs.existsSync(systemPromptPath)) {
    console.error(
      `Error: System prompt file not found at: ${systemPromptPath}`
    );
    process.exit(1);
  }

  systemPrompt = readFileSync(systemPromptPath, "utf-8");

  // Ensure we have a proper string and add debugging
  if (typeof systemPrompt !== "string") {
    console.error("Error: systemPrompt is not a string:", typeof systemPrompt);
    process.exit(1);
  }

  if (systemPrompt.trim().length === 0) {
    console.error("Error: systemPrompt file is empty");
    process.exit(1);
  }

  // Check if the file contains expected content structure
  if (!systemPrompt.includes("Global Mobility Expert Agent Prompt")) {
    console.error(
      "Error: System prompt file doesn't contain expected content structure"
    );
    console.error(
      "Expected to find 'Global Mobility Expert Agent Prompt' in the file"
    );
    process.exit(1);
  }

  // Check for key sections
  const requiredSections = [
    "Core Communication Principle",
    "ONE QUESTION AT A TIME",
    "Response Guidelines",
  ];

  for (const section of requiredSections) {
    if (!systemPrompt.includes(section)) {
      console.error(
        `Error: System prompt missing required section: ${section}`
      );
      process.exit(1);
    }
  }

  console.log(
    "System prompt loaded successfully, length:",
    systemPrompt.length
  );
  console.log("First 100 characters:", systemPrompt.substring(0, 100));
} catch (error) {
  console.error("Error reading system prompt file:", error);
  console.error("File path attempted:", systemPromptPath);
  process.exit(1);
}

const tools = [
  {
    type: "function",
    function: {
      name: "search_relocation_options",
      description:
        "Search for relocation options when user provides origin and destination cities",
      parameters: {
        type: "object",
        properties: {
          origin_city: {
            type: "string",
            description: "The city the user is moving from",
          },
          origin_country: {
            type: "string",
            description: "The country the user is moving from",
          },
          destination_city: {
            type: "string",
            description: "The city the user is moving to",
          },
          destination_country: {
            type: "string",
            description: "The country the user is moving to",
          },
        },
        required: [
          "origin_city",
          "origin_country",
          "destination_city",
          "destination_country",
        ],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/search_relocation_options`,
      timeoutSeconds: 20,
    },
    messages: [
      {
        type: "request-start",
        content:
          "Let me search for the best relocation options from {{origin_city}} to {{destination_city}}. This will take just a moment...",
      },
      {
        type: "request-complete",
        content: "I've found comprehensive relocation options for your move.",
      },
      {
        type: "request-failed",
        content:
          "I'm having trouble searching for relocation options right now. Let me try another approach.",
      },
    ],
  },
  {
    type: "function",
    function: {
      name: "get_visa_requirements",
      description: "Get detailed visa requirements for specific visa types",
      parameters: {
        type: "object",
        properties: {
          origin_country: {
            type: "string",
            description: "Country of origin",
          },
          destination_country: {
            type: "string",
            description: "Destination country",
          },
          visa_type: {
            type: "string",
            description: "Specific visa type (optional)",
          },
        },
        required: ["origin_country", "destination_country"],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/get_visa_requirements`,
      timeoutSeconds: 20,
    },
    messages: [
      {
        type: "request-start",
        content: "Looking up visa requirements for {{destination_country}}...",
      },
      {
        type: "request-complete",
        content: "I've retrieved the visa requirements.",
      },
    ],
  },
  {
    type: "function",
    function: {
      name: "estimate_relocation_costs",
      description: "Calculate detailed cost breakdown for relocation",
      parameters: {
        type: "object",
        properties: {
          destination_city: {
            type: "string",
            description: "Destination city",
          },
          include_flight: {
            type: "boolean",
            description: "Include flight costs",
          },
          include_housing: {
            type: "boolean",
            description: "Include housing costs",
          },
          include_moving: {
            type: "boolean",
            description: "Include moving service costs",
          },
          family_size: {
            type: "number",
            description: "Number of people relocating",
          },
        },
        required: ["destination_city"],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/estimate_relocation_costs`,
      timeoutSeconds: 20,
    },
    messages: [
      {
        type: "request-start",
        content: "Calculating your relocation costs...",
      },
    ],
  },
  {
    type: "function",
    function: {
      name: "get_document_details",
      description: "Provide detailed document preparation guidance",
      parameters: {
        type: "object",
        properties: {
          document_type: {
            type: "string",
            description: "Type of document",
          },
          country: {
            type: "string",
            description: "Country for which document is needed",
          },
        },
        required: ["document_type", "country"],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/get_document_details`,
      timeoutSeconds: 20,
    },
    messages: [
      {
        type: "request-start",
        content: "Looking up document requirements...",
      },
    ],
  },
  {
    type: "function",
    function: {
      name: "capture_contact_info",
      description: "Capture user's email and phone number for sending reports",
      parameters: {
        type: "object",
        properties: {
          email: {
            type: "string",
            description: "User's email address",
          },
          phone: {
            type: "string",
            description: "User's phone number",
          },
          name: {
            type: "string",
            description: "User's name",
          },
        },
        required: ["email", "name"],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/capture_contact_info`,
      timeoutSeconds: 20,
    },
    messages: [
      {
        type: "request-start",
        content: "Saving your contact information...",
      },
    ],
  },
  {
    type: "function",
    function: {
      name: "send_pdf_report",
      description: "Send comprehensive PDF report to user's email",
      parameters: {
        type: "object",
        properties: {
          email: {
            type: "string",
            description: "Email address to send report to",
          },
          consultation_data: {
            type: "object",
            description: "Consultation data to include in report",
          },
        },
        required: ["email", "consultation_data"],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/send_pdf_report`,
      timeoutSeconds: 20,
    },
    messages: [
      {
        type: "request-start",
        content: "Preparing your comprehensive PDF report...",
      },
      {
        type: "request-complete",
        content: "Your detailed relocation report has been sent to your email!",
      },
    ],
  },
  {
    type: "function",
    function: {
      name: "confirm_visa_options",
      description:
        "Confirm whether user wants detailed explanation or PDF report",
      parameters: {
        type: "object",
        properties: {
          send_pdf: {
            type: "boolean",
            description:
              "Whether user wants PDF report instead of voice explanation",
          },
        },
        required: ["send_pdf"],
      },
    },
    server: {
      url: `${CONVEX_SITE_URL}/tools/confirm_visa_options`,
      timeoutSeconds: 20,
    },
  },
];

async function updateAssistant() {
  try {
    console.log("Updating Vapi assistant...");
    console.log("Assistant ID:", VAPI_ASSISTANT_ID);
    console.log("Convex Site URL:", CONVEX_SITE_URL);

    const response = await fetch(
      `https://api.vapi.ai/assistant/${VAPI_ASSISTANT_ID}`,
      {
        method: "PATCH",
        headers: {
          Authorization: `Bearer ${VAPI_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: "Gullie - Global Mobility Expert",
          firstMessage:
            "Hi there, I'm Gullie, your global mobility expert. I'm here to help you navigate your international relocation. Could you tell me which country and city you're moving from, and where you're planning to relocate to?",
          model: {
            provider: "openai",
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: systemPrompt,
              },
            ],
            tools: tools,
            temperature: 0.7,
            maxTokens: 500,
          },
          voice: {
            provider: "vapi",
            voiceId: "Lily",
          },
          serverUrl: `${CONVEX_SITE_URL}/webhooks/vapi`,
          clientMessages: [
            "transcript",
            "tool-calls",
            "speech-update",
            "status-update",
          ],
          serverMessages: [
            "transcript",
            "tool-calls",
            "end-of-call-report",
            "status-update",
          ],
          endCallPhrases: [
            "goodbye",
            "bye",
            "see you later",
            "talk to you later",
          ],
          backgroundSound: "off",
          responseDelaySeconds: 0.4,
          llmRequestDelaySeconds: 0.1,
          numWordsToInterruptAssistant: 2,
        }),
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to update assistant: ${error}`);
    }

    const result = await response.json();
    console.log("✅ Assistant updated successfully!");
    console.log("Assistant ID:", result.id);
    console.log("Tools configured:", result.model.tools.length);
  } catch (error) {
    console.error("❌ Error updating assistant:", error);
    process.exit(1);
  }
}

updateAssistant();
</file>

<file path="src/app/account/page.tsx">
"use client";

import { withAuth } from "@workos-inc/authkit-nextjs";
import { useEffect, useState } from "react";
import { motion } from "motion/react";
import Link from "next/link";

type User = {
  id: string;
  email: string | null;
  firstName: string | null;
  lastName: string | null;
};

interface UserProfile {
  email: string;
  phone: string;
  firstName: string;
  lastName: string;
}

export default function AccountPage() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [profile, setProfile] = useState<UserProfile>({
    email: "",
    phone: "",
    firstName: "",
    lastName: "",
  });
  const [editing, setEditing] = useState(false);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState("");

  useEffect(() => {
    async function fetchUser() {
      try {
        const { user: authUser } = await withAuth();
        setUser(authUser);
        if (authUser) {
          setProfile({
            email: authUser.email || "",
            phone: "", // Phone would come from your database
            firstName: authUser.firstName || "",
            lastName: authUser.lastName || "",
          });
        }
      } catch (error) {
        console.error("Auth error:", error);
      } finally {
        setLoading(false);
      }
    }
    fetchUser();
  }, []);

  const handleSave = async () => {
    setSaving(true);
    setMessage("");

    try {
      // TODO: Save to your database via Convex mutation
      // For now, we'll just simulate a save
      await new Promise((resolve) => setTimeout(resolve, 1000));

      setMessage("Profile updated successfully!");
      setEditing(false);
    } catch (error) {
      console.error("Save error:", error);
      setMessage("Failed to update profile. Please try again.");
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-electric animate-pulse">
          Loading account information...
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-electric mb-4">
            Sign In Required
          </h1>
          <p className="text-gray-400 mb-8">
            Please sign in to access your account
          </p>
          <Link href="/">
            <motion.button
              whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
              whileTap={{
                scale: 0.95,
                backgroundColor: "#00ffff",
                color: "#000000",
                transition: { duration: 0 }
              }}
              className="px-6 py-3 border border-electric text-electric"
            >
              Go to Home
            </motion.button>
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center px-8">
      <div className="max-w-2xl w-full">
        <h1 className="text-4xl font-bold text-electric mb-8 text-center">
          Account Settings
        </h1>

        <div className="border border-electric/30 p-8 mb-8">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold text-electric">
              Profile Information
            </h2>
            {!editing && (
              <motion.button
                whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                whileTap={{
                  scale: 0.95,
                  backgroundColor: "#00ffff",
                  color: "#000000",
                  transition: { duration: 0 }
                }}
                className="px-4 py-2 border border-electric text-electric"
                onClick={() => setEditing(true)}
              >
                Edit Profile
              </motion.button>
            )}
          </div>

          {message && (
            <div
              className={`p-3 mb-4 border ${
                message.includes("success")
                  ? "border-green-500/30 bg-green-500/10 text-green-400"
                  : "border-red-500/30 bg-red-500/10 text-red-400"
              }`}
            >
              {message}
            </div>
          )}

          <div className="space-y-4">
            <div>
              <label className="block text-gray-400 mb-2">First Name</label>
              <input
                type="text"
                value={profile.firstName}
                onChange={(e) =>
                  setProfile({ ...profile, firstName: e.target.value })
                }
                disabled={!editing}
                className="w-full px-4 py-3 bg-black border border-electric/30 text-white disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-electric"
              />
            </div>

            <div>
              <label className="block text-gray-400 mb-2">Last Name</label>
              <input
                type="text"
                value={profile.lastName}
                onChange={(e) =>
                  setProfile({ ...profile, lastName: e.target.value })
                }
                disabled={!editing}
                className="w-full px-4 py-3 bg-black border border-electric/30 text-white disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-electric"
              />
            </div>

            <div>
              <label className="block text-gray-400 mb-2">Email Address</label>
              <input
                type="email"
                value={profile.email}
                onChange={(e) =>
                  setProfile({ ...profile, email: e.target.value })
                }
                disabled={!editing}
                className="w-full px-4 py-3 bg-black border border-electric/30 text-white disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-electric"
              />
            </div>

            <div>
              <label className="block text-gray-400 mb-2">Phone Number</label>
              <input
                type="tel"
                value={profile.phone}
                onChange={(e) =>
                  setProfile({ ...profile, phone: e.target.value })
                }
                disabled={!editing}
                placeholder="+1 (555) 123-4567"
                className="w-full px-4 py-3 bg-black border border-electric/30 text-white disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:border-electric placeholder-gray-600"
              />
            </div>
          </div>

          {editing && (
            <div className="flex gap-4 mt-6">
              <motion.button
                whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                whileTap={{
                  scale: 0.95,
                  backgroundColor: "#00ffff",
                  color: "#000000",
                  transition: { duration: 0 }
                }}
                className="px-6 py-3 border border-electric text-electric disabled:opacity-50 disabled:cursor-not-allowed"
                onClick={handleSave}
                disabled={saving}
              >
                {saving ? "Saving..." : "Save Changes"}
              </motion.button>

              <motion.button
                whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                whileTap={{ scale: 0.95, transition: { duration: 0 } }}
                className="px-6 py-3 border border-gray-500 text-gray-500"
                onClick={() => {
                  setEditing(false);
                  setMessage("");
                  // Reset to original values
                  setProfile({
                    email: user.email || "",
                    phone: "",
                    firstName: user.firstName || "",
                    lastName: user.lastName || "",
                  });
                }}
                disabled={saving}
              >
                Cancel
              </motion.button>
            </div>
          )}
        </div>

        <div className="border border-electric/30 p-8">
          <h2 className="text-2xl font-bold text-electric mb-4">Account ID</h2>
          <p className="text-gray-400 font-mono text-sm break-all">{user.id}</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/billing/page.tsx">
"use client";

import { withAuth } from "@workos-inc/authkit-nextjs";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import Link from "next/link";
import { useEffect, useState } from "react";
import { motion } from "motion/react";
import { Id } from "../../../convex/_generated/dataModel";

type User = {
  id: string;
  email: string | null;
  firstName: string | null;
  lastName: string | null;
};

type Checkout = {
  _id: Id<"checkouts">;
  checkoutId: string;
  customerId: string;
  productId: string;
  amount: number;
  currency: string;
  status: string;
  metadata: Record<string, unknown>;
  createdAt: number;
  _creationTime: number;
};

export default function BillingPage() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUser() {
      try {
        const { user: authUser } = await withAuth();
        setUser(authUser);
      } catch (error) {
        console.error("Auth error:", error);
      } finally {
        setLoading(false);
      }
    }
    fetchUser();
  }, []);

  const subscription = useQuery(
    api.subscriptions.getUserSubscription,
    user ? { userId: user.id } : "skip"
  );

  const checkouts = useQuery(
    api.subscriptions.getUserCheckouts,
    user ? { customerId: user.id } : "skip"
  );

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-electric animate-pulse">
          Loading billing information...
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-electric mb-4">
            Authentication Required
          </h1>
          <p className="text-gray-400 mb-8">
            Please sign in to view your billing information
          </p>
          <Link href="/">
            <motion.button
              whileHover={{ 
                scale: 1.05, 
                x: 2, 
                y: -2,
                transition: { duration: 0.05 }
              }}
              whileTap={{
                scale: 0.95,
                backgroundColor: "#00ffff",
                color: "#000000",
                transition: { duration: 0 }
              }}
              className="px-6 py-3 border border-electric text-electric"
            >
              Go to Home
            </motion.button>
          </Link>
        </div>
      </div>
    );
  }

  const formatDate = (dateString?: string) => {
    if (!dateString) return "N/A";
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  const formatCurrency = (amount: number, currency: string = "USD") => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: currency.toUpperCase(),
    }).format(amount / 100); // Assuming amount is in cents
  };

  return (
    <div className="min-h-screen flex items-center justify-center px-8">
      <div className="max-w-4xl w-full">
        <h1 className="text-4xl font-bold text-electric mb-8 text-center">
          Billing & Subscription
        </h1>

        {/* Current Subscription */}
        <div className="border border-electric/30 p-8 mb-8">
          <h2 className="text-2xl font-bold text-electric mb-4">
            Current Subscription
          </h2>

          {subscription ? (
            <div className="space-y-3">
              <div className="flex justify-between">
                <span className="text-gray-400">Status:</span>
                <span
                  className={`font-bold ${
                    subscription.status === "active"
                      ? "text-green-500"
                      : subscription.status === "canceled"
                        ? "text-red-500"
                        : "text-yellow-500"
                  }`}
                >
                  {subscription.status.toUpperCase()}
                </span>
              </div>

              <div className="flex justify-between">
                <span className="text-gray-400">Current Period:</span>
                <span className="text-white">
                  {formatDate(subscription.currentPeriodStart)} -{" "}
                  {formatDate(subscription.currentPeriodEnd)}
                </span>
              </div>

              {subscription.cancelAtPeriodEnd && (
                <div className="bg-red-500/10 border border-red-500/30 p-3 mt-4">
                  <p className="text-red-400">
                    Your subscription will be canceled at the end of the current
                    period
                  </p>
                </div>
              )}

              <div className="mt-6 flex gap-4">
                {subscription.status === "active" &&
                  !subscription.cancelAtPeriodEnd && (
                    <motion.button
                      whileHover={{ 
                        scale: 1.05, 
                        x: 2, 
                        y: -2,
                        transition: { duration: 0.05 }
                      }}
                      whileTap={{
                        scale: 0.95,
                        backgroundColor: "#ff0000",
                        color: "#ffffff",
                        transition: { duration: 0 }
                      }}
                      className="px-4 py-3 border border-red-500 text-red-500"
                      onClick={() => {
                        // TODO: Implement cancel subscription via Polar API
                        console.log("Cancel subscription");
                      }}
                    >
                      Cancel Subscription
                    </motion.button>
                  )}

                {subscription.cancelAtPeriodEnd && (
                  <motion.button
                    whileHover={{ 
                      scale: 1.05, 
                      x: 2, 
                      y: -2,
                      transition: { duration: 0.05 }
                    }}
                    whileTap={{
                      scale: 0.95,
                      backgroundColor: "#00ffff",
                      color: "#000000",
                      transition: { duration: 0 }
                    }}
                    className="px-4 py-3 border border-electric text-electric"
                    onClick={() => {
                      // TODO: Implement reactivate subscription via Polar API
                      console.log("Reactivate subscription");
                    }}
                  >
                    Reactivate Subscription
                  </motion.button>
                )}
              </div>
            </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-400 mb-6">
                You don&apos;t have an active subscription
              </p>
              <Link href="/checkout">
                <motion.button
                  whileHover={{ 
                    scale: 1.05, 
                    x: 2, 
                    y: -2,
                    transition: { duration: 0.05 }
                  }}
                  whileTap={{
                    scale: 0.95,
                    backgroundColor: "#00ffff",
                    color: "#000000",
                    transition: { duration: 0 }
                  }}
                  className="px-10 py-3 border bg-gray-800 text-white"
                >
                  Get Started with Premium
                </motion.button>
              </Link>
            </div>
          )}
        </div>

        {/* Billing History */}
        <div className="border border-electric/30 p-8">
          <h2 className="text-2xl font-bold text-electric mb-4">
            Billing History
          </h2>

          {checkouts && checkouts.length > 0 ? (
            <div className="space-y-4">
              {checkouts.map((checkout: Checkout) => (
                <div
                  key={checkout._id}
                  className="border-b border-electric/20 pb-4 last:border-0"
                >
                  <div className="flex justify-between items-start">
                    <div>
                      <p className="text-white font-medium">
                        {formatCurrency(checkout.amount, checkout.currency)}
                      </p>
                      <p className="text-gray-400 text-sm">
                        {formatDate(new Date(checkout.createdAt).toISOString())}
                      </p>
                    </div>
                    <span className="text-green-500 text-sm">
                      {checkout.status.toUpperCase()}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-gray-400">No billing history available</p>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/checkout/page.tsx">
"use client";

import { withAuth } from "@workos-inc/authkit-nextjs";
import { useEffect, useState } from "react";
import { motion } from "motion/react";
import Link from "next/link";

type User = {
  id: string;
  email: string | null;
  firstName: string | null;
  lastName: string | null;
};

export default function CheckoutPage() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [initiatingCheckout, setInitiatingCheckout] = useState(false);

  useEffect(() => {
    async function fetchUser() {
      try {
        const { user: authUser } = await withAuth();
        setUser(authUser);
      } catch (error) {
        console.error("Auth error:", error);
      } finally {
        setLoading(false);
      }
    }
    fetchUser();
  }, []);

  const handleCheckout = async () => {
    if (!user || !user.email) {
      alert("Please sign in with an email address to continue");
      return;
    }

    setInitiatingCheckout(true);
    
    try {
      // Call the API to create a Polar checkout session
      const response = await fetch("/api/create-checkout", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          productId: process.env.NEXT_PUBLIC_POLAR_PRODUCT_ID || "c66ea195-003c-44b5-b34a-ad16c02408e8",
          customerId: user.id,
          customerEmail: user.email,
          customerName: user.firstName ? `${user.firstName} ${user.lastName || ""}`.trim() : user.email,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to create checkout session");
      }

      const { checkoutUrl } = await response.json();
      
      // Redirect to Polar checkout
      window.location.href = checkoutUrl;
    } catch (error) {
      console.error("Checkout error:", error);
      alert("Failed to initiate checkout. Please try again.");
      setInitiatingCheckout(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-electric animate-pulse">Loading...</div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-electric mb-4">Sign In Required</h1>
          <p className="text-gray-400 mb-8">Please sign in to continue with your subscription</p>
          <Link href="/">
            <motion.button
              whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
              whileTap={{ scale: 0.95, backgroundColor: "#00ffff", color: "#000000", transition: { duration: 0 } }}
              className="px-6 py-3 border border-electric text-electric"
            >
              Go to Home
            </motion.button>
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="max-w-2xl w-full px-8">
        <h1 className="text-4xl font-bold text-electric mb-8 text-center">
          Upgrade to Premium
        </h1>
        
        <div className="border border-electric/30 p-8 mb-8">
          <h2 className="text-2xl font-bold text-white mb-6">Premium Features</h2>
          
          <ul className="space-y-4 mb-8">
            <li className="flex items-start">
              <span className="text-electric mr-3">▸</span>
              <span className="text-gray-300">Unlimited AI-powered relocation consultations</span>
            </li>
            <li className="flex items-start">
              <span className="text-electric mr-3">▸</span>
              <span className="text-gray-300">Priority visa processing guidance</span>
            </li>
            <li className="flex items-start">
              <span className="text-electric mr-3">▸</span>
              <span className="text-gray-300">Comprehensive PDF reports for all destinations</span>
            </li>
            <li className="flex items-start">
              <span className="text-electric mr-3">▸</span>
              <span className="text-gray-300">Real-time flight and accommodation tracking</span>
            </li>
            <li className="flex items-start">
              <span className="text-electric mr-3">▸</span>
              <span className="text-gray-300">24/7 voice assistant support</span>
            </li>
            <li className="flex items-start">
              <span className="text-electric mr-3">▸</span>
              <span className="text-gray-300">Personalized relocation timeline planning</span>
            </li>
          </ul>
          
          <div className="text-center border-t border-electric/20 pt-6">
            <div className="text-3xl font-bold text-electric mb-2">$990/month</div>
            <p className="text-gray-400 text-sm mb-6">Cancel anytime, no hidden fees</p>
            
            <motion.button
              whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
              whileTap={{ scale: 0.95, backgroundColor: "#00ffff", color: "#000000", transition: { duration: 0 } }}
              className="w-full px-6 py-3 border border-electric text-electric disabled:opacity-50 disabled:cursor-not-allowed"
              onClick={handleCheckout}
              disabled={initiatingCheckout}
            >
              {initiatingCheckout ? "Processing..." : "Subscribe Now"}
            </motion.button>
          </div>
        </div>
        
        <div className="text-center">
          <p className="text-gray-400 text-sm">
            Secure payment processed by Polar
          </p>
          <p className="text-gray-400 text-sm mt-2">
            By subscribing, you agree to our terms of service and privacy policy
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/actions.tsx">
"use server";

import { createStreamableUI } from "@ai-sdk/rsc";
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import { signOut } from "@workos-inc/authkit-nextjs";

//TODO: Add OPENAI_API_KEY to .env.local
// Get from: https://platform.openai.com/api-keys

export async function signOutAction() {
  await signOut();
}

export async function streamSearchResults(fromCity: string, toCity: string) {
  const ui = createStreamableUI();
  
  // Start with loading state
  ui.update(
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {["cheapest", "fastest", "convenient", "premium"].map((type) => (
        <div key={type} className="card p-6 loading-pulse">
          <div className="h-4 bg-gray-800 rounded w-3/4 mb-4" />
          <div className="h-3 bg-gray-800 rounded w-full mb-2" />
          <div className="h-3 bg-gray-800 rounded w-5/6" />
        </div>
      ))}
    </div>
  );

  // Generate search results
  (async () => {
    try {
      //TODO: Replace with actual Exa search when API key is configured
      const prompt = `Analyze relocation options from ${fromCity} to ${toCity}. 
                      Provide 4 options: cheapest, fastest, most convenient, and premium.
                      For each, include visa type, timeline, and estimated total cost.
                      Format as JSON array with fields: type, visaType, timeline, totalCost, highlights`;

      const result = await generateText({
        model: openai("gpt-4o"),
        prompt,
      });

      // Parse and display results
      try {
        const options = JSON.parse(result.text);
        
        ui.done(
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {options.map((option: {type: string; visaType: string; timeline: string; totalCost: string; highlights?: string[]}) => (
              <div
                key={option.type}
                className={`card p-6 border ${getTypeColor(option.type)}`}
              >
                <h3 className={`font-bold text-lg mb-4 ${getTypeColor(option.type).split(" ")[0]}`}>
                  {getTitle(option.type)}
                </h3>
                <div className="space-y-3 text-sm">
                  <div>
                    <span className="text-gray-500">Visa Type:</span>
                    <p className="font-semibold">{option.visaType}</p>
                  </div>
                  <div>
                    <span className="text-gray-500">Timeline:</span>
                    <p className="font-semibold">{option.timeline}</p>
                  </div>
                  <div>
                    <span className="text-gray-500">Total Cost:</span>
                    <p className="font-semibold text-lg">{option.totalCost}</p>
                  </div>
                  {option.highlights && (
                    <ul className="space-y-1 text-xs text-gray-400">
                      {option.highlights.map((item: string, i: number) => (
                        <li key={i}>• {item}</li>
                      ))}
                    </ul>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      } catch {
        // Fallback to mock data if parsing fails
        const mockOptions = [
          {
            type: "cheapest",
            visaType: "Working Holiday Visa",
            timeline: "3-4 weeks",
            totalCost: "£3,500",
            highlights: ["Budget airlines", "Shared accommodation", "DIY application"]
          },
          {
            type: "fastest",
            visaType: "Priority Skilled Worker",
            timeline: "5-7 days",
            totalCost: "£12,000",
            highlights: ["Express processing", "Premium flights", "Relocation service"]
          },
          {
            type: "convenient",
            visaType: "Standard Skilled Worker",
            timeline: "2-3 weeks",
            totalCost: "£7,500",
            highlights: ["Full service support", "Direct flights", "Temporary housing"]
          },
          {
            type: "premium",
            visaType: "Investor Visa",
            timeline: "1-2 weeks",
            totalCost: "£25,000",
            highlights: ["VIP processing", "Business class", "Luxury accommodation"]
          }
        ];

        ui.done(
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {mockOptions.map((option) => (
              <div
                key={option.type}
                className={`card p-6 border ${getTypeColor(option.type)}`}
              >
                <h3 className={`font-bold text-lg mb-4 ${getTypeColor(option.type).split(" ")[0]}`}>
                  {getTitle(option.type)}
                </h3>
                <div className="space-y-3 text-sm">
                  <div>
                    <span className="text-gray-500">Visa Type:</span>
                    <p className="font-semibold">{option.visaType}</p>
                  </div>
                  <div>
                    <span className="text-gray-500">Timeline:</span>
                    <p className="font-semibold">{option.timeline}</p>
                  </div>
                  <div>
                    <span className="text-gray-500">Total Cost:</span>
                    <p className="font-semibold text-lg">{option.totalCost}</p>
                  </div>
                  {option.highlights && (
                    <ul className="space-y-1 text-xs text-gray-400">
                      {option.highlights.map((item: string, i: number) => (
                        <li key={i}>• {item}</li>
                      ))}
                    </ul>
                  )}
                </div>
              </div>
            ))}
          </div>
        );
      }
    } catch {
      ui.error(
        <div className="text-red-500">
          Failed to generate search results. Please try again.
        </div>
      );
    }
  })();

  return ui.value;
}

function getTypeColor(type: string) {
  switch (type) {
    case "cheapest": return "text-green-400 border-green-400/30";
    case "fastest": return "text-blue-400 border-blue-400/30";
    case "convenient": return "text-purple-400 border-purple-400/30";
    case "premium": return "text-yellow-400 border-yellow-400/30";
    default: return "text-gray-400 border-gray-400/30";
  }
}

function getTitle(type: string) {
  switch (type) {
    case "cheapest": return "Cheapest Option";
    case "fastest": return "Fastest Option";
    case "convenient": return "Most Convenient";
    case "premium": return "Premium Option";
    default: return type;
  }
}
</file>

<file path="src/app/page.tsx">
"use client";

import { useState } from "react";
import { LandingHero } from "@/components/LandingHero";
import { VapiConversationIndicator } from "@/components/VapiConversationIndicator";
import { SimulationModal } from "@/components/SimulationModal";
import { useRouter } from "next/navigation";
import { useVapi } from "@/providers/VapiProvider";

export default function Home() {
  const [userName, setUserName] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [isSimulationOpen, setIsSimulationOpen] = useState(false);
  const router = useRouter();
  const { endCall, isCallActive } = useVapi();

  const handleStart = async () => {
    if (!userName.trim()) return;

    setIsLoading(true);

    // Store user name in sessionStorage for the consultation page
    sessionStorage.setItem("userName", userName);

    // Navigate to consultation page
    router.push("/consultation");

    // Don't start the call here - let user start it manually from consultation page
  };

  return (
    <main className="min-h-screen bg-black flex items-center justify-center ">
      <LandingHero
        userName={userName}
        setUserName={setUserName}
        onStart={handleStart}
        isLoading={isLoading}
        onOpenSimulation={async () => {
          if (isCallActive) {
            await endCall();
          }
          setIsSimulationOpen(true);
        }}
      />

      {/* Show the Vapi indicator with showAlways prop */}
      {!isSimulationOpen && <VapiConversationIndicator showAlways={true} />}

      {/* Simulation Modal */}
      <SimulationModal
        isOpen={isSimulationOpen}
        onClose={() => setIsSimulationOpen(false)}
        startCity=""
        destinationCity=""
      />
    </main>
  );
}
</file>

<file path="src/components/Navigation.tsx">
"use client";

import { getSignInUrl, withAuth } from "@workos-inc/authkit-nextjs";
import Link from "next/link";
import { useEffect, useState } from "react";
import { motion } from "motion/react";
import { signOutAction } from "@/app/actions";

type User = {
  id: string;
  email: string | null;
  firstName: string | null;
  lastName: string | null;
};

export function Navigation() {
  const [user, setUser] = useState<User | null>(null);
  const [signInUrl, setSignInUrl] = useState<string>("");
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchAuth() {
      try {
        const { user: authUser } = await withAuth();
        setUser(authUser);
        if (!authUser) {
          const url = await getSignInUrl();
          setSignInUrl(url);
        }
      } catch (error) {
        console.error("Auth error:", error);
        const url = await getSignInUrl();
        setSignInUrl(url);
      } finally {
        setLoading(false);
      }
    }
    fetchAuth();
  }, []);

  return (
    <nav className="fixed top-0 left-0 right-0 z-50 bg-black/80 backdrop-blur-sm border-b border-electric">
      <div className="max-w-7xl mx-auto container px-8 py-4">
        <div className="flex items-center justify-between">
          <Link
            href="/"
            className="text-2xl font-bold text-electric hover:text-white transition-colors"
          >
            GULLIE
          </Link>

          <div className="flex items-center gap-6 min-h-[40px]">
            {loading ? (
              // Loading skeleton with same dimensions as actual content
              <div className="h-10 w-24 bg-electric/20 animate-pulse rounded" />
            ) : user ? (
              <>
                <Link href="/account">
                  <motion.button
                    whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                    whileTap={{
                      scale: 0.95,
                      backgroundColor: "#00ffff",
                      color: "#000000",
                      transition: { duration: 0 }
                    }}
                    className="px-4 py-2 border border-electric text-electric"
                  >
                    Account
                  </motion.button>
                </Link>

                <Link href="/billing">
                  <motion.button
                    whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                    whileTap={{
                      scale: 0.95,
                      backgroundColor: "#00ffff",
                      color: "#000000",
                      transition: { duration: 0 }
                    }}
                    className="px-4 py-2 border border-electric text-electric"
                  >
                    Billing
                  </motion.button>
                </Link>

                <div className="flex items-center gap-4">
                  <span className="text-electric/80 text-sm">
                    {user.firstName || user.email}
                  </span>

                  <form action={signOutAction}>
                    <motion.button
                      type="submit"
                      whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                      whileTap={{
                        scale: 0.95,
                        backgroundColor: "#ff0000",
                        color: "#ffffff",
                        transition: { duration: 0 }
                      }}
                      className="px-4 py-2 border border-red-500 text-red-500"
                    >
                      Sign Out
                    </motion.button>
                  </form>
                </div>
              </>
            ) : (
              <Link href={signInUrl}>
                <motion.button
                  whileHover={{ scale: 1.05, x: 2, y: -2, transition: { duration: 0.05 } }}
                  whileTap={{
                    scale: 0.95,
                    backgroundColor: "#00ffff",
                    color: "#000000",
                    transition: { duration: 0 }
                  }}
                  className="px-6 py-2 border border-electric text-electric"
                >
                  Sign In
                </motion.button>
              </Link>
            )}
          </div>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="src/middleware.ts">
import { authkitMiddleware } from "@workos-inc/authkit-nextjs";

export default authkitMiddleware({
  redirectUri:
    process.env.VERCEL_TARGET_ENV === "preview" ||
    process.env.VERCEL_TARGET_ENV === "production"
      ? `https://${process.env.NEXT_PUBLIC_VERCEL_URL ?? "gullie-travel-planner.vercel.app"}${process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI}`
      : `http://localhost:3000${process.env.NEXT_PUBLIC_WORKOS_REDIRECT_URI}`,
});

// Match against pages that require auth
export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Protect API routes
    "/(api|trpc)(.*)",
    // Protect authenticated pages
    "/dashboard/:path*",
    "/account/:path*",
    "/billing/:path*",
    "/subscription/:path*",
  ],
};
</file>

<file path="CLAUDE.md">
## Must do

1. always do typescript lint check at the end of execution to make sure all files build successfully

2. be succinct and structure about the code style. don't emit, write trash and redundant, extra code

3. Font will be using `Distek Mono` and dark theme, electric, stylish but simple. Do not use rounded corners on buttons and inputs. Scale buttons on X and Y position and tranform them when they are hovered on, change to opposite color theme when they are clicked on.

4. check with convex documentation via context7 and deepwiki to see how to use convex within the `/convex` folder before implementation.

5. use context7 and deepwiki to check how to use Vapi to have both web calls and phone calls

6. use context7 and deepwiki to have a good understanding of model context protocol, A2A protocol

7. use context7 and deepwiki to understand vercel AI sdk, vercel's AI SDK UI to implement elegant frontend

8. use context7 and deepwiki to understand streaming

9. use context7 and deepwiki to understand Resend and how to send email to users and what environment variable we need

10. use context7 and deepwiki to understand how to use Polar (https://polar.sh) to charge users and what environment variable we need

11. do not use env var in code base. never use env var in codebase, always use `process.env.something-var`

Refer to implementation plan in `IMPLEMENTATION_PLAN.md`

Always run `pnpm build` to test if there is problem with production deployment
</file>

<file path="convex/_generated/api.d.ts">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as city from "../city.js";
import type * as conversations from "../conversations.js";
import type * as emails_RelocationReport from "../emails/RelocationReport.js";
import type * as http from "../http.js";
import type * as mcp from "../mcp.js";
import type * as mutate_city from "../mutate/city.js";
import type * as mutate_date from "../mutate/date.js";
import type * as mutate_flight from "../mutate/flight.js";
import type * as mutate_rental from "../mutate/rental.js";
import type * as query_city from "../query/city.js";
import type * as schemas_city from "../schemas/city.js";
import type * as schemas_conversation from "../schemas/conversation.js";
import type * as schemas_date from "../schemas/date.js";
import type * as schemas_document from "../schemas/document.js";
import type * as schemas_flight from "../schemas/flight.js";
import type * as schemas_message from "../schemas/message.js";
import type * as schemas_rental from "../schemas/rental.js";
import type * as schemas_subscription from "../schemas/subscription.js";
import type * as schemas_user from "../schemas/user.js";
import type * as schemas_visa from "../schemas/visa.js";
import type * as schemas_zod_schemas from "../schemas/zod_schemas.js";
import type * as simulations from "../simulations.js";
import type * as storage from "../storage.js";
import type * as subscriptions from "../subscriptions.js";
import type * as tools_citySearch from "../tools/citySearch.js";
import type * as tools_conversationTracker from "../tools/conversationTracker.js";
import type * as tools_costEstimation from "../tools/costEstimation.js";
import type * as tools_documentDetails from "../tools/documentDetails.js";
import type * as tools_emailCapture from "../tools/emailCapture.js";
import type * as tools_pdfSender from "../tools/pdfSender.js";
import type * as tools_updateUserReport from "../tools/updateUserReport.js";
import type * as tools_visaRequirements from "../tools/visaRequirements.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  city: typeof city;
  conversations: typeof conversations;
  "emails/RelocationReport": typeof emails_RelocationReport;
  http: typeof http;
  mcp: typeof mcp;
  "mutate/city": typeof mutate_city;
  "mutate/date": typeof mutate_date;
  "mutate/flight": typeof mutate_flight;
  "mutate/rental": typeof mutate_rental;
  "query/city": typeof query_city;
  "schemas/city": typeof schemas_city;
  "schemas/conversation": typeof schemas_conversation;
  "schemas/date": typeof schemas_date;
  "schemas/document": typeof schemas_document;
  "schemas/flight": typeof schemas_flight;
  "schemas/message": typeof schemas_message;
  "schemas/rental": typeof schemas_rental;
  "schemas/subscription": typeof schemas_subscription;
  "schemas/user": typeof schemas_user;
  "schemas/visa": typeof schemas_visa;
  "schemas/zod_schemas": typeof schemas_zod_schemas;
  simulations: typeof simulations;
  storage: typeof storage;
  subscriptions: typeof subscriptions;
  "tools/citySearch": typeof tools_citySearch;
  "tools/conversationTracker": typeof tools_conversationTracker;
  "tools/costEstimation": typeof tools_costEstimation;
  "tools/documentDetails": typeof tools_documentDetails;
  "tools/emailCapture": typeof tools_emailCapture;
  "tools/pdfSender": typeof tools_pdfSender;
  "tools/updateUserReport": typeof tools_updateUserReport;
  "tools/visaRequirements": typeof tools_visaRequirements;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;
</file>

<file path="convex/schema.ts">
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { message } from "./schemas/message";
import { user } from "./schemas/user";
import { city } from "./schemas/city";
import { date } from "./schemas/date";
import { visa } from "./schemas/visa";
import { flight } from "./schemas/flight";
import { rental } from "./schemas/rental";
import { document } from "./schemas/document";
import { subscriptionSchema, checkoutSchema } from "./schemas/subscription";
import { conversation } from "./schemas/conversation";

export default defineSchema({
  messages: defineTable(message).vectorIndex("by_embedding", {
    dimensions: 1536,
    vectorField: "embedding",
    filterFields: ["body"],
  }),

  users: defineTable(user),

  // initial prompt - we will have created date to run simulation at here
  cities: defineTable(city),

  // user input dates at here
  dates: defineTable(date),

  visa_options: defineTable(visa),

  // simulation case results - 3 simulation ahead for each moving plan
  flights: defineTable(flight),

  rentals: defineTable(rental),
  
  // Generated PDF documents for users
  documents: defineTable(document)
    .index("by_user", ["userId"])
    .index("by_email", ["email"]),
    
  // Subscription data from Polar
  subscriptions: defineTable(subscriptionSchema)
    .index("by_polar_id", ["polarId"])
    .index("by_user_id", ["userId"])
    .index("by_status", ["status"]),
    
  // Checkout records from Polar
  checkouts: defineTable(checkoutSchema)
    .index("by_checkout_id", ["checkoutId"])
    .index("by_customer_id", ["customerId"]),
    
  // Vapi conversation history
  conversations: defineTable(conversation)
    .index("by_call_id", ["callId"])
    .index("by_session_id", ["sessionId"])
    .index("by_user_id", ["userId"])
    .index("by_email", ["userEmail"])
    .index("by_phone", ["phoneNumber"])
    .index("by_status", ["status"])
    .vectorIndex("by_embedding", {
      dimensions: 1536,
      vectorField: "embedding",
    }),
});
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";
import { ConvexClientProvider } from "@/providers/ConvexClientProvider";
import { VapiProvider } from "@/providers/VapiProvider";
import { AuthKitProvider } from "@workos-inc/authkit-nextjs/components";
import { Navigation } from "@/components/Navigation";

const distekMono = localFont({
  src: [
    {
      path: "../../public/fonts/Disket-Mono-Regular.ttf",
      weight: "400",
      style: "normal",
    },
    {
      path: "../../public/fonts/Disket-Mono-Bold.ttf",
      weight: "700",
      style: "normal",
    },
  ],
  variable: "--font-distek-mono",
  fallback: ["monospace"],
});

export const metadata: Metadata = {
  title: "Gullie - Global Mobility Expert",
  description:
    "Your AI-powered global relocation consultant. Get visa guidance, flight options, housing solutions, and comprehensive relocation support.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="dark">
      <body
        className={`${distekMono.variable} font-mono antialiased bg-black text-white min-h-screen`}
      >
        <AuthKitProvider>
          <ConvexClientProvider>
            <VapiProvider>
              <Navigation />
              <div className="flex flex-col items-center justify-center p-8 pt-24 min-h-screen">{children}</div>
            </VapiProvider>
          </ConvexClientProvider>
        </AuthKitProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/components/LandingHero.tsx">
"use client";

import { VapiConversationIndicator } from "./VapiConversationIndicator";
import { useVapi } from "@/providers/VapiProvider";
import DecryptedText from "./DecryptedText";
import { motion } from "motion/react";

interface LandingHeroProps {
  userName: string;
  setUserName: (name: string) => void;
  onStart: () => void;
  isLoading?: boolean;
  onOpenSimulation: () => void;
}

export function LandingHero({
  userName,
  setUserName,
  onStart,
  isLoading,
  onOpenSimulation,
}: LandingHeroProps) {
  const { startCall, endCall, isCallActive } = useVapi();

  return (
    <div className="w-full max-w-5xl mx-auto">
      <div className="flex flex-col items-center justify-center gap-10">
        {/* Header Section */}
        <div className="text-center py-10 flex flex-col items-center space-y-6">
          <h1 className="text-2xl md:text-8xl font-bold">
            <DecryptedText
              text="GULLIE"
              animateOn="view"
              speed={80}
              maxIterations={15}
              characters="G0UL1L3IE#@$%"
              className="gradient-text"
              encryptedClassName="text-gray-600"
              parentClassName="animate-pulse"
            />
          </h1>
          <p className="text-6xl font-semibold md:text-3xl text-gray-300">
            <DecryptedText
              text="Your AI Global Mobility Expert"
              animateOn="view"
              speed={30}
              sequential={true}
              revealDirection="center"
              className="text-gray-300"
              encryptedClassName="text-gray-700"
            />
          </p>
          <p className="text-lg md:text-xl text-gray-400 max-w-3xl mx-auto mt-4">
            <DecryptedText
              text="Navigate global relocation with confidence. Get personalized visa guidance, flight options, housing solutions, and comprehensive support."
              animateOn="view"
              speed={20}
              sequential={true}
              revealDirection="start"
              className="text-gray-400"
              encryptedClassName="text-gray-800"
            />
          </p>
        </div>

        {/* Input Section */}
        <div className="w-full max-w-xl gap-8 flex flex-col items-center">
          <div className="gap-4 flex flex-col items-center">
            <label
              htmlFor="name"
              className="block text-2xl font-semibold text-gray-50"
            >
              Enter your name to begin
            </label>
            <input
              id="name"
              type="text"
              value={userName}
              onChange={(e) => setUserName(e.target.value)}
              placeholder="John Doe"
              className="w-full px-6 py-4 text-lg bg-gray-900 border border-gray-700 focus:border-green-500 transition-colors"
              onKeyDown={(e) => {
                if (e.key === "Enter" && !isLoading) onStart();
              }}
              disabled={isLoading}
            />
          </div>

          {/* Action Buttons - Direct triggers */}
          <div className="w-full flex gap-4">
            {!isCallActive ? (
              <>
                <motion.button
                  onClick={() => startCall(userName || "Guest")}
                  className="flex-1 px-6 py-4 bg-gray-400 text-black 
                             font-bold uppercase tracking-wider text-xl border border-green-400"
                  style={{
                    boxShadow: "0 4px 12px rgba(34, 197, 94, 0.3)",
                  }}
                  whileHover={{
                    scaleX: 1.05,
                    scaleY: 1.05,
                    backgroundColor: "#16a34a",
                    transition: { duration: 0.05 },
                  }}
                  whileTap={{
                    backgroundColor: "#ffffff",
                    color: "#000000",
                    transition: { duration: 0 },
                  }}
                >
                  🎤 Start Voice Consultation
                </motion.button>
                <motion.button
                  onClick={onOpenSimulation}
                  className="flex-1 px-6 py-4 bg-gray-400 text-black 
                             font-bold uppercase tracking-wider text-xl border border-green-400"
                  style={{
                    boxShadow: "0 4px 12px rgba(34, 197, 94, 0.3)",
                  }}
                  whileHover={{
                    scaleX: 1.05,
                    scaleY: 1.05,
                    backgroundColor: "#16a34a",
                    transition: { duration: 0.05 },
                  }}
                  whileTap={{
                    backgroundColor: "#ffffff",
                    color: "#000000",
                    transition: { duration: 0 },
                  }}
                >
                  📊 Run Simulations
                </motion.button>
              </>
            ) : (
              <motion.button
                onClick={endCall}
                className="flex-1 px-6 py-4 bg-red-500 text-white 
                           font-bold uppercase tracking-wider text-2xl border border-red-400"
                style={{
                  boxShadow: "0 4px 12px rgba(239, 68, 68, 0.3)",
                }}
                whileHover={{
                  scaleX: 1.05,
                  scaleY: 1.05,
                  backgroundColor: "#dc2626",
                  transition: { duration: 0.05 },
                }}
                whileTap={{
                  backgroundColor: "#ffffff",
                  color: "#000000",
                  transition: { duration: 0 },
                }}
              >
                End Call
              </motion.button>
            )}
          </div>
          <div className="text-center gap-4 flex flex-col text-xs text-gray-600">
            <p>
              We analyze cheapest, fastest, most expensive, and most convenient
              options
            </p>
            <p>Personalized PDF reports delivered to your email</p>
            <div className="mt-4 pt-4 border-t border-gray-800">
              <p className="text-green-400 text-xl font-bold">
                📞 Call us directly:{" "}
                <DecryptedText
                  text="+1 (628) 241 4121"
                  speed={50}
                  characters="0123456789+-() "
                  useOriginalCharsOnly={true}
                  className="text-green-400"
                  encryptedClassName="text-green-700"
                />
              </p>
              <p className="text-gray-500 text-xs mt-1">
                Available 24/7 for voice consultations
              </p>
            </div>
          </div>
          <VapiConversationIndicator />
        </div>

        {/* Features Grid */}
        <div className="flex gap-10 w-full">
          <div className="card p-8 space-y-3 hover:scale-105 transition-transform">
            <div className="text-green-400 text-3xl mb-2">🤖</div>
            <h3 className="text-green-400 font-semibold text-lg">
              <DecryptedText
                text="AI-Powered Support"
                speed={40}
                maxIterations={10}
                className="text-green-400"
                encryptedClassName="text-green-900"
              />
            </h3>
            <p className="text-sm text-gray-400">
              24/7 phone and web assistance with real-time guidance
            </p>
          </div>

          <div className="card p-8 space-y-3 hover:scale-105 transition-transform">
            <div className="text-blue-400 text-3xl mb-2">🌍</div>
            <h3 className="text-blue-400 font-semibold text-lg">
              <DecryptedText
                text="Comprehensive Solutions"
                speed={40}
                maxIterations={10}
                className="text-blue-400"
                encryptedClassName="text-blue-900"
              />
            </h3>
            <p className="text-sm text-gray-400">
              Visa, flights, housing, and school enrollment in one place
            </p>
          </div>

          <div className="card p-8 space-y-3 hover:scale-105 transition-transform">
            <div className="text-purple-400 text-3xl mb-2">💰</div>
            <h3 className="text-purple-400 font-semibold text-lg">
              <DecryptedText
                text="Transparent Pricing"
                speed={40}
                maxIterations={10}
                className="text-purple-400"
                encryptedClassName="text-purple-900"
              />
            </h3>
            <p className="text-sm text-gray-400">
              $990/month until your relocation is completed, first month free
            </p>
          </div>
        </div>

        {/* Footer Info */}
      </div>
    </div>
  );
}
</file>

<file path="src/components/VapiConversationIndicator.tsx">
"use client";

import { useVapi } from "@/providers/VapiProvider";
import { useEffect, useState } from "react";

interface VapiConversationIndicatorProps {
  showAlways?: boolean; // Show even when call is not active
}

export function VapiConversationIndicator({ showAlways = false }: VapiConversationIndicatorProps = {}) {
  const { isCallActive, isSpeaking, transcript } = useVapi();
  const [pulseAnimation, setPulseAnimation] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);

  useEffect(() => {
    if (isSpeaking) {
      setPulseAnimation(true);
      const timer = setTimeout(() => setPulseAnimation(false), 1000);
      return () => clearTimeout(timer);
    }
  }, [isSpeaking]);

  useEffect(() => {
    setIsExpanded(isCallActive);
  }, [isCallActive]);

  // Only hide if not showAlways and call is not active
  if (!showAlways && !isCallActive) return null;

  const lastTranscript = transcript[transcript.length - 1];

  return (
    <div className="fixed bottom-8 right-8 z-50">
      <div className="relative">
        {/* Main conversation card - transitions between small square and full size */}
        <div 
          className={`bg-black border border-green-500/30 flex flex-col transition-all duration-500 ease-in-out ${
            isExpanded 
              ? 'w-[400px] h-[420px] p-6' 
              : 'w-[80px] h-[80px] p-4 cursor-pointer hover:scale-105'
          }`}
          onClick={() => !isExpanded && setIsExpanded(true)}
        >
          {isExpanded ? (
            <>
              {/* Expanded view - Full conversation interface */}
              {/* Header */}
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-3">
                  {/* Animated microphone icon */}
                  <div className="relative">
                    <div className={`absolute inset-0 bg-green-500/20 ${pulseAnimation ? 'animate-ping' : ''}`}></div>
                    <div className="relative w-12 h-12 bg-green-500/10 border border-green-500 flex items-center justify-center">
                      <svg 
                        className={`w-6 h-6 ${isSpeaking ? 'text-green-500' : 'text-green-400'}`}
                        fill="currentColor" 
                        viewBox="0 0 20 20"
                      >
                        <path fillRule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clipRule="evenodd" />
                      </svg>
                    </div>
                  </div>
                  <div>
                    <h3 className="text-green-500 font-bold text-sm uppercase tracking-wider">
                      Gullie Agent
                    </h3>
                    <p className="text-xs text-gray-500">
                      {!isCallActive ? "Ready to connect" : isSpeaking ? "Speaking..." : "Listening..."}
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {isCallActive ? (
                    <>
                      <div className="relative">
                        <div className="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                        <div className="absolute inset-0 w-3 h-3 bg-green-500 rounded-full animate-ping"></div>
                      </div>
                      <span className="text-xs text-green-500 font-medium">LIVE</span>
                    </>
                  ) : (
                    <>
                      <button 
                        onClick={(e) => {
                          e.stopPropagation();
                          setIsExpanded(false);
                        }}
                        className="text-gray-500 hover:text-green-500 transition-colors"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    </>
                  )}
                </div>
              </div>

              {/* Audio visualization */}
              <div className="mb-4 flex-shrink-0">
                <div className="flex items-center justify-center gap-1 h-16">
                  {[...Array(20)].map((_, i) => (
                    <div
                      key={i}
                      className={`bg-green-500 transition-all duration-150 ${
                        isSpeaking 
                          ? 'animate-pulse' 
                          : 'opacity-30'
                      }`}
                      style={{
                        width: '3px',
                        height: isSpeaking 
                          ? `${Math.random() * 100}%` 
                          : '20%',
                        animationDelay: `${i * 50}ms`,
                        transform: isSpeaking ? 'scaleY(1)' : 'scaleY(0.3)',
                        transition: 'all 0.3s ease'
                      }}
                    />
                  ))}
                </div>
              </div>

              {/* Latest transcript */}
              <div className="border-t border-green-500/20 pt-4 flex-1 overflow-hidden">
                {lastTranscript ? (
                  <>
                    <p className="text-xs text-gray-500 mb-1 uppercase tracking-wider">
                      {lastTranscript.role === 'user' ? 'You' : 'Agent'}:
                    </p>
                    <div className="overflow-y-auto max-h-[100px]">
                      <p className="text-sm text-gray-300 leading-relaxed">
                        {lastTranscript.text}
                      </p>
                    </div>
                  </>
                ) : (
                  <p className="text-xs text-gray-500 uppercase tracking-wider">
                    Waiting for conversation...
                  </p>
                )}
              </div>

              {/* Instructions */}
              <div className="mt-4 pt-4 border-t border-green-500/20 flex-shrink-0">
                <p className="text-xs text-gray-600">
                  {isCallActive 
                    ? "Speak naturally to provide your destination city"
                    : "Voice assistant ready - Start a consultation to begin"}
                </p>
              </div>
            </>
          ) : (
            /* Collapsed view - Small square with pulsing icon */
            <div className="flex items-center justify-center w-full h-full">
              <div className="relative">
                <div className="absolute inset-0 bg-green-500/20 animate-ping"></div>
                <svg 
                  className="w-8 h-8 text-green-500 relative z-10"
                  fill="currentColor" 
                  viewBox="0 0 20 20"
                >
                  <path fillRule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clipRule="evenodd" />
                </svg>
              </div>
            </div>
          )}
        </div>

        {/* Electric glow effect - only when expanded */}
        {isExpanded && (
          <div 
            className="absolute inset-0 bg-green-500/5 blur-xl -z-10 transition-opacity duration-500"
            style={{
              filter: 'blur(40px)',
              transform: 'scale(1.2)'
            }}
          />
        )}
      </div>
    </div>
  );
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"],
      "@convex/*": ["./convex/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "scripts/**/*"]
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --font-distek-mono: "Distek Mono", monospace;
}

@theme inline {
  --font-mono: var(--font-distek-mono);
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
}

html,
body {
  background-color: #000000;
  color: #ffffff;
  font-family: var(--font-distek-mono), monospace;
  overflow-x: hidden;
}

button {
  cursor: pointer;
  transform-style: preserve-3d;
  border-radius: 0;
}

input,
textarea {
  border-radius: 0;
  background-color: #0a0a0a;
  border: 1px solid #333333;
  color: #ffffff;
  font-family: var(--font-distek-mono), monospace;
}

input:focus,
textarea:focus {
  outline: none;
  border-color: #00ff88;
  box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
}

.electric-border {
  position: relative;
  background: linear-gradient(45deg, #00ff88, #00ffff, #ff00ff, #ffff00);
  background-size: 400% 400%;
  animation: electric 5s ease infinite;
}

@keyframes electric {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

.card {
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
  border: 1px solid #333333;
  transition: all 0.1s ease;
}

.card:hover {
  border-color: #00ff88;
  transform: translateY(-2px);
  box-shadow: 0 10px 30px rgba(0, 255, 136, 0.2);
}

.loading-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.gradient-text {
  background: linear-gradient(90deg, #00ff88, #00ffff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Ensure proper spacing utilities */
.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: 1.5rem;
  padding-left: 1.5rem;
}

@media (min-width: 640px) {
  .container {
    max-width: 640px;
  }
}

@media (min-width: 768px) {
  .container {
    max-width: 768px;
  }
}

@media (min-width: 1024px) {
  .container {
    max-width: 1024px;
  }
}

@media (min-width: 1280px) {
  .container {
    max-width: 1280px;
  }
}

@media (min-width: 1536px) {
  .container {
    max-width: 1536px;
  }
}

/* Text selection styling - neon green background with black text */
::selection {
  background-color: #00ff00;
  color: #000000;
}

::-moz-selection {
  background-color: #00ff00;
  color: #000000;
}

/* Apply to all elements */
*::selection {
  background-color: #00ff00;
  color: #000000;
}

*::-moz-selection {
  background-color: #00ff00;
  color: #000000;
}

/* Ensure it works for input and textarea elements */
input::selection,
textarea::selection {
  background-color: #00ff00;
  color: #000000;
}

input::-moz-selection,
textarea::-moz-selection {
  background-color: #00ff00;
  color: #000000;
}
</file>

<file path="package.json">
{
  "name": "gullie-travel-planner",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@ai-sdk/openai": "^2.0.19",
    "@ai-sdk/react": "^2.0.22",
    "@ai-sdk/rsc": "^1.0.22",
    "@ai-sdk/xai": "^2.0.11",
    "@modelcontextprotocol/sdk": "^1.17.4",
    "@polar-sh/nextjs": "^0.4.4",
    "@polar-sh/sdk": "^0.34.13",
    "@react-email/components": "^0.5.1",
    "@react-email/render": "^1.2.1",
    "@types/jspdf": "^2.0.0",
    "@vapi-ai/web": "^2.3.8",
    "@workos-inc/authkit-nextjs": "^2.5.0",
    "ai": "^5.0.22",
    "convex": "^1.26.1",
    "dotenv": "^17.2.1",
    "exa-js": "^1.9.1",
    "html2canvas": "^1.4.1",
    "html2pdf.js": "^0.11.0",
    "jspdf": "^3.0.1",
    "motion": "^12.23.12",
    "next": "15.5.0",
    "openai": "^5.15.0",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "resend": "^6.0.1",
    "zod": "^4.0.17"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.0",
    "prettier": "^3.6.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

</files>
